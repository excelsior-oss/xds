<* M2EXTENSIONS+ *>
<* ALIGNMENT="8" *>
<* ENUMSIZE="4" *>
<* SETSIZE="4" *>

(*****************************************************************************\
*                                                                             *
* CommCtrl.def - Interface for the Windows Common Controls                    *
*                                                                             *
* Version 1.2                                                                 *
*                                                                             *
* XDS team thanks Alexander Naumov for submitting this file                   *
*                                                                             *
\*****************************************************************************)


DEFINITION MODULE ["StdCall"] CommCtrl;

IMPORT SYSTEM;
FROM WinDef  IMPORT BOOL, UINT, BYTE, WCHAR, WORD, DWORD, LONG, 
                    WPARAM, LPARAM, LRESULT,
                    PVOID, PSTR, PCSTR, PWSTR, PCWSTR, INTARRAY,
                    PUINT, PINT, PPOINT, PRECT, PCRECT, CALLBACK,
                    HWND, HINSTANCE, HICON, HBITMAP, HPALETTE, HMENU, HDC, HBRUSH, HPEN,
                    HCURSOR, HFONT, COLORREF, POINT, RECT, SIZEL;
FROM WinUser IMPORT WM_USER, SC_SIZE, NMHDR, PWINDOWPOS, PDLGTEMPLATE, DLGPROC,
                    MSG, SCROLLINFO, PSCROLLINFO, CB_DELETESTRING,
                    TRACKMOUSEEVENT, IMAGE_TYPE, DT_SET,
                    WS_ENUM, WS_SET, LR_SET, KF_SET, SB_TYPE, ESB_SET, WNDPROC;
FROM WinBase IMPORT SYSTEMTIME, PSYSTEMTIME;
FROM WinGDI  IMPORT ROP, BKMODE_ENUM;
FROM WinReg  IMPORT HKEY;

TYPE
  HRESULT = LONG;

  COMMCTRL_PSTREAM = PVOID; (* actually pointer to IStream *)


<* PUSH *> <* ALIGNMENT="1" *>


(*****************************************************************************\
*                                                                             *
* Interface for the Windows Property Sheet Pages (based on prsht.h)           *
*                                                                             *
\*****************************************************************************)



CONST
  MAXPROPPAGES = 100;

TYPE
  HPROPSHEETPAGE = POINTER TO RECORD END;

  PSP_ENUM = (
    PSP__DLGINDIRECT,         (*  0 *)
    PSP__USEHICON,            (*  1 *)
    PSP__USEICONID,           (*  2 *)
    PSP__USETITLE,            (*  3 *)
    PSP__RTLREADING,          (*  4 *)
    PSP__HASHELP,             (*  5 *)
    PSP__USEREFPARENT,        (*  6 *)
    PSP__USECALLBACK,         (*  7 *)
    PSP__8,                   (*  8 *)
    PSP__9,                   (*  9 *)
    PSP__PREMATURE,           (* 10 *)
    PSP__HIDEHEADER,          (* 11 *)
    PSP__USEHEADERTITLE,      (* 12 *)
    PSP__USEHEADERSUBTITLE    (* 13 *)
  );
  PSP_SET = SET OF PSP_ENUM;

CONST
  PSP_DEFAULT           = PSP_SET {};                       (* 0000H *)
  PSP_DLGINDIRECT       = PSP_SET {PSP__DLGINDIRECT};       (* 0001H *)
  PSP_USEHICON          = PSP_SET {PSP__USEHICON};          (* 0002H *)
  PSP_USEICONID         = PSP_SET {PSP__USEICONID};         (* 0004H *)
  PSP_USETITLE          = PSP_SET {PSP__USETITLE};          (* 0008H *)
  PSP_RTLREADING        = PSP_SET {PSP__RTLREADING};        (* 0010H *)
  PSP_HASHELP           = PSP_SET {PSP__HASHELP};           (* 0020H *)
  PSP_USEREFPARENT      = PSP_SET {PSP__USEREFPARENT};      (* 0040H *)
  PSP_USECALLBACK       = PSP_SET {PSP__USECALLBACK};       (* 0080H *)
  PSP_PREMATURE         = PSP_SET {PSP__PREMATURE};         (* 0400H *)

(* IF _WIN32_IE >= 0x0400 THEN *)
(* ----- New flags for wizard97 -------------- *)
  PSP_HIDEHEADER        = PSP_SET {PSP__HIDEHEADER};        (* 0800H *)
  PSP_USEHEADERTITLE    = PSP_SET {PSP__USEHEADERTITLE};    (* 1000H *)
  PSP_USEHEADERSUBTITLE = PSP_SET {PSP__USEHEADERSUBTITLE}; (* 2000H *)
(* ------------------------------------------- *)
(* END *)

  PSPCB_RELEASE = 1;
  PSPCB_CREATE  = 2;

TYPE
  PPROPSHEETPAGEA  = POINTER TO PROPSHEETPAGEA;
  PCPROPSHEETPAGEA = PPROPSHEETPAGEA;

  PFNPSPCALLBACKA = PROCEDURE [CALLBACK] ( (* hwnd *) HWND, (* uMsg *) UINT,
                                           (* ppsp *) PPROPSHEETPAGEA ): UINT;

  PROPSHEETPAGEA = RECORD
    dwSize     : DWORD;
    dwFlags    : PSP_SET;
    hInstance  : HINSTANCE;
    CASE : INTEGER OF
        0: pszTemplate: PCSTR;
       |1: pResource  : PDLGTEMPLATE;
    END;
    CASE : INTEGER OF
        0: hIcon  : HICON;
       |1: pszIcon: PCSTR;
    END;
    pszTitle   : PCSTR;
    pfnDlgProc : DLGPROC;
    lParam     : LPARAM;
    pfnCallback: PFNPSPCALLBACKA;
    pcRefParent: PUINT;
(* IF _WIN32_IE >= 0x0400 *)
    pszHeaderTitle   : PCSTR;            (*  this is displayed in the header *)
    pszHeaderSubTitle: PCSTR;
(* END *)
  END;

CONST
  PROPSHEETPAGEA_V1_SIZE = SIZE (PROPSHEETPAGEA) - SIZE (PCSTR)  - SIZE (PCSTR);


TYPE
  PPROPSHEETPAGEW  = POINTER TO PROPSHEETPAGEW;
  PCPROPSHEETPAGEW = PPROPSHEETPAGEW;

  PFNPSPCALLBACKW = PROCEDURE [CALLBACK] ( (* hwnd *) HWND, (* uMsg *) UINT,
                                           (* ppsp *) PPROPSHEETPAGEW ): UINT;

  PROPSHEETPAGEW = RECORD
    dwSize     : DWORD;
    dwFlags    : PSP_SET;
    hInstance  : HINSTANCE;
    CASE : INTEGER OF
        0: pszTemplate: PCWSTR;
       |1: pResource  : PDLGTEMPLATE;
    END;
    CASE : INTEGER OF
        0: hIcon  : HICON;
       |1: pszIcon: PCWSTR;
    END;
    pszTitle   : PCWSTR;
    pfnDlgProc : DLGPROC;
    lParam     : LPARAM;
    pfnCallback: PFNPSPCALLBACKW;
    pcRefParent: PUINT;
(* IF _WIN32_IE >= 0x0400 THEN *)
    pszHeaderTitle   : PCWSTR;           (*  this is displayed in the header *)
    pszHeaderSubTitle: PCWSTR;
(* END *)
  END;

CONST
  PROPSHEETPAGEW_V1_SIZE = SIZE (PROPSHEETPAGEW) - SIZE (PCWSTR)  - SIZE (PCWSTR);

<* IF DEFINED (UNICODE) THEN *>
TYPE
  PFNPSPCALLBACK  = PFNPSPCALLBACKW;
  PROPSHEETPAGE   = PROPSHEETPAGEW;
  PPROPSHEETPAGE  = PPROPSHEETPAGEW;
  PCPROPSHEETPAGE = PCPROPSHEETPAGEW;
CONST
  PROPSHEETPAGE_V1_SIZE = PROPSHEETPAGEW_V1_SIZE;
<* ELSE *>
TYPE
  PFNPSPCALLBACK  = PFNPSPCALLBACKA;
  PROPSHEETPAGE   = PROPSHEETPAGEA;
  PPROPSHEETPAGE  = PPROPSHEETPAGEA;
  PCPROPSHEETPAGE = PCPROPSHEETPAGEA;
CONST
  PROPSHEETPAGE_V1_SIZE = PROPSHEETPAGEA_V1_SIZE;

<* END *>

TYPE
  PSH_ENUM = (
    PSH__PROPTITLE,         (*  0 *)
    PSH__USEHICON,          (*  1 *)
    PSH__USEICONID,         (*  2 *)
    PSH__PROPSHEETPAGE,     (*  3 *)
    PSH__4,                 (*  4 *)
    PSH__WIZARD,            (*  5 *)
    PSH__USEPSTARTPAGE,     (*  6 *)
    PSH__NOAPPLYNOW,        (*  7 *)
    PSH__USECALLBACK,       (*  8 *)
    PSH__HASHELP,           (*  9 *)
    PSH__MODELESS,          (* 10 *)
    PSH__RTLREADING,        (* 11 *)
    PSH__WIZARDCONTEXTHELP, (* 12 *)
    PSH__WIZARD97,          (* 13 *)
    PSH__14,                (* 14 *)
    PSH__WATERMARK,         (* 15 *)
    PSH__USEHBMWATERMARK,   (* 16 *)
    PSH__USEHPLWATERMARK,   (* 17 *)
    PSH__STRETCHWATERMARK,  (* 18 *)
    PSH__HEADER,            (* 19 *)
    PSH__USEHBMHEADER,      (* 20 *)
    PSH__USEPAGELANG        (* 21 *)
  );
  PSH_SET = SET OF PSH_ENUM;

CONST
  PSH_DEFAULT           = PSH_SET {};                       (* 000000H *)
  PSH_PROPTITLE         = PSH_SET {PSH__PROPTITLE};         (* 000001H *)
  PSH_USEHICON          = PSH_SET {PSH__USEHICON};          (* 000002H *)
  PSH_USEICONID         = PSH_SET {PSH__USEICONID};         (* 000004H *)
  PSH_PROPSHEETPAGE     = PSH_SET {PSH__PROPSHEETPAGE};     (* 000008H *)
  PSH_WIZARD            = PSH_SET {PSH__WIZARD};            (* 000020H *)
  PSH_USEPSTARTPAGE     = PSH_SET {PSH__USEPSTARTPAGE};     (* 000040H *)
  PSH_NOAPPLYNOW        = PSH_SET {PSH__NOAPPLYNOW};        (* 000080H *)
  PSH_USECALLBACK       = PSH_SET {PSH__USECALLBACK};       (* 000100H *)
  PSH_HASHELP           = PSH_SET {PSH__HASHELP};           (* 000200H *)
  PSH_MODELESS          = PSH_SET {PSH__MODELESS};          (* 000400H *)
  PSH_RTLREADING        = PSH_SET {PSH__RTLREADING};        (* 000800H *)
  PSH_WIZARDCONTEXTHELP = PSH_SET {PSH__WIZARDCONTEXTHELP}; (* 001000H *)

(* IF _WIN32_IE >= 0x0400 THEN *)
(* ----- New flags for wizard97 ----------- *)
  PSH_WIZARD97          = PSH_SET {PSH__WIZARD97};          (* 002000H *)
(* 00004000H was not used by any previous release *)
  PSH_WATERMARK         = PSH_SET {PSH__WATERMARK};         (* 008000H *)
  PSH_USEHBMWATERMARK   = PSH_SET {PSH__USEHBMWATERMARK};   (* 010000H *)   (*  user pass in a hbmWatermark instead of pszbmWatermark *)
  PSH_USEHPLWATERMARK   = PSH_SET {PSH__USEHPLWATERMARK};   (* 020000H *)
  PSH_STRETCHWATERMARK  = PSH_SET {PSH__STRETCHWATERMARK};  (* 040000H *)   (*  stretchwatermark also applies for the header *)
  PSH_HEADER            = PSH_SET {PSH__HEADER};            (* 080000H *)
  PSH_USEHBMHEADER      = PSH_SET {PSH__USEHBMHEADER};      (* 100000H *)
  PSH_USEPAGELANG       = PSH_SET {PSH__USEPAGELANG};       (* 200000H *)   (*  use frame dialog template matched to page *)
(* ---------------------------------------- *)
(* END *)

TYPE
  PFNPROPSHEETCALLBACK = PROCEDURE [CALLBACK] ( (* hwnd   : *) HWND,
                                                (* uMsg   : *) UINT,
                                                (* lParam : *) LPARAM ): INTEGER;

  PROPSHEETHEADERA = RECORD
    dwSize     : DWORD;
    dwFlags    : PSH_SET;
    hwndParent : HWND;
    hInstance  : HINSTANCE;
    CASE : INTEGER OF
        0: hIcon  : HICON;
       |1: pszIcon: PCSTR;
    END;
    pszCaption : PCSTR;
    nPages     : UINT;
    CASE : INTEGER OF
        0: nStartPage: UINT;
       |1: pStartPage: PCSTR;
    END;
    CASE : INTEGER OF
        0: ppsp  : PCPROPSHEETPAGEA;
       |1: phpage: POINTER TO ARRAY OF HPROPSHEETPAGE;
    END;
    pfnCallback: PFNPROPSHEETCALLBACK;
(* IF _WIN32_IE >= 0x0400 THEN *)
    CASE : INTEGER OF
        0: hbmWatermark  : HBITMAP;
       |1: pszbmWatermark: PCSTR;
    END;
    hplWatermark: HPALETTE;
    CASE : INTEGER OF
        0: hbmHeader  : HBITMAP;  (*  Header  bitmap shares the palette with watermark *)
       |1: pszbmHeader: PCSTR;
    END;
(* END *)
  END;

  PPROPSHEETHEADERA  = POINTER TO PROPSHEETHEADERA;
  PCPROPSHEETHEADERA = PPROPSHEETHEADERA;
CONST
  PROPSHEETHEADERA_V1_SIZE = SIZE (PROPSHEETHEADERA) - SIZE (PCSTR) - SIZE (HPALETTE) - SIZE (PCSTR);

TYPE
  PROPSHEETHEADERW = RECORD
    dwSize     : DWORD;
    dwFlags    : PSH_SET;
    hwndParent : HWND;
    hInstance  : HINSTANCE;
    CASE : INTEGER OF
        0: hIcon  : HICON;
       |1: pszIcon: PCWSTR;
    END;
    pszCaption : PCWSTR;
    nPages     : UINT;
    CASE : INTEGER OF
        0: nStartPage: UINT;
       |1: pStartPage: PCWSTR;
    END;
    CASE : INTEGER OF
        0: ppsp  : PCPROPSHEETPAGEW;
       |1: phpage: POINTER TO ARRAY OF HPROPSHEETPAGE;
    END;
    pfnCallback: PFNPROPSHEETCALLBACK;
(* IF _WIN32_IE >= 0x0400 THEN *)
    CASE : INTEGER OF
        0: hbmWatermark  : HBITMAP;
       |1: pszbmWatermark: PCWSTR;
    END;
    hplWatermark   : HPALETTE;
    CASE : INTEGER OF
        0: hbmHeader  : HBITMAP;
       |1: pszbmHeader: PCWSTR;
    END;
(* END *)
  END;

CONST
  PROPSHEETHEADERW_V1_SIZE = SIZE (PROPSHEETHEADERW) - SIZE (PCWSTR) - SIZE (HPALETTE) - SIZE (PCWSTR);

TYPE
  PPROPSHEETHEADERW  = POINTER TO PROPSHEETHEADERW;
  PCPROPSHEETHEADERW = PPROPSHEETHEADERW;

<* IF DEFINED (UNICODE) THEN *>
TYPE
  PROPSHEETHEADER   = PROPSHEETHEADERW;
  PPROPSHEETHEADER  = PPROPSHEETHEADERW;
  PCPROPSHEETHEADER = PPROPSHEETHEADERW;
CONST
  PROPSHEETHEADER_V1_SIZE = PROPSHEETHEADERW_V1_SIZE;
<* ELSE *>
TYPE
  PROPSHEETHEADER   = PROPSHEETHEADERA;
  PPROPSHEETHEADER  = PPROPSHEETHEADERA;
  PCPROPSHEETHEADER = PPROPSHEETHEADERA;
CONST
  PROPSHEETHEADER_V1_SIZE = PROPSHEETHEADERA_V1_SIZE;
<* END *>

CONST
  PSCB_INITIALIZED = 1;
  PSCB_PRECREATE   = 2;

<* IF BACKEND # "C" THEN *>
PROCEDURE CreatePropertySheetPageA ( psp: PROPSHEETPAGEA (*!*) ): HPROPSHEETPAGE;
<* ELSE *>
PROCEDURE CreatePropertySheetPageA ( psp: PPROPSHEETPAGEA (*!*) ): HPROPSHEETPAGE;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE CreatePropertySheetPageW ( psp: PROPSHEETPAGEW (*!*) ): HPROPSHEETPAGE;
<* ELSE *>
PROCEDURE CreatePropertySheetPageW ( psp: PPROPSHEETPAGEW (*!*) ): HPROPSHEETPAGE;
<* END *>

PROCEDURE DestroyPropertySheetPage ( hpsp: HPROPSHEETPAGE ): BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE PropertySheetA ( psh: PROPSHEETHEADERA (*!*) ): INTEGER;
<* ELSE *>
PROCEDURE PropertySheetA ( psh: PPROPSHEETHEADERA (*!*) ): INTEGER;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE PropertySheetW ( psh: PROPSHEETHEADERW (*!*) ): INTEGER;
<* ELSE *>
PROCEDURE PropertySheetW ( psh: PPROPSHEETHEADERW (*!*) ): INTEGER;
<* END *>

CONST
<* IF DEFINED (UNICODE) THEN *>
  CreatePropertySheetPage = CreatePropertySheetPageW;
  PropertySheet = PropertySheetW;
<* ELSE *>
  CreatePropertySheetPage = CreatePropertySheetPageA;
  PropertySheet = PropertySheetA;
<* END *>

TYPE 
  PFNADDPROPSHEETPAGE = PROCEDURE [CALLBACK] ( HPROPSHEETPAGE, LPARAM ): BOOL;
  PFNADDPROPSHEETPAGES = PROCEDURE [CALLBACK] ( PVOID, PFNADDPROPSHEETPAGE, LPARAM ): BOOL;

  PSHNOTIFY = RECORD
    hdr   : NMHDR;
    lParam: LPARAM;
  END;
  PPSHNOTIFY = POINTER TO PSHNOTIFY;

CONST
  PSN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-200));
  PSN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-299));

  PSN_SETACTIVE   = PSN_FIRST-0;
  PSN_KILLACTIVE  = PSN_FIRST-1;
  (* PSN_VALIDATE = PSN_FIRST-1; *)
  PSN_APPLY       = PSN_FIRST-2;
  PSN_RESET       = PSN_FIRST-3;
  (* PSN_CANCEL   = PSN_FIRST-3; *)
  PSN_HELP        = PSN_FIRST-5;
  PSN_WIZBACK     = PSN_FIRST-6;
  PSN_WIZNEXT     = PSN_FIRST-7;
  PSN_WIZFINISH   = PSN_FIRST-8;
  PSN_QUERYCANCEL = PSN_FIRST-9;
(* IF _WIN32_IE >= 0x0400 THEN *)
  PSN_GETOBJECT   = PSN_FIRST-10;
(* END *)
  PSNRET_NOERROR              = 0;
  PSNRET_INVALID              = 1;
  PSNRET_INVALID_NOCHANGEPAGE = 2;

CONST
  PSM_SETCURSEL = WM_USER+101;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_SetCurSel ( hPropSheetDlg: HWND; hpage: HPROPSHEETPAGE; index: INTEGER ): BOOL;

CONST 
  PSM_REMOVEPAGE = WM_USER+102;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_RemovePage ( hPropSheetDlg: HWND; index: INTEGER; hpage: HPROPSHEETPAGE );

CONST 
  PSM_ADDPAGE = WM_USER+103;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_AddPage ( hPropSheetDlg: HWND; hpage: HPROPSHEETPAGE ): BOOL;

CONST 
  PSM_CHANGED = WM_USER+104;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_Changed ( hPropSheetDlg: HWND; hwndPage: HWND ): BOOL;

CONST 
  PSM_RESTARTWINDOWS = WM_USER+105;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_RestartWindows ( hPropSheetDlg: HWND );

CONST 
  PSM_REBOOTSYSTEM = WM_USER+106;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_RebootSystem ( hPropSheetDlg: HWND );

CONST 
  PSM_CANCELTOCLOSE = WM_USER+107;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_CancelToClose ( hPropSheetDlg: HWND );

CONST 
  PSM_QUERYSIBLINGS = WM_USER+108;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_QuerySiblings ( hPropSheetDlg: HWND; wParam: WPARAM; lParam: LPARAM ): INTEGER;

CONST 
  PSM_UNCHANGED = WM_USER+109;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_UnChanged ( hPropSheetDlg: HWND; hwndPage: HWND );

CONST 
  PSM_APPLY = WM_USER+110;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_Apply ( hPropSheetDlg: HWND ): BOOL;

CONST 
  PSM_SETTITLEA = WM_USER+111;
  PSM_SETTITLEW = WM_USER+120;
<* IF DEFINED (UNICODE) THEN *>
  PSM_SETTITLE = PSM_SETTITLEW;
<* ELSE *>
  PSM_SETTITLE = PSM_SETTITLEA;
<* END *>

(* This procedures correspond to a macro. *)
PROCEDURE PropSheet_SetTitleA ( hPropSheetDlg: HWND; dwStyle: PSH_SET; szText: PCSTR  (* NIL *) );
PROCEDURE PropSheet_SetTitleW ( hPropSheetDlg: HWND; dwStyle: PSH_SET; szText: PCWSTR (* NIL *) );

CONST
<* IF DEFINED (UNICODE) THEN *>
  PropSheet_SetTitle = PropSheet_SetTitleW;
<* ELSE *>
  PropSheet_SetTitle = PropSheet_SetTitleA;
<* END *>


TYPE
  PSWIZB_ENUM = (
    PSWIZB__BACK,               (* 0 *)
    PSWIZB__NEXT,               (* 1 *)
    PSWIZB__FINISH,             (* 2 *)
    PSWIZB__DISABLEDFINISH      (* 3 *)
  );
  PSWIZB_SET = SET OF PSWIZB_ENUM;

CONST 
  PSWIZB_BACK           = PSWIZB_SET {PSWIZB__BACK};             (* 0001H *)
  PSWIZB_NEXT           = PSWIZB_SET {PSWIZB__NEXT};             (* 0002H *)
  PSWIZB_FINISH         = PSWIZB_SET {PSWIZB__FINISH};           (* 0004H *)
  PSWIZB_DISABLEDFINISH = PSWIZB_SET {PSWIZB__DISABLEDFINISH};   (* 0008H *)

  PSM_SETWIZBUTTONS = WM_USER+112;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_SetWizButtons ( hPropSheetDlg: HWND; dwFlags: PSWIZB_SET );

TYPE
  PSBTN_ENUM = (
    PSBTN_BACK,     (* 0 *)
    PSBTN_NEXT,     (* 1 *)
    PSBTN_FINISH,   (* 2 *)
    PSBTN_OK,       (* 3 *)
    PSBTN_APPLYNOW, (* 4 *)
    PSBTN_CANCEL,   (* 5 *)
    PSBTN_HELP      (* 6 *)
  );

CONST
  PSBTN_MAX = MAX(PSBTN_ENUM);

  PSM_PRESSBUTTON = WM_USER+113;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_PressButton ( hPropSheetDlg: HWND; iButton: PSBTN_ENUM ): BOOL;

CONST 
  PSM_SETCURSELID = WM_USER+114;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_SetCurSelByID ( hPropSheetDlg: HWND; id: INTEGER ): BOOL;

CONST 
  PSM_SETFINISHTEXTA = WM_USER+115;
  PSM_SETFINISHTEXTW = WM_USER+121;
<* IF DEFINED (UNICODE) THEN *>
  PSM_SETFINISHTEXT = PSM_SETFINISHTEXTW;
<* ELSE *>
  PSM_SETFINISHTEXT = PSM_SETFINISHTEXTA;
<* END *>

(* These procedures correspond to a macro. *)
PROCEDURE PropSheet_SetFinishTextA ( hPropSheetDlg: HWND; szText: PCSTR (* NIL *) );
PROCEDURE PropSheet_SetFinishTextW ( hPropSheetDlg: HWND; szText: PCWSTR (* NIL *) );

CONST
<* IF DEFINED (UNICODE) THEN *>
  PropSheet_SetFinishText = PropSheet_SetFinishTextW;
<* ELSE *>
  PropSheet_SetFinishText = PropSheet_SetFinishTextA;
<* END *>

CONST 
  PSM_GETTABCONTROL = WM_USER+116;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_GetTabControl ( hPropSheetDlg: HWND ): HWND;

CONST 
  PSM_ISDIALOGMESSAGE = WM_USER+117;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_IsDialogMessage ( hPropSheetDlg: HWND; VAR Msg: MSG ): BOOL;

CONST 
  PSM_GETCURRENTPAGEHWND = WM_USER+118;

(* This procedure corresponds to a macro. *)
PROCEDURE PropSheet_GetCurrentPageHwnd ( hPropSheetDlg: HWND ): HWND;

CONST 
  ID_PSRESTARTWINDOWS = 2H;
  ID_PSREBOOTSYSTEM   = ID_PSRESTARTWINDOWS + 1;

  WIZ_CXDLG  = 276;
  WIZ_CYDLG  = 140;

  WIZ_CXBMP  = 80;

  WIZ_BODYX  = 92;
  WIZ_BODYCX = 184;

  PROP_SM_CXDLG  = 212;
  PROP_SM_CYDLG  = 188;

  PROP_MED_CXDLG = 227;
  PROP_MED_CYDLG = 215;

  PROP_LG_CXDLG  = 252;
  PROP_LG_CYDLG  = 218;

(* End of property aheet definitions based on prsht.h *)


PROCEDURE InitCommonControls ();

(* IF _WIN32_IE >= 0x0300 THEN *)
TYPE
  ICC_ENUM = (
    ICC__LISTVIEW_CLASSES,       (*  0 *)
    ICC__TREEVIEW_CLASSES,       (*  1 *)
    ICC__BAR_CLASSES,            (*  2 *)
    ICC__TAB_CLASSES,            (*  3 *)
    ICC__UPDOWN_CLASS,           (*  4 *)
    ICC__PROGRESS_CLASS,         (*  5 *)
    ICC__HOTKEY_CLASS,           (*  6 *)
    ICC__ANIMATE_CLASS,          (*  7 *)
    ICC__DATE_CLASSES,           (*  8 *)
    ICC__USEREX_CLASSES,         (*  9 *)
    ICC__COOL_CLASSES,           (* 10 *)
    ICC__INTERNET_CLASSES,       (* 11 *)
    ICC__PAGESCROLLER_CLASS,     (* 12 *)
    ICC__NATIVEFNTCTL_CLASS      (* 13 *)
  );
  ICC_SET = SET OF ICC_ENUM;

  INITCOMMONCONTROLSEX = RECORD
    dwSize: DWORD;                    (*  size of this structure *)
    dwICC : ICC_SET;                  (*  flags indicating which classes to be initialized *)
  END;
  PINITCOMMONCONTROLSEX = POINTER TO INITCOMMONCONTROLSEX;

CONST
  ICC_LISTVIEW_CLASSES   = ICC_SET {ICC__LISTVIEW_CLASSES};   (* 0001H *) (*  listview, header *)
  ICC_TREEVIEW_CLASSES   = ICC_SET {ICC__TREEVIEW_CLASSES};   (* 0002H *) (*  treeview, tooltips *)
  ICC_BAR_CLASSES        = ICC_SET {ICC__BAR_CLASSES};        (* 0004H *) (*  toolbar, statusbar, trackbar, tooltips *)
  ICC_TAB_CLASSES        = ICC_SET {ICC__TAB_CLASSES};        (* 0008H *) (*  tab, tooltips *)
  ICC_UPDOWN_CLASS       = ICC_SET {ICC__UPDOWN_CLASS};       (* 0010H *) (*  updown *)
  ICC_PROGRESS_CLASS     = ICC_SET {ICC__PROGRESS_CLASS};     (* 0020H *) (*  progress *)
  ICC_HOTKEY_CLASS       = ICC_SET {ICC__HOTKEY_CLASS};       (* 0040H *) (*  hotkey *)
  ICC_ANIMATE_CLASS      = ICC_SET {ICC__ANIMATE_CLASS};      (* 0080H *) (*  animate *)

  ICC_WIN95_CLASSES      = ICC_SET {ICC__LISTVIEW_CLASSES..
                                    ICC__ANIMATE_CLASS};      (* 00FFH *)

  ICC_DATE_CLASSES       = ICC_SET {ICC__DATE_CLASSES};       (* 0100H *) (*  month picker, date picker, time picker, updown *)
  ICC_USEREX_CLASSES     = ICC_SET {ICC__USEREX_CLASSES};     (* 0200H *) (*  comboex *)
  ICC_COOL_CLASSES       = ICC_SET {ICC__COOL_CLASSES};       (* 0400H *) (*  rebar (coolbar) control *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  ICC_INTERNET_CLASSES   = ICC_SET {ICC__INTERNET_CLASSES};   (* 0800H *)
  ICC_PAGESCROLLER_CLASS = ICC_SET {ICC__PAGESCROLLER_CLASS}; (* 1000H *) (*  page scroller *)
  ICC_NATIVEFNTCTL_CLASS = ICC_SET {ICC__NATIVEFNTCTL_CLASS}; (* 2000H *) (*  native font control *)
(* END *)

<* IF BACKEND # "C" THEN *>
PROCEDURE InitCommonControlsEx ( icc: INITCOMMONCONTROLSEX (*!*) ): BOOL;
<* ELSE *>
PROCEDURE InitCommonControlsEx ( icc: PINITCOMMONCONTROLSEX (*!*) ): BOOL;
<* END *>
(* END *)

CONST
  ODT_HEADER   = 100;
  ODT_TAB      = 101;
  ODT_LISTVIEW = 102;

(* ====== Ranges for control message IDs ======================================= *)
  LVM_FIRST = 1000H;         (*  ListView messages *)
  TV_FIRST  = 1100H;         (*  TreeView messages *)
  HDM_FIRST = 1200H;         (*  Header messages *)
  TCM_FIRST = 1300H;         (*  Tab control messages *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  PGM_FIRST = 1400H;         (*  Pager control messages *)
  CCM_FIRST = 2000H;         (*  Common control shared messages *)

  CCM_SETBKCOLOR = CCM_FIRST+1; (*  lParam is bkColor *)

TYPE
  COLORSCHEME = RECORD
    dwSize         : DWORD;
    clrBtnHighlight: COLORREF;  (*  highlight color *)
    clrBtnShadow   : COLORREF;  (*  shadow color *)
  END;
  PCOLORSCHEME = POINTER TO COLORSCHEME;

CONST
  CCM_SETCOLORSCHEME   = CCM_FIRST+2;   (*  lParam is color scheme *)
  CCM_GETCOLORSCHEME   = CCM_FIRST+3;   (*  fills in COLORSCHEME pointed to by lParam *)
  CCM_GETDROPTARGET    = CCM_FIRST+4;
  CCM_SETUNICODEFORMAT = CCM_FIRST+5;
  CCM_GETUNICODEFORMAT = CCM_FIRST+6;

(*  for tooltips *)
  INFOTIPSIZE = 1024;
(* END *)

(* ====== WM_NOTIFY codes (NMHDR.code values) ================================== *)

TYPE PFN_WM_NOTIFY_HANDLER = PROCEDURE (     (* hwnd   : *) HWND,
                                             (* idFrom : *) INTEGER,
                                         VAR (* nmhdr  : *) NMHDR ): LRESULT;

(* This function implements a macro *)

PROCEDURE HANDLE_WM_NOTIFY ( hwnd : HWND; wParam : WPARAM;
                             lParam : LPARAM;
                             fn : PFN_WM_NOTIFY_HANDLER ): LRESULT;

(* This function implements a macro *)

PROCEDURE FORWARD_WM_NOTIFY ( hwnd : HWND; idFrom : INTEGER;
                              VAR nmhdr : NMHDR; fn : WNDPROC ): LRESULT;


CONST 
  NM_FIRST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-  0));   (*  generic to all controls *)
  NM_LAST   = SYSTEM.CAST (UINT, VAL (INTEGER, 0- 99));

  LVN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-100));   (*  listview *)
  LVN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-199));

  HDN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-300));   (*  header *)
  HDN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-399));

  TVN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-400));   (*  treeview *)
  TVN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-499));

  TTN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-520));   (*  tooltips *)
  TTN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-549));

  TCN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-550));   (*  tab control *)
  TCN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-580));

(*  Shell reserved               (0U-580U) -  (0U-589U) *)
  CDN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-601));   (*  common dialog (new) *)
  CDN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-699));

  TBN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-700));   (*  toolbar *)
  TBN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-720));

  UDN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-721));   (*  updown *)
  UDN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-740));

(* IF _WIN32_IE >= 0x0300 THEN *)
  MCN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-750));   (*  monthcal *)
  MCN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-759));

  DTN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-760));   (*  datetimepick *)
  DTN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-799));

  CBEN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-800));  (*  combo box ex *)
  CBEN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-830));

  RBN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-831));   (*  rebar *)
  RBN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-859));
(* END *)

(* IF _WIN32_IE >= 0x0400 THEN *)
  IPN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-860));   (*  internet address *)
  IPN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-879));

  SBN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-880));   (*  status bar *)
  SBN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-899));

  PGN_FIRST = SYSTEM.CAST (UINT, VAL (INTEGER, 0-900));   (*  Pager Control *)
  PGN_LAST  = SYSTEM.CAST (UINT, VAL (INTEGER, 0-950));
(* END *)

  MSGF_COMMCTRL_BEGINDRAG   = 4200H;
  MSGF_COMMCTRL_SIZEHEADER  = 4201H;
  MSGF_COMMCTRL_DRAGSELECT  = 4202H;
  MSGF_COMMCTRL_TOOLBARCUST = 4203H;

(* ====== Generic WM_NOTIFY notification codes ================================= *)
  NM_OUTOFMEMORY = (NM_FIRST-1);
  NM_CLICK       = (NM_FIRST-2);    (* uses NMCLICK struct *)
  NM_DBLCLK      = (NM_FIRST-3);
  NM_RETURN      = (NM_FIRST-4);
  NM_RCLICK      = (NM_FIRST-5);    (* uses NMCLICK struct *)
  NM_RDBLCLK     = (NM_FIRST-6);
  NM_SETFOCUS    = (NM_FIRST-7);
  NM_KILLFOCUS   = (NM_FIRST-8);
(* IF _WIN32_IE >= 0x0300 THEN *)
  NM_CUSTOMDRAW  = (NM_FIRST-12);
  NM_HOVER       = (NM_FIRST-13);
(* END *)

(* IF _WIN32_IE >= 0x0400 THEN *)
  NM_NCHITTEST       = (NM_FIRST-14);   (* uses NMMOUSE struct *)
  NM_KEYDOWN         = (NM_FIRST-15);   (* uses NMKEY struct *)
  NM_RELEASEDCAPTURE = (NM_FIRST-16);
  NM_SETCURSOR       = (NM_FIRST-17);   (* uses NMMOUSE struct *)
  NM_CHAR            = (NM_FIRST-18);   (* uses NMCHAR struct *)

TYPE
  NMMOUSE = RECORD
    hdr       : NMHDR;
    dwItemSpec: DWORD;
    dwItemData: DWORD;
    pt        : POINT;
    dwHitInfo : DWORD;   (*  any specifics about where on the item or control the mouse is *)
  END;
  PNMMOUSE = POINTER TO NMMOUSE;

  NMCLICK  = NMMOUSE;
  PNMCLICK = PNMMOUSE;

(*  Generic structure to request an object of a specific type. *)

  NMOBJECTNOTIFY = RECORD
    hdr    : NMHDR;
    iItem  : INTEGER;
    piid   : PVOID;
    pObject: PVOID;
    hResult: HRESULT;
    dwFlags: DWORD;             (*  control specific flags (hints as to where in iItem it hit) *)
  END;
  PNMOBJECTNOTIFY = POINTER TO NMOBJECTNOTIFY;

(*  Generic structure for a key *)

  NMKEY = RECORD
    hdr   : NMHDR;
    nVKey : UINT;
    uFlags: UINT;
  END;
  PNMKEY = POINTER TO NMKEY;

(*  Generic structure for a character *)

  NMCHAR = RECORD
    hdr       : NMHDR;
    ch        : UINT;
    dwItemPrev: DWORD;  (*  Item previously selected  *)
    dwItemNext: DWORD;  (*  Item to be selected *)
  END;
  PNMCHAR = POINTER TO NMCHAR;
(* END *)

(* IF _WIN32_IE >= 0x0300 THEN *)
(* ==================== CUSTOM DRAW ========================================== *)
(*  custom draw return flags *)
(*  values under 0x00010000 are reserved for global custom draw values. *)
(*  above that are for specific controls *)
CONST
  CDRF_DODEFAULT         = 0000H;
  CDRF_NEWFONT           = 0002H;
  CDRF_SKIPDEFAULT       = 0004H;
  CDRF_NOTIFYPOSTPAINT   = 0010H;
  CDRF_NOTIFYITEMDRAW    = 0020H;
(* IF _WIN32_IE >= 0x0400 THEN *)
  CDRF_NOTIFYSUBITEMDRAW = 0020H;   (*  flags are the same, we can distinguish by context *)
(* END *)
  CDRF_NOTIFYPOSTERASE   = 0040H;

(*  drawstage flags *)
(*  values under 0x00010000 are reserved for global custom draw values. *)
(*  above that are for specific controls *)
TYPE
  CDDS_ENUM = [0 .. 17];
  CDDS_SET = SET OF CDDS_ENUM;

CONST
  CDDS__0  = 0;
  CDDS__1  = 1;
  CDDS__2  = 2;
  CDDS__16 = 16;
  CDDS__17 = 17;

CONST
  CDDS_PREPAINT      = CDDS_SET {CDDS__0};               (* 00000001H *)
  CDDS_POSTPAINT     = CDDS_SET {CDDS__1};               (* 00000002H *)
  CDDS_PREERASE      = CDDS_SET {CDDS__0, CDDS__1};      (* 00000003H *)
  CDDS_POSTERASE     = CDDS_SET {CDDS__2};               (* 00000004H *)

(*  the 0x000010000 bit means it's individual item specific *)
  CDDS_ITEM          = CDDS_SET {CDDS__16};              (* 00010000H *)
  CDDS_ITEMPREPAINT  = CDDS_ITEM + CDDS_PREPAINT;
  CDDS_ITEMPOSTPAINT = CDDS_ITEM + CDDS_POSTPAINT;
  CDDS_ITEMPREERASE  = CDDS_ITEM + CDDS_PREERASE;
  CDDS_ITEMPOSTERASE = CDDS_ITEM + CDDS_POSTERASE;
(* IF _WIN32_IE >= 0x0400 THEN *)
  CDDS_SUBITEM       = CDDS_SET {CDDS__17};              (* 00020000H *)
(* END *)

(*  itemState flags *)
TYPE
  CDIS_ENUM = (
    CDIS__SELECTED,              (* 0 *)
    CDIS__GRAYED,                (* 1 *)
    CDIS__DISABLED,              (* 2 *)
    CDIS__CHECKED,               (* 3 *)
    CDIS__FOCUS,                 (* 4 *)
    CDIS__DEFAULT,               (* 5 *)
    CDIS__HOT,                   (* 6 *)
    CDIS__MARKED,                (* 7 *)
    CDIS__INDETERMINATE          (* 8 *)
  );
  CDIS_SET = SET OF CDIS_ENUM;

CONST
  CDIS_SELECTED      = CDIS_SET {CDIS__SELECTED};      (* 0001H *)
  CDIS_GRAYED        = CDIS_SET {CDIS__GRAYED};        (* 0002H *)
  CDIS_DISABLED      = CDIS_SET {CDIS__DISABLED};      (* 0004H *)
  CDIS_CHECKED       = CDIS_SET {CDIS__CHECKED};       (* 0008H *)
  CDIS_FOCUS         = CDIS_SET {CDIS__FOCUS};         (* 0010H *)
  CDIS_DEFAULT       = CDIS_SET {CDIS__DEFAULT};       (* 0020H *)
  CDIS_HOT           = CDIS_SET {CDIS__HOT};           (* 0040H *)
  CDIS_MARKED        = CDIS_SET {CDIS__MARKED};        (* 0080H *)
  CDIS_INDETERMINATE = CDIS_SET {CDIS__INDETERMINATE}; (* 0100H *)

TYPE
  NMCUSTOMDRAW = RECORD
    hdr        : NMHDR;
    dwDrawStage: CDDS_SET;
    hdc        : HDC;
    rc         : RECT;
    dwItemSpec : DWORD;           (*  this is control specific, but it's how to specify an item.  valid only with CDDS_ITEM bit set *)
    uItemState : CDIS_SET;
    lItemlParam: LPARAM;
  END;
  PNMCUSTOMDRAW = POINTER TO NMCUSTOMDRAW;

  NMTTCUSTOMDRAW = RECORD
    nmcd      : NMCUSTOMDRAW;
    uDrawFlags: DT_SET;
  END;
  PNMTTCUSTOMDRAW = POINTER TO NMTTCUSTOMDRAW;
(* END *)

(* ====== IMAGE APIS =========================================================== *)
CONST
  CLR_NONE    = SYSTEM.CAST(COLORREF, 0FFFFFFFFH);
  CLR_DEFAULT = SYSTEM.CAST(COLORREF, 0FF000000H);

TYPE 
  HIMAGELIST = POINTER TO RECORD END;

  ILC_ENUM = (ILC__0, ILC__1, ILC__2,  ILC__3,  ILC__4,  ILC__5,  ILC__6,  ILC__7,
              ILC__8, ILC__9, ILC__10, ILC__11, ILC__12, ILC__13, ILC__14, ILC__15);
  ILC_SET = SET OF ILC_ENUM;

CONST
  ILC_MASK     = ILC_SET {ILC__0};              (* 0001H *)
  ILC_COLOR    = ILC_SET {};                    (* 0000H *)
  ILC_COLORDDB = ILC_SET {ILC__1 .. ILC__7};    (* 00FEH *)
  ILC_COLOR4   = ILC_SET {ILC__2};              (* 0004H *)
  ILC_COLOR8   = ILC_SET {ILC__3};              (* 0008H *)
  ILC_COLOR16  = ILC_SET {ILC__4};              (* 0010H *)
  ILC_COLOR24  = ILC_SET {ILC__3,ILC__4};       (* 0018H *)
  ILC_COLOR32  = ILC_SET {ILC__5};              (* 0020H *)
  ILC_PALETTE  = ILC_SET {ILC__11};             (* 0800H *)

TYPE
  BIT_ENUM = (BIT__0, BIT__1, BIT__2,  BIT__3,  BIT__4,  BIT__5,  BIT__6,  BIT__7,
              BIT__8, BIT__9, BIT__10, BIT__11, BIT__12, BIT__13, BIT__14, BIT__15);
  BIT_SET = SET OF BIT_ENUM;

  ILD_SET = BIT_SET;

(* IF _WIN32_IE >= 0x0300 THEN *)
  IMAGELISTDRAWPARAMS = RECORD
    cbSize : DWORD;
    himl   : HIMAGELIST;
    i      : INTEGER;
    hdcDst : HDC;
    x      : INTEGER;
    y      : INTEGER;
    cx     : INTEGER;
    cy     : INTEGER;
    xBitmap: INTEGER;           (*  x offest from the upperleft of bitmap *)
    yBitmap: INTEGER;           (*  y offset from the upperleft of bitmap *)
    rgbBk  : COLORREF;
    rgbFg  : COLORREF;
    fStyle : ILD_SET;
    dwRop  : ROP;
  END;
  PIMAGELISTDRAWPARAMS = POINTER TO IMAGELISTDRAWPARAMS;
(* END *)

PROCEDURE ImageList_Create ( cx, cy: INTEGER; flags: ILC_SET; cInitial, cGrow: INTEGER ): HIMAGELIST;
PROCEDURE ImageList_Destroy ( himl: HIMAGELIST ): BOOL;
PROCEDURE ImageList_GetImageCount ( himl: HIMAGELIST ): INTEGER;
(* IF _WIN32_IE >= 0x0300 THEN *)
PROCEDURE ImageList_SetImageCount ( himl: HIMAGELIST; uNewCount: UINT ): BOOL;
(* END *)
PROCEDURE ImageList_Add ( himl: HIMAGELIST; hbmImage, hbmMask: HBITMAP ): INTEGER;
PROCEDURE ImageList_ReplaceIcon ( himl: HIMAGELIST; i: INTEGER; hicon: HICON ): INTEGER;
PROCEDURE ImageList_SetBkColor ( himl: HIMAGELIST; clrBk: COLORREF ): COLORREF;
PROCEDURE ImageList_GetBkColor ( himl: HIMAGELIST ): COLORREF;
PROCEDURE ImageList_SetOverlayImage ( himl: HIMAGELIST; iImage, iOverlay: INTEGER ): BOOL;

(* This procedure corresponds to a macro. *)
PROCEDURE ImageList_AddIcon ( himl: HIMAGELIST; hicon: HICON ): INTEGER;


CONST 
  ILD_NORMAL      = ILD_SET {};                  (* 0000H *)
  ILD_TRANSPARENT = ILD_SET {BIT__0};            (* 0001H *)
  ILD_MASK        = ILD_SET {BIT__4};            (* 0010H *)
  ILD_IMAGE       = ILD_SET {BIT__5};            (* 0020H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  ILD_ROP         = ILD_SET {BIT__6};            (* 0040H *)
(* END *)
  ILD_BLEND25     = ILD_SET {BIT__1};            (* 0002H *)
  ILD_BLEND50     = ILD_SET {BIT__2};            (* 0004H *)
  ILD_OVERLAYMASK = ILD_SET {BIT__8 .. BIT__11}; (* 0F00H *)

  ILD_SELECTED    = ILD_BLEND50;
  ILD_FOCUS       = ILD_BLEND25;
  ILD_BLEND       = ILD_BLEND50;

  CLR_HILIGHT     = CLR_DEFAULT;

(* This procedure corresponds to a macro. *)
PROCEDURE INDEXTOOVERLAYMASK ( iOverlay: UINT ): BIT_SET;

PROCEDURE ImageList_Draw ( himl: HIMAGELIST; i: INTEGER; hdcDst: HDC; x, y: INTEGER; fStyle: ILD_SET ): BOOL;
PROCEDURE ImageList_Replace ( himl: HIMAGELIST; i: INTEGER; hbmImage, hbmMask: HBITMAP ): BOOL;
PROCEDURE ImageList_AddMasked ( himl: HIMAGELIST; hbmImage: HBITMAP; crMask: COLORREF ): INTEGER;
PROCEDURE ImageList_DrawEx ( himl: HIMAGELIST; i: INTEGER; hdcDst: HDC;
                             x, y, dx, dy: INTEGER; rgbBk, rgbFg: COLORREF;
                             fStyle: ILD_SET ): BOOL;
(* IF _WIN32_IE >= 0x0300 THEN *)
<* IF BACKEND # "C" THEN *>
PROCEDURE ImageList_DrawIndirect ( imldp: IMAGELISTDRAWPARAMS (*!*) ): BOOL;
<* ELSE *>
PROCEDURE ImageList_DrawIndirect ( imldp: PIMAGELISTDRAWPARAMS (*!*) ): BOOL;
<* END *>
(* END *)
PROCEDURE ImageList_Remove ( himl: HIMAGELIST; i: INTEGER ): BOOL;
PROCEDURE ImageList_GetIcon ( himl: HIMAGELIST; i: INTEGER; flags: ILD_SET ): HICON;
PROCEDURE ImageList_LoadImageA ( hi: HINSTANCE; lpbmp: PCSTR; 
                                 cx, cGrow: INTEGER; crMask: COLORREF; 
                                 uType: IMAGE_TYPE; uFlags: LR_SET ): HIMAGELIST;
PROCEDURE ImageList_LoadImageW ( hi: HINSTANCE; lpbmp: PCWSTR; 
                                 cx, cGrow: INTEGER; crMask: COLORREF; 
                                 uType: IMAGE_TYPE; uFlags: LR_SET ): HIMAGELIST;

CONST
<* IF DEFINED (UNICODE) THEN *>
  ImageList_LoadImage = ImageList_LoadImageW;
<* ELSE *>
  ImageList_LoadImage = ImageList_LoadImageA;
<* END *>

(* IF _WIN32_IE >= 0x0300 THEN *)
TYPE
  ILCF_ENUM = (
    ILCF_MOVE,          (* 00H *)
    ILCF_SWAP           (* 01H *)
  );

PROCEDURE ImageList_Copy ( himlDst: HIMAGELIST; iDst: INTEGER; himlSrc: HIMAGELIST;
                           iSrc: INTEGER; uFlags: ILCF_ENUM ): BOOL;
(* END *)
PROCEDURE ImageList_BeginDrag ( himlTrack: HIMAGELIST; iTrack: INTEGER;
                                dxHotspot, dyHotspot: INTEGER ): BOOL;
PROCEDURE ImageList_EndDrag ();
PROCEDURE ImageList_DragEnter ( hwndLock: HWND; x, y: INTEGER ): BOOL;
PROCEDURE ImageList_DragLeave ( hwndLock: HWND ): BOOL;
PROCEDURE ImageList_DragMove ( x, y: INTEGER ): BOOL;
PROCEDURE ImageList_SetDragCursorImage ( himlDrag: HIMAGELIST; iDrag: INTEGER;
                                         dxHotspot, dyHotspot: INTEGER ): BOOL;
PROCEDURE ImageList_DragShowNolock ( fShow: BOOL ): BOOL;

PROCEDURE ImageList_GetDragImage ( VAR pt, ptHotspot: POINT ): HIMAGELIST;

(* This procedure corresponds to a macro. *)
PROCEDURE ImageList_RemoveAll ( himl: HIMAGELIST ): BOOL;

(* This procedure corresponds to a macro. *)
PROCEDURE ImageList_ExtractIcon ( hi: HINSTANCE; himl: HIMAGELIST;
                                  i: INTEGER ): HICON;

(* These procedures correspond to a macro. *)
PROCEDURE ImageList_LoadBitmapA ( hi: HINSTANCE; pbmp: PCSTR;
                                 cx, cGrow: INTEGER; crMask: COLORREF ): HIMAGELIST;
PROCEDURE ImageList_LoadBitmapW ( hi: HINSTANCE; pbmp: PCWSTR;
                                 cx, cGrow: INTEGER; crMask: COLORREF ): HIMAGELIST;

CONST
<* IF DEFINED (UNICODE) THEN *>
  ImageList_LoadBitmap = ImageList_LoadBitmapW;
<* ELSE *>
  ImageList_LoadBitmap = ImageList_LoadBitmapA;
<* END *>

PROCEDURE ImageList_Read ( pstm : COMMCTRL_PSTREAM ) : HIMAGELIST;
PROCEDURE ImageList_Write ( himl : HIMAGELIST; pstm : COMMCTRL_PSTREAM ): BOOL;

TYPE 
  IMAGEINFO = RECORD
    hbmImage: HBITMAP;
    hbmMask : HBITMAP;
    Unused1 : INTEGER;
    Unused2 : INTEGER;
    rcImage : RECT;
  END;

PROCEDURE ImageList_GetIconSize ( himl: HIMAGELIST; VAR cx, cy: INTEGER ): BOOL;
PROCEDURE ImageList_SetIconSize ( himl: HIMAGELIST; cx, cy: INTEGER ): BOOL;
PROCEDURE ImageList_GetImageInfo ( himl: HIMAGELIST; i: INTEGER;
                                   VAR ImageInfo: IMAGEINFO ): BOOL;
PROCEDURE ImageList_Merge ( himl1: HIMAGELIST; i1: INTEGER; himl2: HIMAGELIST;
                            i2: INTEGER; dx, dy: INTEGER ): HIMAGELIST;
(* IF _WIN32_IE >= 0x0400 THEN *)
PROCEDURE ImageList_Duplicate ( himl: HIMAGELIST ): HIMAGELIST;
(* END *)

(* ====== HEADER CONTROL ======================================================= *)
CONST 
  WC_HEADERW = ARRAY OF WCHAR {ORD('S'),ORD('y'),ORD('s'),ORD('H'),ORD('e'),ORD('a'),
                               ORD('d'),ORD('e'),ORD('r'),ORD('3'),ORD('2'),0};
  WC_HEADERA = 'SysHeader32';
<* IF DEFINED (UNICODE) THEN *>
  WC_HEADER = WC_HEADERW;
<* ELSE *>
  WC_HEADER = WC_HEADERA;
<* END *>

  HDS_HORZ     = WS_SET {};      (* 0000H *)
  HDS_BUTTONS  = WS_SET {WS__1}; (* 0002H *)
  HDS_HIDDEN   = WS_SET {WS__3}; (* 0008H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  HDS_HOTTRACK = WS_SET {WS__2}; (* 0004H *)
  HDS_DRAGDROP = WS_SET {WS__6}; (* 0040H *)
  HDS_FULLDRAG = WS_SET {WS__7}; (* 0080H *)
(* END *)

TYPE
  HDI_ENUM = (
    HDI__WIDTH,         (* 0 *)
    HDI__TEXT,          (* 1 *)
    HDI__FORMAT,        (* 2 *)
    HDI__LPARAM,        (* 3 *)
    HDI__BITMAP,        (* 4 *)
    HDI__IMAGE,         (* 5 *)
    HDI__DI_SETITEM,    (* 6 *)
    HDI__ORDER          (* 7 *)
  );
  HDI_SET = SET OF HDI_ENUM;

  HDF_ENUM = (
    HDF__RIGHT,                 (*  0 *)
    HDF__CENTER,                (*  1 *)
    HDF__RTLREADING,            (*  2 *)
    HDF__3, HDF__4, HDF__5, HDF__6, HDF__7, HDF__8, HDF__9, HDF__10,
    HDF__IMAGE,                 (* 11 *)
    HDF__BITMAP_ON_RIGHT,       (* 12 *)
    HDF__BITMAP,                (* 13 *)
    HDF__STRING,                (* 14 *)
    HDF__OWNERDRAW              (* 15 *)
  );
  HDF_SET = SET OF HDF_ENUM;

CONST
  HDI_WIDTH      = HDI_SET {HDI__WIDTH};          (* 0001H *)
  HDI_HEIGHT     = HDI_WIDTH;
  HDI_TEXT       = HDI_SET {HDI__TEXT};           (* 0002H *)
  HDI_FORMAT     = HDI_SET {HDI__FORMAT};         (* 0004H *)
  HDI_LPARAM     = HDI_SET {HDI__LPARAM};         (* 0008H *)
  HDI_BITMAP     = HDI_SET {HDI__BITMAP};         (* 0010H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  HDI_IMAGE      = HDI_SET {HDI__IMAGE};          (* 0020H *)
  HDI_DI_SETITEM = HDI_SET {HDI__DI_SETITEM};     (* 0040H *)
  HDI_ORDER      = HDI_SET {HDI__ORDER};          (* 0080H *)
(* END *)

  HDF_LEFT            = HDF_SET {};                     (* 0000H *)
  HDF_RIGHT           = HDF_SET {HDF__RIGHT};           (* 0001H *)
  HDF_CENTER          = HDF_SET {HDF__CENTER};          (* 0002H *)
  HDF_RTLREADING      = HDF_SET {HDF__RTLREADING};      (* 0004H *)
  HDF_JUSTIFYMASK     = HDF_RIGHT + HDF_CENTER;         (* 0003H *)

  HDF_OWNERDRAW       = HDF_SET {HDF__OWNERDRAW};       (* 8000H *)
  HDF_STRING          = HDF_SET {HDF__STRING};          (* 4000H *)
  HDF_BITMAP          = HDF_SET {HDF__BITMAP};          (* 2000H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  HDF_BITMAP_ON_RIGHT = HDF_SET {HDF__BITMAP_ON_RIGHT}; (* 1000H *)
  HDF_IMAGE           = HDF_SET {HDF__IMAGE};           (* 0800H *)
(* END *)

TYPE 
  HDITEMA = RECORD
    mask      : HDI_SET;
    cxy       : INTEGER;
    pszText   : PSTR;
    hbm       : HBITMAP;
    cchTextMax: INTEGER;
    fmt       : HDF_SET;
    lParam    : LPARAM;
(* IF _WIN32_IE >= 0x0300 THEN *)
    iImage    : INTEGER;  (*  index of bitmap in ImageList *)
    iOrder    : INTEGER;  (*  where to draw this item *)
(* END *)
  END;
  PHDITEMA = POINTER TO HDITEMA;

  HDITEMW = RECORD
    mask      : HDI_SET;
    cxy       : INTEGER;
    pszText   : PWSTR;
    hbm       : HBITMAP;
    cchTextMax: INTEGER;
    fmt       : HDF_SET;
    lParam    : LPARAM;
(* IF _WIN32_IE >= 0x0300 THEN *)
    iImage    : INTEGER;  (*  index of bitmap in ImageList *)
    iOrder    : INTEGER;  (*  where to draw this item *)
(* END *)
  END;
  PHDITEMW = POINTER TO HDITEMW;

CONST
  HDITEMA_V1_SIZE = SIZE (HDITEMA) - SIZE (INTEGER) - SIZE (INTEGER);
  HDITEMW_V1_SIZE = SIZE (HDITEMW) - SIZE (INTEGER) - SIZE (INTEGER);

<* IF DEFINED (UNICODE) THEN *>
TYPE
  HDITEM  = HDITEMW;
  PHDITEM = PHDITEMW;
CONST
  HDITEM_V1_SIZE =   HDITEMW_V1_SIZE;
<* ELSE *>
TYPE
  HDITEM  = HDITEMA;
  PHDITEM = PHDITEMA;
CONST
  HDITEM_V1_SIZE =   HDITEMA_V1_SIZE;
<* END *>

TYPE
  HD_ITEM  = HDITEM;
  HD_ITEMA = HDITEMA;
  HD_ITEMW = HDITEMW;

CONST
  HDM_GETITEMCOUNT = HDM_FIRST+0;

(* This procedure corresponds to a macro. *)
PROCEDURE Header_GetItemCount ( hwndHD: HWND ): INTEGER;

CONST 
  HDM_INSERTITEMA = HDM_FIRST+1;
  HDM_INSERTITEMW = HDM_FIRST+10;
<* IF DEFINED (UNICODE) THEN *>
  HDM_INSERTITEM = HDM_INSERTITEMW;
<* ELSE *>
  HDM_INSERTITEM = HDM_INSERTITEMA;
<* END *>

(* These procedures correspond to a macro. *)
<* IF BACKEND # "C" THEN *>
PROCEDURE Header_InsertItemA ( hwndHD: HWND; iIndex: INTEGER; hdi: HDITEMA (*!*) ): INTEGER;
<* ELSE *>
PROCEDURE Header_InsertItemA ( hwndHD: HWND; iIndex: INTEGER; hdi: PHDITEMA (*!*) ): INTEGER;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE Header_InsertItemW ( hwndHD: HWND; iIndex: INTEGER; hdi: HDITEMW (*!*) ): INTEGER;
<* ELSE *>
PROCEDURE Header_InsertItemW ( hwndHD: HWND; iIndex: INTEGER; hdi: PHDITEMW (*!*) ): INTEGER;
<* END *>

CONST
<* IF DEFINED (UNICODE) THEN *>
  Header_InsertItem = Header_InsertItemW;
<* ELSE *>
  Header_InsertItem = Header_InsertItemA;
<* END *>

CONST 
  HDM_DELETEITEM = HDM_FIRST+2;

(* This procedure corresponds to a macro. *)
PROCEDURE Header_DeleteItem ( hwndHD: HWND; iIndex: INTEGER ): BOOL;

CONST 
  HDM_GETITEMA = HDM_FIRST+3;
  HDM_GETITEMW = HDM_FIRST+11;
<* IF DEFINED (UNICODE) THEN *>
  HDM_GETITEM = HDM_GETITEMW;
<* ELSE *>
  HDM_GETITEM = HDM_GETITEMA;
<* END *>

(* These procedures correspond to a macro. *)
PROCEDURE Header_GetItemA ( hwndHD: HWND; iIndex: INTEGER; VAR hdi: HDITEMA ): BOOL;
PROCEDURE Header_GetItemW ( hwndHD: HWND; iIndex: INTEGER; VAR hdi: HDITEMW ): BOOL;

CONST
<* IF DEFINED (UNICODE) THEN *>
  Header_GetItem = Header_GetItemW;
<* ELSE *>
  Header_GetItem = Header_GetItemA;
<* END *>

CONST 
  HDM_SETITEMA = HDM_FIRST+4;
  HDM_SETITEMW = HDM_FIRST+12;
<* IF DEFINED (UNICODE) THEN *>
  HDM_SETITEM = HDM_SETITEMW;
<* ELSE *>
  HDM_SETITEM = HDM_SETITEMA;
<* END *>

(* This procedure corresponds to a macro. *)
<* IF BACKEND # "C" THEN *>
PROCEDURE Header_SetItemA ( hwndHD: HWND; iIndex: INTEGER; hdItem: HDITEMA (*!*) ): BOOL;
<* ELSE *>
PROCEDURE Header_SetItemA ( hwndHD: HWND; iIndex: INTEGER; hdItem: PHDITEMA (*!*) ): BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE Header_SetItemW ( hwndHD: HWND; iIndex: INTEGER; hdItem: HDITEMW (*!*) ): BOOL;
<* ELSE *>
PROCEDURE Header_SetItemW ( hwndHD: HWND; iIndex: INTEGER; hdItem: PHDITEMW (*!*) ): BOOL;
<* END *>

CONST
<* IF DEFINED (UNICODE) THEN *>
  Header_SetItem = Header_SetItemW;
<* ELSE *>
  Header_SetItem = Header_SetItemA;
<* END *>

TYPE
  HDLAYOUT = RECORD
    prc  : PRECT;
    pwpos: PWINDOWPOS;
  END;
  PHDLAYOUT = POINTER TO HDLAYOUT;

  HD_LAYOUT = HDLAYOUT;

CONST 
  HDM_LAYOUT = HDM_FIRST+5;

(* This procedure corresponds to a macro. *)
PROCEDURE Header_Layout ( hwndHD: HWND; VAR layout: HDLAYOUT ): BOOL;

TYPE
  HHT_ENUM = (
    HHT__NOWHERE,       (*  0 *)
    HHT__ONHEADER,      (*  1 *)
    HHT__ONDIVIDER,     (*  2 *)
    HHT__ONDIVOPEN,     (*  3 *)
    HHT__4, HHT__5, HHT__6, HHT__7,
    HHT__ABOVE,         (*  8 *)
    HHT__BELOW,         (*  9 *)
    HHT__TORIGHT,       (* 10 *)
    HHT__TOLEFT         (* 11 *)
  );
  HHT_SET = SET OF HHT_ENUM;

CONST 
  HHT_NOWHERE   = HHT_SET {HHT__NOWHERE};       (* 0001H *)
  HHT_ONHEADER  = HHT_SET {HHT__ONHEADER};      (* 0002H *)
  HHT_ONDIVIDER = HHT_SET {HHT__ONDIVIDER};     (* 0004H *)
  HHT_ONDIVOPEN = HHT_SET {HHT__ONDIVOPEN};     (* 0008H *)
  HHT_ABOVE     = HHT_SET {HHT__ABOVE};         (* 0100H *)
  HHT_BELOW     = HHT_SET {HHT__BELOW};         (* 0200H *)
  HHT_TORIGHT   = HHT_SET {HHT__TORIGHT};       (* 0400H *)
  HHT_TOLEFT    = HHT_SET {HHT__TOLEFT};        (* 0800H *)

TYPE
  HDHITTESTINFO = RECORD
    pt   : POINT;
    flags: HHT_SET;
    iItem: INTEGER;
  END;
  PHDHITTESTINFO = POINTER TO HDHITTESTINFO;

  HD_HITTESTINFO = HDHITTESTINFO;

CONST
  HDM_HITTEST = HDM_FIRST+6;

(* IF _WIN32_IE >= 0x0300 THEN *)
  HDM_GETITEMRECT = HDM_FIRST+7;

(* This procedure corresponds to a macro. *)
PROCEDURE Header_GetItemRect ( hwndHD: HWND; iIndex: INTEGER; VAR ItemRect: RECT ): BOOL;

CONST
  HDM_SETIMAGELIST = HDM_FIRST+8;

(* This procedure corresponds to a macro. *)
PROCEDURE Header_SetImageList ( hwndHD: HWND; himl: HIMAGELIST ): HIMAGELIST;

CONST
  HDM_GETIMAGELIST = HDM_FIRST+9;

(* This procedure corresponds to a macro. *)
PROCEDURE Header_GetImageList ( hwndHD: HWND ): HIMAGELIST;

CONST
  HDM_ORDERTOINDEX = HDM_FIRST+15;

(* This procedure corresponds to a macro. *)
PROCEDURE Header_OrderToIndex ( hwndHD: HWND; iOrder: INTEGER ): INTEGER;

CONST
  HDM_CREATEDRAGIMAGE = HDM_FIRST+16;   (*  wparam = which item (by index) *)

(* This procedure corresponds to a macro. *)
PROCEDURE Header_CreateDragImage ( hwndHD: HWND; iIndex: INTEGER ): HIMAGELIST;

CONST
  HDM_GETORDERARRAY = HDM_FIRST+17;

(* This procedure corresponds to a macro. *)
PROCEDURE Header_GetOrderArray ( hwndHD: HWND; iCount: INTEGER;
                                 VAR iArray: ARRAY OF INTEGER ): BOOL;

CONST
  HDM_SETORDERARRAY = HDM_FIRST+18;

(* This procedure corresponds to a macro. *)
PROCEDURE Header_SetOrderArray ( hwndHD: HWND; iCount: INTEGER;
                                 iArray: ARRAY OF INTEGER (*!*) ): BOOL;
(*  lparam = int array of size HDM_GETITEMCOUNT *)
(*  the array specifies the order that all items should be displayed. *)
(*  e.g.  { 2, 0, 1} *)
(*  says the index 2 item should be shown in the 0ths position *)
(*       index 0 should be shown in the 1st position *)
(*       index 1 should be shown in the 2nd position *)

CONST
  HDM_SETHOTDIVIDER = HDM_FIRST+19;

(* This procedure corresponds to a macro. *)
PROCEDURE Header_SetHotDivider ( hwndHD: HWND; flag: BOOL; dwInputValue: DWORD ): INTEGER;
(*  convenience message for external dragdrop *)
(*  wParam = BOOL  specifying whether the lParam is a dwPos of the cursor *)
(*               position or the index of which divider to hotlight *)
(*  lParam = depends on wParam  (-1 and wParm = FALSE turns off hotlight) *)
(* END *)

(* IF _WIN32_IE >= 0x0400 THEN *)
CONST
  HDM_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT;

(* This procedure corresponds to a macro. *)
PROCEDURE Header_SetUnicodeFormat ( hwnd: HWND; fUnicode: BOOL ): BOOL;

CONST
  HDM_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT;

(* This procedure corresponds to a macro. *)
PROCEDURE Header_GetUnicodeFormat ( hwnd: HWND ): BOOL;
(* END *)

CONST
  HDN_ITEMCHANGINGA    = HDN_FIRST-0;
  HDN_ITEMCHANGINGW    = HDN_FIRST-20;
  HDN_ITEMCHANGEDA     = HDN_FIRST-1;
  HDN_ITEMCHANGEDW     = HDN_FIRST-21;
  HDN_ITEMCLICKA       = HDN_FIRST-2;
  HDN_ITEMCLICKW       = HDN_FIRST-22;
  HDN_ITEMDBLCLICKA    = HDN_FIRST-3;
  HDN_ITEMDBLCLICKW    = HDN_FIRST-23;
  HDN_DIVIDERDBLCLICKA = HDN_FIRST-5;
  HDN_DIVIDERDBLCLICKW = HDN_FIRST-25;
  HDN_BEGINTRACKA      = HDN_FIRST-6;
  HDN_BEGINTRACKW      = HDN_FIRST-26;
  HDN_ENDTRACKA        = HDN_FIRST-7;
  HDN_ENDTRACKW        = HDN_FIRST-27;
  HDN_TRACKA           = HDN_FIRST-8;
  HDN_TRACKW           = HDN_FIRST-28;
(* IF _WIN32_IE >= 0x0300 THEN *)
  HDN_GETDISPINFOA     = HDN_FIRST-9;
  HDN_GETDISPINFOW     = HDN_FIRST-29;
  HDN_BEGINDRAG        = HDN_FIRST-10;
  HDN_ENDDRAG          = HDN_FIRST-11;
(* END *)

<* IF DEFINED (UNICODE) THEN *>
  HDN_ITEMCHANGING    = HDN_ITEMCHANGINGW;
  HDN_ITEMCHANGED     = HDN_ITEMCHANGEDW;
  HDN_ITEMCLICK       = HDN_ITEMCLICKW;
  HDN_ITEMDBLCLICK    = HDN_ITEMDBLCLICKW;
  HDN_DIVIDERDBLCLICK = HDN_DIVIDERDBLCLICKW;
  HDN_BEGINTRACK      = HDN_BEGINTRACKW;
  HDN_ENDTRACK        = HDN_ENDTRACKW;
  HDN_TRACK           = HDN_TRACKW;
(* IF _WIN32_IE >= 0x0300 THEN *)
  HDN_GETDISPINFO     = HDN_GETDISPINFOW;
(* END *)
<* ELSE *>
  HDN_ITEMCHANGING    = HDN_ITEMCHANGINGA;
  HDN_ITEMCHANGED     = HDN_ITEMCHANGEDA;
  HDN_ITEMCLICK       = HDN_ITEMCLICKA;
  HDN_ITEMDBLCLICK    = HDN_ITEMDBLCLICKA;
  HDN_DIVIDERDBLCLICK = HDN_DIVIDERDBLCLICKA;
  HDN_BEGINTRACK      = HDN_BEGINTRACKA;
  HDN_ENDTRACK        = HDN_ENDTRACKA;
  HDN_TRACK           = HDN_TRACKA;
(* IF _WIN32_IE >= 0x0300 THEN *)
  HDN_GETDISPINFO     = HDN_GETDISPINFOA;
(* END *)
<* END *>

TYPE
  NMHEADERA = RECORD
    hdr    : NMHDR;
    iItem  : INTEGER;
    iButton: INTEGER;
    pitem  : PHDITEMA;
  END;
  PNMHEADERA = POINTER TO NMHEADERA;

  NMHEADERW = RECORD
    hdr    : NMHDR;
    iItem  : INTEGER;
    iButton: INTEGER;
    pitem  : PHDITEMW;
  END;
  PNMHEADERW = POINTER TO NMHEADERW;

<* IF DEFINED (UNICODE) THEN *>
  NMHEADER  = NMHEADERW;
  PNMHEADER = PNMHEADERW;
<* ELSE *>
  NMHEADER  = NMHEADERA;
  PNMHEADER = PNMHEADERA;
<* END *>

  HD_NOTIFY  = NMHEADER;
  HD_NOTIFYA = NMHEADERA;
  HD_NOTIFYW = NMHEADERW;

  NMHDDISPINFOA = RECORD
    hdr       : NMHDR;
    iItem     : INTEGER;
    mask      : HDI_SET;
    pszText   : PSTR;
    cchTextMax: INTEGER;
    iImage    : INTEGER;
    lParam    : LPARAM;
  END;
  PNMHDDISPINFOA = POINTER TO NMHDDISPINFOA;

  NMHDDISPINFOW = RECORD
    hdr       : NMHDR;
    iItem     : INTEGER;
    mask      : HDI_SET;
    pszText   : PWSTR;
    cchTextMax: INTEGER;
    iImage    : INTEGER;
    lParam    : LPARAM;
  END;
  PNMHDDISPINFOW = POINTER TO NMHDDISPINFOW;

<* IF DEFINED (UNICODE) THEN *>
  NMHDDISPINFO  = NMHDDISPINFOW;
  PNMHDDISPINFO = PNMHDDISPINFOW;
<* ELSE *>
  NMHDDISPINFO  = NMHDDISPINFOA;
  PNMHDDISPINFO = PNMHDDISPINFOA;
<* END *>

(* ====== TOOLBAR CONTROL ====================================================== *)
CONST
  TOOLBARCLASSNAMEW = ARRAY OF WCHAR {ORD('T'),ORD('o'),ORD('o'),ORD('l'),ORD('b'),ORD('a'),ORD('r'),
                                      ORD('W'),ORD('i'),ORD('n'),ORD('d'),ORD('o'),ORD('w'),ORD('3'),ORD('2'),0};
  TOOLBARCLASSNAMEA = 'ToolbarWindow32';
<* IF DEFINED (UNICODE) THEN *>
  TOOLBARCLASSNAME = TOOLBARCLASSNAMEW;
<* ELSE *>
  TOOLBARCLASSNAME = TOOLBARCLASSNAMEA;
<* END *>

TYPE
<* PUSH *>
<* SETSIZE="1" *>
  TBSTATE_ENUM = (
    TBSTATE__CHECKED,           (* 0 *)
    TBSTATE__PRESSED,           (* 1 *)
    TBSTATE__ENABLED,           (* 2 *)
    TBSTATE__HIDDEN,            (* 3 *)
    TBSTATE__INDETERMINATE,     (* 4 *)
    TBSTATE__WRAP,              (* 5 *)
    TBSTATE__ELLIPSES,          (* 6 *)
    TBSTATE__MARKED             (* 7 *)
  );
  TBSTATE_SET = SET OF TBSTATE_ENUM;

  TBSTYLE_ENUM = (
    TBSTYLE__SEP,               (* 0 *)
    TBSTYLE__CHECK,             (* 1 *)
    TBSTYLE__GROUP,             (* 2 *)
    TBSTYLE__DROPDOWN,          (* 3 *)
    TBSTYLE__AUTOSIZE,          (* 4 *)
    TBSTYLE__NOPREFIX           (* 5 *)
  );
  TBSTYLE_SET = SET OF TBSTYLE_ENUM;
<* POP *>

CONST
  TBSTATE_CHECKED       = TBSTATE_SET {TBSTATE__CHECKED};       (* 01H *)
  TBSTATE_PRESSED       = TBSTATE_SET {TBSTATE__PRESSED};       (* 02H *)
  TBSTATE_ENABLED       = TBSTATE_SET {TBSTATE__ENABLED};       (* 04H *)
  TBSTATE_HIDDEN        = TBSTATE_SET {TBSTATE__HIDDEN};        (* 08H *)
  TBSTATE_INDETERMINATE = TBSTATE_SET {TBSTATE__INDETERMINATE}; (* 10H *)
  TBSTATE_WRAP          = TBSTATE_SET {TBSTATE__WRAP};          (* 20H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  TBSTATE_ELLIPSES      = TBSTATE_SET {TBSTATE__ELLIPSES};      (* 40H *)
(* END *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  TBSTATE_MARKED        = TBSTATE_SET {TBSTATE__MARKED};        (* 80H *)
(* END *)

(* styles of toolbarbuttons *)

  TBSTYLE_BUTTON          = TBSTYLE_SET {};                  (* 00H *)
  TBSTYLE_SEP             = TBSTYLE_SET {TBSTYLE__SEP};      (* 01H *)
  TBSTYLE_CHECK           = TBSTYLE_SET {TBSTYLE__CHECK};    (* 02H *)
  TBSTYLE_GROUP           = TBSTYLE_SET {TBSTYLE__GROUP};    (* 04H *)
  TBSTYLE_CHECKGROUP      = TBSTYLE_GROUP + TBSTYLE_CHECK;
(* IF _WIN32_IE >= 0x0300 THEN *)
  TBSTYLE_DROPDOWN        = TBSTYLE_SET {TBSTYLE__DROPDOWN}; (* 08H *)
(* END *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  TBSTYLE_AUTOSIZE        = TBSTYLE_SET {TBSTYLE__AUTOSIZE}; (* 10H *) (* automatically calculate the cx of the button *)
  TBSTYLE_NOPREFIX        = TBSTYLE_SET {TBSTYLE__NOPREFIX}; (* 20H *) (* if this button should not have accel prefix *)
(* END *)

(* Styles of Toolbar itself (window styles) *)

  TBSTYLE_TOOLTIPS        = WS_SET {WS__8};  (* 0100H *)
  TBSTYLE_WRAPABLE        = WS_SET {WS__9};  (* 0200H *)
  TBSTYLE_ALTDRAG         = WS_SET {WS__10}; (* 0400H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  TBSTYLE_FLAT            = WS_SET {WS__11}; (* 0800H *)
  TBSTYLE_LIST            = WS_SET {WS__12}; (* 1000H *)
  TBSTYLE_CUSTOMERASE     = WS_SET {WS__13}; (* 2000H *)
(* END *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  TBSTYLE_REGISTERDROP    = WS_SET {WS__14}; (* 4000H *)
  TBSTYLE_TRANSPARENT     = WS_SET {WS__15}; (* 8000H *)

  TBSTYLE_EX_DRAWDDARROWS = 0001H;
(* END *)

  CMB_MASKED = 2H;

TYPE
  TBBUTTON = RECORD
    iBitmap  : INTEGER;
    idCommand: INTEGER;
    fsState  : TBSTATE_SET; (* :BYTE *)
    fsStyle  : TBSTYLE_SET; (* :BYTE *)
    bReserved: ARRAY [0..2-1] OF SYSTEM.BYTE;
    dwData   : DWORD;
    iString  : INTEGER;
  END;
  PTBBUTTON = POINTER TO TBBUTTON;
  PCTBBUTTON = PTBBUTTON;

  COLORMAP = RECORD
    from: COLORREF;
    to  : COLORREF;
  END;
  PCOLORMAP = POINTER TO COLORMAP;

PROCEDURE CreateToolbarEx ( hwnd: HWND; ws: WS_SET; wID: UINT; nBitmaps: INTEGER;
                            hBMInst: HINSTANCE; wBMID: UINT;
                            Buttons: PCTBBUTTON; iNumButtons: INTEGER;
                            dxButton, dyButton, dxBitmap, dyBitmap: INTEGER;
                            uStructSize: UINT ): HWND;
PROCEDURE CreateMappedBitmap ( hInstance: HINSTANCE; idBitmap: INTEGER;
                               wFlags: UINT; lpColorMap: PCOLORMAP;
                               iNumMaps: INTEGER ): HBITMAP;

(* IF _WIN32_IE >= 0x0400 THEN *)
TYPE
  NMTBCUSTOMDRAW = RECORD
    nmcd                : NMCUSTOMDRAW;
    hbrMonoDither       : HBRUSH;
    hbrLines            : HBRUSH;        (*  For drawing lines on buttons *)
    hpenLines           : HPEN;          (*  For drawing lines on buttons *)
    clrText             : COLORREF;      (*  Color of text *)
    clrMark             : COLORREF;      (*  Color of text bk when marked. (only if TBSTATE_MARKED) *)
    clrTextHighlight    : COLORREF;      (*  Color of text when highlighted *)
    clrBtnFace          : COLORREF;      (*  Background of the button *)
    clrBtnHighlight     : COLORREF;      (*  3D highlight *)
    clrHighlightHotTrack: COLORREF;      (*  In conjunction with fHighlightHotTrack *)
    (*  will cause button to highlight like a menu *)
    rcText              : RECT;          (*  Rect for text *)
    nStringBkMode       : BKMODE_ENUM;
    nHLStringBkMode     : BKMODE_ENUM;
  END;
  PNMTBCUSTOMDRAW = POINTER TO NMTBCUSTOMDRAW;

(*  Toolbar custom draw return flags *)
CONST
  TBCDRF_NOEDGES        = 010000H;   (*  Don't draw button edges *)
  TBCDRF_HILITEHOTTRACK = 020000H;   (*  Use color of the button bk when hottracked *)
  TBCDRF_NOOFFSET       = 040000H;   (*  Don't offset button if pressed *)
  TBCDRF_NOMARK         = 080000H;   (*  Don't draw default highlight of image/text for TBSTATE_MARKED *)
  TBCDRF_NOETCHEDEFFECT = 100000H;   (*  Don't draw etched effect for disabled items *)
(* END *)

CONST
  TB_ENABLEBUTTON          = WM_USER+1;
  TB_CHECKBUTTON           = WM_USER+2;
  TB_PRESSBUTTON           = WM_USER+3;
  TB_HIDEBUTTON            = WM_USER+4;
  TB_INDETERMINATE         = WM_USER+5;
(* IF _WIN32_IE >= 0x0400 THEN *)
  TB_MARKBUTTON            = WM_USER+6;
(* END *)
  TB_ISBUTTONENABLED       = WM_USER+9;
  TB_ISBUTTONCHECKED       = WM_USER+10;
  TB_ISBUTTONPRESSED       = WM_USER+11;
  TB_ISBUTTONHIDDEN        = WM_USER+12;
  TB_ISBUTTONINDETERMINATE = WM_USER+13;
(* IF _WIN32_IE >= 0x0400 THEN *)
  TB_ISBUTTONHIGHLIGHTED   = WM_USER+14;
(* END *)
  TB_SETSTATE              = WM_USER+17;
  TB_GETSTATE              = WM_USER+18;
  TB_ADDBITMAP             = WM_USER+19;

TYPE 
  TBADDBITMAP = RECORD
    hInst: HINSTANCE;
    nID  : UINT;
  END;
  PTBADDBITMAP = POINTER TO TBADDBITMAP;

CONST
  HINST_COMMCTRL = SYSTEM.CAST(HINSTANCE, VAL(LONG, -1));
  IDB_STD_SMALL_COLOR  = 0;
  IDB_STD_LARGE_COLOR  = 1;
  IDB_VIEW_SMALL_COLOR = 4;
  IDB_VIEW_LARGE_COLOR = 5;
(* IF _WIN32_IE >= 0x0300 THEN *)
  IDB_HIST_SMALL_COLOR = 8;
  IDB_HIST_LARGE_COLOR = 9;
(* END *)

(*  icon indexes for standard bitmap *)
  STD_CUT        = 0;
  STD_COPY       = 1;
  STD_PASTE      = 2;
  STD_UNDO       = 3;
  STD_REDOW      = 4;
  STD_DELETE     = 5;
  STD_FILENEW    = 6;
  STD_FILEOPEN   = 7;
  STD_FILESAVE   = 8;
  STD_PRINTPRE   = 9;
  STD_PROPERTIES = 10;
  STD_HELP       = 11;
  STD_FIND       = 12;
  STD_REPLACE    = 13;
  STD_PRINT      = 14;

(*  icon indexes for standard view bitmap *)
  VIEW_LARGEICONS    = 0;
  VIEW_SMALLICONS    = 1;
  VIEW_LIST          = 2;
  VIEW_DETAILS       = 3;
  VIEW_SORTNAME      = 4;
  VIEW_SORTSIZE      = 5;
  VIEW_SORTDATE      = 6;
  VIEW_SORTTYPE      = 7;
  VIEW_PARENTFOLDER  = 8;
  VIEW_NETCONNECT    = 9;
  VIEW_NETDISCONNECT = 10;
  VIEW_NEWFOLDER     = 11;
(* IF _WIN32_IE >= 0x0400 THEN *)
  VIEW_VIEWMENU      = 12;
(* END *)

(* IF _WIN32_IE >= 0x0300 THEN *)
  HIST_BACK           = 0;
  HIST_FORWARD        = 1;
  HIST_FAVORITES      = 2;
  HIST_ADDTOFAVORITES = 3;
  HIST_VIEWTREE       = 4;
(* END *)

TYPE
  TBSAVEPARAMSA = RECORD
    hkr         : HKEY;
    pszSubKey   : PCSTR;
    pszValueName: PCSTR;
  END;
  PTBSAVEPARAMSA = POINTER TO TBSAVEPARAMSA;

  TBSAVEPARAMSW = RECORD
    hkr         : HKEY;
    pszSubKey   : PCWSTR;
    pszValueName: PCWSTR;
  END;
  PTBSAVEPARAMW = POINTER TO TBSAVEPARAMSW;

<* IF DEFINED (UNICODE) THEN *>
  TBSAVEPARAMS = TBSAVEPARAMSW;
  PTBSAVEPARAM = PTBSAVEPARAMW;
<* ELSE *>
  TBSAVEPARAMS = TBSAVEPARAMSA;
  PTBSAVEPARAM = PTBSAVEPARAMSA;
<* END *>

CONST
(*  New post Win95/NT4 for InsertButton and AddButton.  if iString member *)
(*  is a pointer to a string, it will be handled as a string like listview *)
(*  (although PSTR_TEXTCALLBACK is not supported). *)
  TB_ADDBUTTONSA      = WM_USER+20;
  TB_ADDBUTTONSW      = WM_USER+68;
  TB_INSERTBUTTONA    = WM_USER+21;
  TB_INSERTBUTTONW    = WM_USER+67;

  TB_DELETEBUTTON     = WM_USER+22;
  TB_GETBUTTON        = WM_USER+23;
  TB_BUTTONCOUNT      = WM_USER+24;
  TB_COMMANDTOINDEX   = WM_USER+25;

  TB_SAVERESTOREA     = WM_USER+26;
  TB_SAVERESTOREW     = WM_USER+76;
  TB_CUSTOMIZE        = WM_USER+27;
  TB_ADDSTRINGA       = WM_USER+28;
  TB_ADDSTRINGW       = WM_USER+77;
  TB_GETITEMRECT      = WM_USER+29;
  TB_BUTTONSTRUCTSIZE = WM_USER+30;
  TB_SETBUTTONSIZE    = WM_USER+31;
  TB_SETBITMAPSIZE    = WM_USER+32;
  TB_AUTOSIZE         = WM_USER+33;
  TB_GETTOOLTIPS      = WM_USER+35;
  TB_SETTOOLTIPS      = WM_USER+36;
  TB_SETPARENT        = WM_USER+37;
  TB_SETROWS          = WM_USER+39;
  TB_GETROWS          = WM_USER+40;
  TB_SETCMDID         = WM_USER+42;
  TB_CHANGEBITMAP     = WM_USER+43;
  TB_GETBITMAP        = WM_USER+44;
  TB_GETBUTTONTEXTA   = WM_USER+45;
  TB_GETBUTTONTEXTW   = WM_USER+75;
  TB_REPLACEBITMAP    = WM_USER+46;
(* IF _WIN32_IE >= 0x0300 THEN *)
  TB_SETINDENT            = WM_USER+47;
  TB_SETIMAGELIST         = WM_USER+48;
  TB_GETIMAGELIST         = WM_USER+49;
  TB_LOADIMAGES           = WM_USER+50;
  TB_GETRECT              = WM_USER+51;   (*  wParam is the Cmd instead of index *)
  TB_SETHOTIMAGELIST      = WM_USER+52;
  TB_GETHOTIMAGELIST      = WM_USER+53;
  TB_SETDISABLEDIMAGELIST = WM_USER+54;
  TB_GETDISABLEDIMAGELIST = WM_USER+55;
  TB_SETSTYLE             = WM_USER+56;
  TB_GETSTYLE             = WM_USER+57;
  TB_GETBUTTONSIZE        = WM_USER+58;
  TB_SETBUTTONWIDTH       = WM_USER+59;
  TB_SETMAXTEXTROWS       = WM_USER+60;
  TB_GETTEXTROWS          = WM_USER+61;
(* END *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  TB_GETOBJECT          = WM_USER+62;   (*  wParam == IID, lParam void **ppv *)
  TB_GETHOTITEM         = WM_USER+71;
  TB_SETHOTITEM         = WM_USER+72;   (*  wParam == iHotItem *)
  TB_SETANCHORHIGHLIGHT = WM_USER+73;   (*  wParam == TRUE/FALSE *)
  TB_GETANCHORHIGHLIGHT = WM_USER+74;
  TB_MAPACCELERATORA    = WM_USER+78;   (*  wParam == ch, lParam int * pidBtn *)
  TB_MAPACCELERATORW    = WM_USER+90;   (*  wParam == ch, lParam int * pidBtn *)
  TB_GETINSERTMARK      = WM_USER+79;   (*  lParam == PTBINSERTMARK *)
  TB_SETINSERTMARK      = WM_USER+80;   (*  lParam == PTBINSERTMARK *)
  TB_INSERTMARKHITTEST  = WM_USER+81;   (*  wParam == PPOINT lParam == PTBINSERTMARK *)
  TB_MOVEBUTTON         = WM_USER+82;
  TB_GETMAXSIZE         = WM_USER+83;   (*  lParam == PSIZE *)
  TB_SETEXTENDEDSTYLE   = WM_USER+84;   (*  For TBSTYLE_EX_* *)
  TB_GETEXTENDEDSTYLE   = WM_USER+85;   (*  For TBSTYLE_EX_* *)
  TB_GETPADDING         = WM_USER+86;
  TB_SETPADDING         = WM_USER+87;
  TB_SETINSERTMARKCOLOR = WM_USER+88;
  TB_GETINSERTMARKCOLOR = WM_USER+89;
(* END *)

<* IF DEFINED (UNICODE) THEN *>
  TB_ADDBUTTONS     = TB_ADDBUTTONSW;
  TB_INSERTBUTTON   = TB_INSERTBUTTONW;
  TB_SAVERESTORE    = TB_SAVERESTOREW;
  TB_ADDSTRING      = TB_ADDSTRINGW;
  TB_GETBUTTONTEXT  = TB_GETBUTTONTEXTW;
(* IF _WIN32_IE >= 0x0400 THEN *)
  TB_MAPACCELERATOR = TB_MAPACCELERATORW;
(* END *)
<* ELSE *>
  TB_ADDBUTTONS     = TB_ADDBUTTONSA;
  TB_INSERTBUTTON   = TB_INSERTBUTTONA;
  TB_SAVERESTORE    = TB_SAVERESTOREA;
  TB_ADDSTRING      = TB_ADDSTRINGA;
  TB_GETBUTTONTEXT  = TB_GETBUTTONTEXTA;
(* IF _WIN32_IE >= 0x0400 THEN *)
  TB_MAPACCELERATOR = TB_MAPACCELERATORA;
(* END *)
<* END *>

(* IF _WIN32_IE >= 0x0400 THEN *)
TYPE
  TBIMHT_ENUM = (
    TBIMHT_BEFORE,     (* 0 *)
    TBIMHT_AFTER,      (* 1 *)  (*  TRUE = insert After iButton, otherwise before *)
    TBIMHT_BACKGROUND  (* 2 *)  (*  TRUE iff missed buttons completely *)
  );

  TBINSERTMARK = RECORD
    iButton: INTEGER;
    dwFlags: TBIMHT_ENUM;
  END;
  PTBINSERTMARK = POINTER TO TBINSERTMARK;
(* END *)


CONST
  TB_SETCOLORSCHEME   = CCM_SETCOLORSCHEME;  (* lParam is color scheme *)
  TB_GETCOLORSCHEME   = CCM_GETCOLORSCHEME;  (* fills in COLORSCHEME pointed to by lParam *)

  TB_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT;
  TB_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT;

TYPE
  TBREPLACEBITMAP = RECORD
    hInstOld: HINSTANCE;
    nIDOld  : UINT;
    hInstNew: HINSTANCE;
    nIDNew  : UINT;
    nButtons: INTEGER;
  END;
  PTBREPLACEBITMAP = POINTER TO TBREPLACEBITMAP;

CONST
  TBBF_LARGE = 0001H;

  TB_GETBITMAPFLAGS = WM_USER+41;

(* IF _WIN32_IE >= 0x0400 THEN *)
TYPE
  TBIF_ENUM = (
    TBIF__IMAGE,        (* 0 *)
    TBIF__TEXT,         (* 1 *)
    TBIF__STATE,        (* 2 *)
    TBIF__STYLE,        (* 3 *)
    TBIF__LPARAM,       (* 4 *)
    TBIF__COMMAND,      (* 5 *)
    TBIF__SIZE          (* 6 *)
  );
  TBIF_SET = SET OF TBIF_ENUM;

CONST
  TBIF_IMAGE   = TBIF_SET {TBIF__IMAGE};   (* 0001H *)
  TBIF_TEXT    = TBIF_SET {TBIF__TEXT};    (* 0002H *)
  TBIF_STATE   = TBIF_SET {TBIF__STATE};   (* 0004H *)
  TBIF_STYLE   = TBIF_SET {TBIF__STYLE};   (* 0008H *)
  TBIF_LPARAM  = TBIF_SET {TBIF__LPARAM};  (* 0010H *)
  TBIF_COMMAND = TBIF_SET {TBIF__COMMAND}; (* 0020H *)
  TBIF_SIZE    = TBIF_SET {TBIF__SIZE};    (* 0040H *)

TYPE
  TBBUTTONINFOA = RECORD
    cbSize   : UINT;
    dwMask   : TBIF_SET;
    idCommand: INTEGER;
    iImage   : INTEGER;
    fsState  : TBSTATE_SET; (* :BYTE *)
    fsStyle  : TBSTYLE_SET; (* :BYTE *)
    cx       : WORD;
    lParam   : DWORD;
    pszText  : PSTR;
    cchText  : INTEGER;
  END;
  PTBBUTTONINFOA = POINTER TO TBBUTTONINFOA;

  TBBUTTONINFOW = RECORD
    cbSize   : UINT;
    dwMask   : TBIF_SET;
    idCommand: INTEGER;
    iImage   : INTEGER;
    fsState  : TBSTATE_SET; (* :BYTE *)
    fsStyle  : TBSTYLE_SET; (* :BYTE *)
    cx       : WORD;
    lParam   : DWORD;
    pszText  : PWSTR;
    cchText  : INTEGER;
  END;
  PTBBUTTONINFOW = POINTER TO TBBUTTONINFOW;

<* IF DEFINED (UNICODE) THEN *>
  TBBUTTONINFO  = TBBUTTONINFOW;
  PTBBUTTONINFO = PTBBUTTONINFOW;
<* ELSE *>
  TBBUTTONINFO  = TBBUTTONINFOA;
  PTBBUTTONINFO = PTBBUTTONINFOA;
<* END *>

(*  BUTTONINFO APIs do NOT support the string pool. *)
CONST
  TB_GETBUTTONINFOW   = WM_USER+63;
  TB_SETBUTTONINFOW   = WM_USER+64;
  TB_GETBUTTONINFOA   = WM_USER+65;
  TB_SETBUTTONINFOA   = WM_USER+66;

<* IF DEFINED (UNICODE) THEN *>
  TB_GETBUTTONINFO = TB_GETBUTTONINFOW;
  TB_SETBUTTONINFO = TB_SETBUTTONINFOW;
<* ELSE *>
  TB_GETBUTTONINFO = TB_GETBUTTONINFOA;
  TB_SETBUTTONINFO = TB_SETBUTTONINFOA;
<* END *>

  TB_HITTEST          = WM_USER+69;

  TB_SETDRAWTEXTFLAGS = WM_USER+70;   (*  wParam == mask lParam == bit values *)
(* END *)

  TBN_GETBUTTONINFOA  = TBN_FIRST-0;
  TBN_GETBUTTONINFOW  = TBN_FIRST-20;
<* IF DEFINED (UNICODE) THEN *>
  TBN_GETBUTTONINFO   = TBN_GETBUTTONINFOW;
<* ELSE *>
  TBN_GETBUTTONINFO   = TBN_GETBUTTONINFOA;
<* END *>
  TBN_BEGINDRAG       = TBN_FIRST-1;
  TBN_ENDDRAG         = TBN_FIRST-2;
  TBN_BEGINADJUST     = TBN_FIRST-3;
  TBN_ENDADJUST       = TBN_FIRST-4;
  TBN_RESET           = TBN_FIRST-5;
  TBN_QUERYINSERT     = TBN_FIRST-6;
  TBN_QUERYDELETE     = TBN_FIRST-7;
  TBN_TOOLBARCHANGE   = TBN_FIRST-8;
  TBN_CUSTHELP        = TBN_FIRST-9;
(* IF _WIN32_IE >= 0x0300 THEN *)
  TBN_DROPDOWN        = TBN_FIRST-10;
(* END *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  TBN_GETOBJECT       = TBN_FIRST-12;

(*  Hot item change flags *)
TYPE
  HICF_ENUM = (
    HICF__MOUSE,        (* 0 *)
    HICF__ARROWKEYS,    (* 1 *)
    HICF__ACCELERATOR,  (* 2 *)
    HICF__DUPACCEL,     (* 3 *)
    HICF__ENTERING,     (* 4 *)
    HICF__LEAVING,      (* 5 *)
    HICF__RESELECT      (* 6 *)
  );
  HICF_SET = SET OF HICF_ENUM;

CONST
  HICF_OTHER       = HICF_SET {};                  (* 0000H *)
  HICF_MOUSE       = HICF_SET {HICF__MOUSE};       (* 0001H *) (*  Triggered by mouse *)
  HICF_ARROWKEYS   = HICF_SET {HICF__ARROWKEYS};   (* 0002H *) (*  Triggered by arrow keys *)
  HICF_ACCELERATOR = HICF_SET {HICF__ACCELERATOR}; (* 0004H *) (*  Triggered by accelerator *)
  HICF_DUPACCEL    = HICF_SET {HICF__DUPACCEL};    (* 0008H *) (*  This accelerator is not unique *)
  HICF_ENTERING    = HICF_SET {HICF__ENTERING};    (* 0010H *) (*  idOld is invalid *)
  HICF_LEAVING     = HICF_SET {HICF__LEAVING};     (* 0020H *) (*  idNew is invalid *)
  HICF_RESELECT    = HICF_SET {HICF__RESELECT};    (* 0040H *) (*  hot item reselected *)

(*  Structure for TBN_HOTITEMCHANGE notification *)
TYPE
  NMTBHOTITEM = RECORD
    hdr    : NMHDR;
    idOld  : INTEGER;
    idNew  : INTEGER;
    dwFlags: HICF_SET;          (*  HICF_* *)
  END;
  PNMTBHOTITEM = POINTER TO NMTBHOTITEM;

CONST
  TBN_HOTITEMCHANGE  = TBN_FIRST-13;
  TBN_DRAGOUT        = TBN_FIRST-14;   (*  this is sent when the user clicks down on a button then drags off the button *)
  TBN_DELETINGBUTTON = TBN_FIRST-15;   (*  uses TBNOTIFY *)
  TBN_GETDISPINFOA   = TBN_FIRST-16;   (*  This is sent when the  toolbar needs  some display information *)
  TBN_GETDISPINFOW   = TBN_FIRST-17;   (*  This is sent when the  toolbar needs  some display information *)
  TBN_GETINFOTIPA    = TBN_FIRST-18;
  TBN_GETINFOTIPW    = TBN_FIRST-19;

<* IF DEFINED (UNICODE) THEN *>
  TBN_GETDISPINFO = TBN_GETDISPINFOW;
  TBN_GETINFOTIP  = TBN_GETINFOTIPW;
<* ELSE *>
  TBN_GETDISPINFO = TBN_GETDISPINFOA;
  TBN_GETINFOTIP  = TBN_GETINFOTIPA;
<* END *>

TYPE
  NMTBGETINFOTIPA = RECORD
    hdr       : NMHDR;
    pszText   : PSTR;
    cchTextMax: INTEGER;
    iItem     : INTEGER;
    lParam    : LPARAM;
  END;
  PNMTBGETINFOTIPA = POINTER TO NMTBGETINFOTIPA;

  NMTBGETINFOTIPW = RECORD
    hdr       : NMHDR;
    pszText   : PWSTR;
    cchTextMax: INTEGER;
    iItem     : INTEGER;
    lParam    : LPARAM;
  END;
  PNMTBGETINFOTIPW = POINTER TO NMTBGETINFOTIPW;

<* IF DEFINED (UNICODE) THEN *>
  NMTBGETINFOTIP  = NMTBGETINFOTIPW;
  PNMTBGETINFOTIP = PNMTBGETINFOTIPW;
<* ELSE *>
  NMTBGETINFOTIP  = NMTBGETINFOTIPA;
  PNMTBGETINFOTIP = PNMTBGETINFOTIPA;
<* END *>

TYPE
  TBNF_ENUM = [0 .. 28];
  TBNF_SET = SET OF TBNF_ENUM;

CONST
  TBNF__IMAGE      = 0;
  TBNF__TEXT       = 1;
  TBNF__DI_SETITEM = 28;

CONST
  TBNF_IMAGE      = TBNF_SET {TBNF__IMAGE};      (* 00000001H *)
  TBNF_TEXT       = TBNF_SET {TBNF__TEXT};       (* 00000002H *)
  TBNF_DI_SETITEM = TBNF_SET {TBNF__DI_SETITEM}; (* 10000000H *)

TYPE
  NMTBDISPINFOA = RECORD
    hdr      : NMHDR;
    dwMask   : TBNF_SET;    (*  [in] Specifies the values requested .[out] Client ask the data to be set for future use *)
    idCommand: INTEGER;     (*  [in] id of button we're requesting info for *)
    lParam   : DWORD;       (*  [in] lParam of button *)
    iImage   : INTEGER;     (*  [out] image index *)
    pszText  : PSTR;        (*  [out] new text for item *)
    cchText  : INTEGER;     (*  [in] size of buffer pointed to by pszText *)
  END;
  PNMTBDISPINFOA = POINTER TO NMTBDISPINFOA;

  NMTBDISPINFOW = RECORD
    hdr      : NMHDR;
    dwMask   : TBNF_SET;    (*  [in] Specifies the values requested .[out] Client ask the data to be set for future use *)
    idCommand: INTEGER;     (*  [in] id of button we're requesting info for *)
    lParam   : DWORD;       (*  [in] lParam of button *)
    iImage   : INTEGER;     (*  [out] image index *)
    pszText  : PWSTR;       (*  [out] new text for item *)
    cchText  : INTEGER;     (*  [in] size of buffer pointed to by pszText *)
  END;
  PNMTBDISPINFOW = POINTER TO NMTBDISPINFOW;

<* IF DEFINED (UNICODE) THEN *>
  NMTBDISPINFO  = NMTBDISPINFOW;
  PNMTBDISPINFO = PNMTBDISPINFOW;
<* ELSE *>
  NMTBDISPINFO  = NMTBDISPINFOA;
  PNMTBDISPINFO = PNMTBDISPINFOA;
<* END *>

(*  Return codes for TBN_DROPDOWN *)
CONST
  TBDDRET_DEFAULT      = 0;
  TBDDRET_NODEFAULT    = 1;
  TBDDRET_TREATPRESSED = 2;   (*  Treat as a standard press button *)
(* END *)

TYPE
  NMTOOLBARA = RECORD
    hdr     : NMHDR;
    iItem   : INTEGER;
    tbButton: TBBUTTON;
    cchText : INTEGER;
    pszText : PSTR;
  END;
  PNMTOOLBARA = POINTER TO NMTOOLBARA;

  NMTOOLBARW = RECORD
    hdr     : NMHDR;
    iItem   : INTEGER;
    tbButton: TBBUTTON;
    cchText : INTEGER;
    pszText : PWSTR;
  END;
  PNMTOOLBARW = POINTER TO NMTOOLBARW;

<* IF DEFINED (UNICODE) THEN *>
  NMTOOLBAR  = NMTOOLBARW;
  PNMTOOLBAR = PNMTOOLBARW;
<* ELSE *>
  NMTOOLBAR  = NMTOOLBARA;
  PNMTOOLBAR = PNMTOOLBARA;
<* END *>

  TBNOTIFY   = NMTOOLBAR;
  TBNOTIFYA  = NMTOOLBARA;
  TBNOTIFYW  = NMTOOLBARW;
  PTBNOTIFYA = PNMTOOLBARA;
  PTBNOTIFYW = PNMTOOLBARW;

(* IF _WIN32_IE >= 0x0300 THEN *)
(* ====== REBAR CONTROL ======================================================== *)
CONST
  REBARCLASSNAMEW = ARRAY OF WCHAR {ORD('R'),ORD('e'),ORD('B'),ORD('a'),ORD('r'),ORD('W'),ORD('i'),ORD('n'),
                                    ORD('d'),ORD('o'),ORD('w'),ORD('3'),ORD('2'),0};
  REBARCLASSNAMEA = 'ReBarWindow32';
<* IF DEFINED (UNICODE) THEN *>
  REBARCLASSNAME = REBARCLASSNAMEW;
<* ELSE *>
  REBARCLASSNAME = REBARCLASSNAMEA;
<* END *>

  RBS_TOOLTIPS        = WS_SET {WS__8};  (* 0100H *)
  RBS_VARHEIGHT       = WS_SET {WS__9};  (* 0200H *)
  RBS_BANDBORDERS     = WS_SET {WS__10}; (* 0400H *)
  RBS_FIXEDORDER      = WS_SET {WS__11}; (* 0800H *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  RBS_REGISTERDROP    = WS_SET {WS__12}; (* 1000H *)
  RBS_AUTOSIZE        = WS_SET {WS__13}; (* 2000H *)
  RBS_VERTICALGRIPPER = WS_SET {WS__14}; (* 4000H *)   (*  this always has the vertical gripper (default for horizontal mode) *)
  RBS_DBLCLKTOGGLE    = WS_SET {WS__15}; (* 8000H *)
(* END *)

  RBIM_IMAGELIST = 0001H;

TYPE
  REBARINFO = RECORD
    cbSize: UINT;
    fMask : UINT;
    himl  : HIMAGELIST;
  END;
  PREBARINFO = POINTER TO REBARINFO;

TYPE
  RBBS_ENUM = (
    RBBS__BREAK,                (* 0 *)
    RBBS__FIXEDSIZE,            (* 1 *)
    RBBS__CHILDEDGE,            (* 2 *)
    RBBS__HIDDEN,               (* 3 *)
    RBBS__NOVERT,               (* 4 *)
    RBBS__FIXEDBMP,             (* 5 *)
    RBBS__VARIABLEHEIGHT,       (* 6 *)
    RBBS__GRIPPERALWAYS,        (* 7 *)
    RBBS__NOGRIPPER             (* 8 *)
  );
  RBBS_SET = SET OF RBBS_ENUM;

  RBBIM_ENUM = (
    RBBIM__STYLE,               (*  0 *)
    RBBIM__COLORS,              (*  1 *)
    RBBIM__TEXT,                (*  2 *)
    RBBIM__IMAGE,               (*  3 *)
    RBBIM__CHILD,               (*  4 *)
    RBBIM__CHILDSIZE,           (*  5 *)
    RBBIM__SIZE,                (*  6 *)
    RBBIM__BACKGROUND,          (*  7 *)
    RBBIM__ID,                  (*  8 *)
    RBBIM__IDEALSIZE,           (*  9 *)
    RBBIM__LPARAM,              (* 10 *)
    RBBIM__HEADERSIZE           (* 11 *)
  );
  RBBIM_SET = SET OF RBBIM_ENUM;

CONST
  RBBS_BREAK          = RBBS_SET {RBBS__BREAK};          (* 0001H *)   (*  break to new line *)
  RBBS_FIXEDSIZE      = RBBS_SET {RBBS__FIXEDSIZE};      (* 0002H *)   (*  band can't be sized *)
  RBBS_CHILDEDGE      = RBBS_SET {RBBS__CHILDEDGE};      (* 0004H *)   (*  edge around top & bottom of child window *)
  RBBS_HIDDEN         = RBBS_SET {RBBS__HIDDEN};         (* 0008H *)   (*  don't show *)
  RBBS_NOVERT         = RBBS_SET {RBBS__NOVERT};         (* 0010H *)   (*  don't show when vertical *)
  RBBS_FIXEDBMP       = RBBS_SET {RBBS__FIXEDBMP};       (* 0020H *)   (*  bitmap doesn't move during band resize *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  RBBS_VARIABLEHEIGHT = RBBS_SET {RBBS__VARIABLEHEIGHT}; (* 0040H *)   (*  allow autosizing of this child vertically *)
  RBBS_GRIPPERALWAYS  = RBBS_SET {RBBS__GRIPPERALWAYS};  (* 0080H *)   (*  always show the gripper *)
  RBBS_NOGRIPPER      = RBBS_SET {RBBS__NOGRIPPER};      (* 0100H *)   (*  never show the gripper *)
(* END *)

  RBBIM_STYLE      = RBBIM_SET {RBBIM__STYLE};      (* 0001H *)
  RBBIM_COLORS     = RBBIM_SET {RBBIM__COLORS};     (* 0002H *)
  RBBIM_TEXT       = RBBIM_SET {RBBIM__TEXT};       (* 0004H *)
  RBBIM_IMAGE      = RBBIM_SET {RBBIM__IMAGE};      (* 0008H *)
  RBBIM_CHILD      = RBBIM_SET {RBBIM__CHILD};      (* 0010H *)
  RBBIM_CHILDSIZE  = RBBIM_SET {RBBIM__CHILDSIZE};  (* 0020H *)
  RBBIM_SIZE       = RBBIM_SET {RBBIM__SIZE};       (* 0040H *)
  RBBIM_BACKGROUND = RBBIM_SET {RBBIM__BACKGROUND}; (* 0080H *)
  RBBIM_ID         = RBBIM_SET {RBBIM__ID};         (* 0100H *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  RBBIM_IDEALSIZE  = RBBIM_SET {RBBIM__IDEALSIZE};  (* 0200H *)
  RBBIM_LPARAM     = RBBIM_SET {RBBIM__LPARAM};     (* 0400H *)
  RBBIM_HEADERSIZE = RBBIM_SET {RBBIM__HEADERSIZE}; (* 0800H *)   (*  control the size of the header *)
(* END *)

TYPE
  REBARBANDINFOA = RECORD
    cbSize    : UINT;
    fMask     : RBBIM_SET;
    fStyle    : RBBS_SET;
    clrFore   : COLORREF;
    clrBack   : COLORREF;
    lpText    : PSTR;
    cch       : UINT;
    iImage    : INTEGER;
    hwndChild : HWND;
    cxMinChild: UINT;
    cyMinChild: UINT;
    cx        : UINT;
    hbmBack   : HBITMAP;
    wID       : UINT;
(* IF _WIN32_IE >= 0x0400 THEN *)
    cyChild   : UINT;
    cyMaxChild: UINT;
    cyIntegral: UINT;
    cxIdeal   : UINT;
    lParam    : LPARAM;
    cxHeader  : UINT;
(* END *)
  END;
  PREBARBANDINFOA = POINTER TO REBARBANDINFOA;
  PCREBARBANDINFOA = PREBARBANDINFOA;

CONST
  REBARBANDINFOA_V3_SIZE = SIZE (REBARBANDINFOA) - SIZE (UINT) * 5 - SIZE (LPARAM);

TYPE
  REBARBANDINFOW = RECORD
    cbSize    : UINT;
    fMask     : RBBIM_SET;
    fStyle    : RBBS_SET;
    clrFore   : COLORREF;
    clrBack   : COLORREF;
    lpText    : PWSTR;
    cch       : UINT;
    iImage    : INTEGER;
    hwndChild : HWND;
    cxMinChild: UINT;
    cyMinChild: UINT;
    cx        : UINT;
    hbmBack   : HBITMAP;
    wID       : UINT;
(* IF _WIN32_IE >= 0x0400 THEN *)
    cyChild   : UINT;
    cyMaxChild: UINT;
    cyIntegral: UINT;
    cxIdeal   : UINT;
    lParam    : LPARAM;
    cxHeader  : UINT;
(* END *)
  END;
  PREBARBANDINFOW = POINTER TO REBARBANDINFOW;
  PCREBARBANDINFOW = PREBARBANDINFOW;

CONST
  REBARBANDINFOW_V3_SIZE = SIZE (REBARBANDINFOW) - SIZE (UINT) * 5 - SIZE (LPARAM);

<* IF DEFINED (UNICODE) THEN *>
TYPE
  REBARBANDINFO   = REBARBANDINFOW;
  PREBARBANDINFO  = PREBARBANDINFOW;
  PCREBARBANDINFO = PREBARBANDINFOW;
CONST
  REBARBANDINFO_V3_SIZE = REBARBANDINFOW_V3_SIZE;
<* ELSE *>
TYPE
  REBARBANDINFO   = REBARBANDINFOA;
  PREBARBANDINFO  = PREBARBANDINFOA;
  PCREBARBANDINFO = PREBARBANDINFOA;
CONST
  REBARBANDINFO_V3_SIZE = REBARBANDINFOA_V3_SIZE;
<* END *>

CONST
  RB_INSERTBANDA  = WM_USER+1;
  RB_DELETEBAND   = WM_USER+2;
  RB_GETBARINFO   = WM_USER+3;
  RB_SETBARINFO   = WM_USER+4;
  (* RB_GETBANDINFO = WM_USER+5; *)
  RB_SETBANDINFOA = WM_USER+6;
  RB_SETPARENT    = WM_USER+7;
(* IF _WIN32_IE >= 0x0400 THEN *)
  RB_HITTEST      = WM_USER+8;
  RB_GETRECT      = WM_USER+9;
(* END *)
  RB_INSERTBANDW  = WM_USER+10;
  RB_SETBANDINFOW = WM_USER+11;
  RB_GETBANDCOUNT = WM_USER+12;
  RB_GETROWCOUNT  = WM_USER+13;
  RB_GETROWHEIGHT = WM_USER+14;
(* IF _WIN32_IE >= 0x0400 THEN *)
  RB_IDTOINDEX    = WM_USER+16;   (*  wParam == id *)
  RB_GETTOOLTIPS  = WM_USER+17;
  RB_SETTOOLTIPS  = WM_USER+18;
  RB_SETBKCOLOR   = WM_USER+19;   (*  sets the default BK color *)
  RB_GETBKCOLOR   = WM_USER+20;   (*  defaults to CLR_NONE *)
  RB_SETTEXTCOLOR = WM_USER+21;
  RB_GETTEXTCOLOR = WM_USER+22;   (*  defaults to 0x00000000 *)
  RB_SIZETORECT   = WM_USER+23;   (*  resize the rebar/break bands and such to this rect (lparam) *)
(* END *)

  RB_SETCOLORSCHEME = CCM_SETCOLORSCHEME;  (* lParam is color scheme *)
  RB_GETCOLORSCHEME = CCM_GETCOLORSCHEME;  (* fills in COLORSCHEME pointed to by lParam *)

<* IF DEFINED (UNICODE) THEN *>
  RB_INSERTBAND  = RB_INSERTBANDW;
  RB_SETBANDINFO = RB_SETBANDINFOW;
<* ELSE *>
  RB_INSERTBAND  = RB_INSERTBANDA;
  RB_SETBANDINFO = RB_SETBANDINFOA;
<* END *>

(* IF _WIN32_IE >= 0x0400 THEN *)
(*  for manual drag control *)
(*  lparam == cursor pos *)
(*  -1 means do it yourself. *)
(*  -2 means use what you had saved before *)
  RB_BEGINDRAG    = WM_USER+24;
  RB_ENDDRAG      = WM_USER+25;
  RB_DRAGMOVE     = WM_USER+26;
  RB_GETBARHEIGHT = WM_USER+27;
  RB_GETBANDINFOW = WM_USER+28;
  RB_GETBANDINFOA = WM_USER+29;
<* IF DEFINED (UNICODE) THEN *>
  RB_GETBANDINFO  = RB_GETBANDINFOW;
<* ELSE *>
  RB_GETBANDINFO  = RB_GETBANDINFOA;
<* END *>

  RB_MINIMIZEBAND = WM_USER+30;
  RB_MAXIMIZEBAND = WM_USER+31;

  RB_GETDROPTARGET  = CCM_GETDROPTARGET;

  RB_GETBANDBORDERS = WM_USER+34;   (*  returns in lparam = lprc the amount of edges added to band wparam *)

  RB_SHOWBAND   = WM_USER+35;   (*  show/hide band *)
  RB_SETPALETTE = WM_USER+37;
  RB_GETPALETTE = WM_USER+38;
  RB_MOVEBAND   = WM_USER+39;

  RB_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT;
  RB_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT;
(* END *)

  RBN_HEIGHTCHANGE = RBN_FIRST-0;

(* IF _WIN32_IE >= 0x0400 THEN *)
  RBN_GETOBJECT     = RBN_FIRST-1;
  RBN_LAYOUTCHANGED = RBN_FIRST-2;
  RBN_AUTOSIZE      = RBN_FIRST-3;
  RBN_BEGINDRAG     = RBN_FIRST-4;
  RBN_ENDDRAG       = RBN_FIRST-5;
  RBN_DELETINGBAND  = RBN_FIRST-6;   (*  Uses NMREBAR *)
  RBN_DELETEDBAND   = RBN_FIRST-7;   (*  Uses NMREBAR *)
  RBN_CHILDSIZE     = RBN_FIRST-8;

TYPE
  RBNM_ENUM = (
    RBNM__ID,           (* 0 *)
    RBNM__STYLE,        (* 1 *)
    RBNM__LPARAM        (* 2 *)
  );
  RBNM_SET = SET OF RBNM_ENUM;

(*  Mask flags for NMREBAR *)
CONST
  RBNM_ID     = RBNM_SET {RBNM__ID};     (* 0001H *)
  RBNM_STYLE  = RBNM_SET {RBNM__STYLE};  (* 0002H *)
  RBNM_LPARAM = RBNM_SET {RBNM__LPARAM}; (* 0004H *)

TYPE
  NMREBARCHILDSIZE = RECORD
    hdr    : NMHDR;
    uBand  : UINT;
    wID    : UINT;
    rcChild: RECT;
    rcBand : RECT;
  END;
  PNMREBARCHILDSIZE = POINTER TO NMREBARCHILDSIZE;

  NMREBAR = RECORD
    hdr   : NMHDR;
    dwMask: RBNM_SET;       (*  RBNM_* *)
    uBand : UINT;
    fStyle: RBBS_SET;
    wID   : UINT;
    lParam: LPARAM;
  END;
  PNMREBAR = POINTER TO NMREBAR;

TYPE
  NMRBAUTOSIZE = RECORD
    hdr     : NMHDR;
    fChanged: BOOL;
    rcTarget: RECT;
    rcActual: RECT;
  END;
  PNMRBAUTOSIZE = POINTER TO NMRBAUTOSIZE;

TYPE
  RBHT_ENUM = (
    RBHT_0,
    RBHT_NOWHERE, (* 1H *)
    RBHT_CAPTION, (* 2H *)
    RBHT_CLIENT,  (* 3H *)
    RBHT_GRABBER  (* 4H *)
  );

  RBHITTESTINFO = RECORD
    pt   : POINT;
    flags: RBHT_ENUM;
    iItem: INTEGER;
  END;
  PRBHITTESTINFO = POINTER TO RBHITTESTINFO;
(* END *)
(* END *)

(* ====== TOOLTIPS CONTROL ===================================================== *)
CONST
  TOOLTIPS_CLASSW = ARRAY OF WCHAR {ORD('t'),ORD('o'),ORD('o'),ORD('l'),ORD('t'),ORD('i'),ORD('p'),ORD('s'),
                                    ORD('_'),ORD('c'),ORD('l'),ORD('a'),ORD('s'),ORD('s'),ORD('3'),ORD('2'),0};
  TOOLTIPS_CLASSA = 'tooltips_class32';
<* IF DEFINED (UNICODE) THEN *>
  TOOLTIPS_CLASS = TOOLTIPS_CLASSW;
<* ELSE *>
  TOOLTIPS_CLASS = TOOLTIPS_CLASSA;
<* END *>

CONST
  TTS_ALWAYSTIP = WS_SET {WS__0}; (* 0001H *)
  TTS_NOPREFIX  = WS_SET {WS__1}; (* 0002H *)

TYPE
  TTF_ENUM = (
    TTF__IDISHWND,      (*  0 *)
    TTF__CENTERTIP,     (*  1 *)
    TTF__RTLREADING,    (*  2 *)
    TTF__3,
    TTF__SUBCLASS,      (*  4 *)
    TTF__TRACK,         (*  5 *)
    TTF__6,
    TTF__ABSOLUTE,      (*  7 *)
    TTF__TRANSPARENT,   (*  8 *)
    TTF__9, TTF__10,
    TTF__11, TTF__12,
    TTF__13, TTF__14,
    TTF__DI_SETITEM     (* 15 *)
  );
  TTF_SET = SET OF TTF_ENUM;

CONST
  TTF_IDISHWND    = TTF_SET {TTF__IDISHWND};    (* 0001H *)

(*  Use this to center around trackpoint in trackmode *)
(*  -OR- to center around tool in normal mode. *)
(*  Use TTF_ABSOLUTE to place the tip exactly at the track coords when *)
(*  in tracking mode.  TTF_ABSOLUTE can be used in conjunction with TTF_CENTERTIP *)
(*  to center the tip absolutely about the track point. *)

  TTF_CENTERTIP   = TTF_SET {TTF__CENTERTIP};   (* 0002H *)
  TTF_RTLREADING  = TTF_SET {TTF__RTLREADING};  (* 0004H *)
  TTF_SUBCLASS    = TTF_SET {TTF__SUBCLASS};    (* 0010H *)

(* IF _WIN32_IE >= 0x0300 THEN *)
  TTF_TRACK       = TTF_SET {TTF__TRACK};       (* 0020H *)
  TTF_ABSOLUTE    = TTF_SET {TTF__ABSOLUTE};    (* 0080H *)
  TTF_TRANSPARENT = TTF_SET {TTF__TRANSPARENT}; (* 0100H *)
  TTF_DI_SETITEM  = TTF_SET {TTF__DI_SETITEM};  (* 8000H *)   (*  valid only on the TTN_NEEDTEXT callback *)
(* END *)

TYPE
  TTTOOLINFOA = RECORD
    cbSize  : UINT;
    uFlags  : TTF_SET;
    hwnd    : HWND;
    uId     : UINT;
    rect    : RECT;
    hinst   : HINSTANCE;
    lpszText: PSTR;
(* IF _WIN32_IE >= 0x0300 THEN *)
    lParam  : LPARAM;
(* END *)
  END;
  PTTTOOLINFOA = POINTER TO TTTOOLINFOA;

CONST
  TTTOOLINFOA_V1_SIZE = SIZE (TTTOOLINFOA) - SIZE (LPARAM);

TYPE
  TTTOOLINFOW = RECORD
    cbSize  : UINT;
    uFlags  : TTF_SET;
    hwnd    : HWND;
    uId     : UINT;
    rect    : RECT;
    hinst   : HINSTANCE;
    lpszText: PWSTR;
(* IF _WIN32_IE >= 0x0300 THEN *)
    lParam  : LPARAM;
(* END *)
  END;
  PTTTOOLINFOW = POINTER TO TTTOOLINFOW;

CONST
  TTTOOLINFOW_V1_SIZE = SIZE (TTTOOLINFOW) - SIZE (LPARAM);

<* IF DEFINED (UNICODE) THEN *>
TYPE
  TTTOOLINFO  = TTTOOLINFOW;
  PTTTOOLINFO = PTTTOOLINFOW;
CONST
  TTTOOLINFO_V1_SIZE = TTTOOLINFOW_V1_SIZE;
<* ELSE *>
TYPE
  TTTOOLINFO  = TTTOOLINFOA;
  PTTTOOLINFO = PTTTOOLINFOA;
CONST
  TTTOOLINFO_V1_SIZE = TTTOOLINFOA_V1_SIZE;
<* END *>

TYPE
  TOOLINFO    = TTTOOLINFO;
  TOOLINFOA   = TTTOOLINFOA;
  TOOLINFOW   = TTTOOLINFOW;
  PTOOLINFO   = PTTTOOLINFO;
  PTOOLINFOA  = PTTTOOLINFOA;
  PTOOLINFOW  = PTTTOOLINFOW;

CONST
  TTDT_AUTOMATIC = 0;
  TTDT_RESHOW    = 1;
  TTDT_AUTOPOP   = 2;
  TTDT_INITIAL   = 3;

  TTM_ACTIVATE        = WM_USER+1;
  TTM_SETDELAYTIME    = WM_USER+3;
  TTM_ADDTOOLA        = WM_USER+4;
  TTM_ADDTOOLW        = WM_USER+50;
  TTM_DELTOOLA        = WM_USER+5;
  TTM_DELTOOLW        = WM_USER+51;
  TTM_NEWTOOLRECTA    = WM_USER+6;
  TTM_NEWTOOLRECTW    = WM_USER+52;
  TTM_RELAYEVENT      = WM_USER+7;

  TTM_GETTOOLINFOA    = WM_USER+8;
  TTM_GETTOOLINFOW    = WM_USER+53;

  TTM_SETTOOLINFOA    = WM_USER+9;
  TTM_SETTOOLINFOW    = WM_USER+54;

  TTM_HITTESTA        = WM_USER+10;
  TTM_HITTESTW        = WM_USER+55;
  TTM_GETTEXTA        = WM_USER+11;
  TTM_GETTEXTW        = WM_USER+56;
  TTM_UPDATETIPTEXTA  = WM_USER+12;
  TTM_UPDATETIPTEXTW  = WM_USER+57;
  TTM_GETTOOLCOUNT    = WM_USER+13;
  TTM_ENUMTOOLSA      = WM_USER+14;
  TTM_ENUMTOOLSW      = WM_USER+58;
  TTM_GETCURRENTTOOLA = WM_USER+15;
  TTM_GETCURRENTTOOLW = WM_USER+59;
  TTM_WINDOWFROMPOINT = WM_USER+16;
(* IF _WIN32_IE >= 0x0300 THEN *)
  TTM_TRACKACTIVATE   = WM_USER+17;   (*  wParam = TRUE/FALSE start end  lparam = PTOOLINFO *)
  TTM_TRACKPOSITION   = WM_USER+18;   (*  lParam = dwPos *)
  TTM_SETTIPBKCOLOR   = WM_USER+19;
  TTM_SETTIPTEXTCOLOR = WM_USER+20;
  TTM_GETDELAYTIME    = WM_USER+21;
  TTM_GETTIPBKCOLOR   = WM_USER+22;
  TTM_GETTIPTEXTCOLOR = WM_USER+23;
  TTM_SETMAXTIPWIDTH  = WM_USER+24;
  TTM_GETMAXTIPWIDTH  = WM_USER+25;
  TTM_SETMARGIN       = WM_USER+26;   (*  lParam = lprc *)
  TTM_GETMARGIN       = WM_USER+27;   (*  lParam = lprc *)
  TTM_POP             = WM_USER+28;
(* END *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  TTM_UPDATE = WM_USER+29;
(* END *)

<* IF DEFINED (UNICODE) THEN *>
  TTM_ADDTOOL         = TTM_ADDTOOLW;
  TTM_DELTOOL         = TTM_DELTOOLW;
  TTM_NEWTOOLRECT     = TTM_NEWTOOLRECTW;
  TTM_GETTOOLINFO     = TTM_GETTOOLINFOW;
  TTM_SETTOOLINFO     = TTM_SETTOOLINFOW;
  TTM_HITTEST         = TTM_HITTESTW;
  TTM_GETTEXT         = TTM_GETTEXTW;
  TTM_UPDATETIPTEXT   = TTM_UPDATETIPTEXTW;
  TTM_ENUMTOOLS       = TTM_ENUMTOOLSW;
  TTM_GETCURRENTTOOL  = TTM_GETCURRENTTOOLW;
<* ELSE *>
  TTM_ADDTOOL         = TTM_ADDTOOLA;
  TTM_DELTOOL         = TTM_DELTOOLA;
  TTM_NEWTOOLRECT     = TTM_NEWTOOLRECTA;
  TTM_GETTOOLINFO     = TTM_GETTOOLINFOA;
  TTM_SETTOOLINFO     = TTM_SETTOOLINFOA;
  TTM_HITTEST         = TTM_HITTESTA;
  TTM_GETTEXT         = TTM_GETTEXTA;
  TTM_UPDATETIPTEXT   = TTM_UPDATETIPTEXTA;
  TTM_ENUMTOOLS       = TTM_ENUMTOOLSA;
  TTM_GETCURRENTTOOL  = TTM_GETCURRENTTOOLA;
<* END *>

TYPE
  TTHITTESTINFOA = RECORD
    hwnd: HWND;
    pt  : POINT;
    ti  : TTTOOLINFOA;
  END;
  PTTHITTESTINFOA = POINTER TO TTHITTESTINFOA;

  TTHITTESTINFOW = RECORD
    hwnd: HWND;
    pt  : POINT;
    ti  : TTTOOLINFOW;
  END;
  PTTHITTESTINFOW = POINTER TO TTHITTESTINFOW;

<* IF DEFINED (UNICODE) THEN *>
  TTHITTESTINFO  = TTHITTESTINFOW;
  PTTHITTESTINFO = PTTHITTESTINFOW;
<* ELSE *>
  TTHITTESTINFO  = TTHITTESTINFOA;
  PTTHITTESTINFO = PTTHITTESTINFOA;
<* END *>

  PHITTESTINFO  = PTTHITTESTINFO;
  PHITTESTINFOW = PTTHITTESTINFOW;
  PHITTESTINFOA = PTTHITTESTINFOA;

CONST
  TTN_GETDISPINFOA = TTN_FIRST-0;
  TTN_GETDISPINFOW = TTN_FIRST-10;
  TTN_SHOW         = TTN_FIRST-1;
  TTN_POP          = TTN_FIRST-2;

<* IF DEFINED (UNICODE) THEN *>
  TTN_GETDISPINFO  = TTN_GETDISPINFOW;
<* ELSE *>
  TTN_GETDISPINFO  = TTN_GETDISPINFOA;
<* END *>

  TTN_NEEDTEXT     = TTN_GETDISPINFO;
  TTN_NEEDTEXTA    = TTN_GETDISPINFOA;
  TTN_NEEDTEXTW    = TTN_GETDISPINFOW;

TYPE
  NMTTDISPINFOA = RECORD
    hdr     : NMHDR;
    lpszText: PSTR;
    szText  : ARRAY [0..80-1] OF CHAR;
    hinst   : HINSTANCE;
    uFlags  : TTF_SET;
(* IF _WIN32_IE >= 0x0300 THEN *)
    lParam  : LPARAM;
(* END *)
  END;
  PNMTTDISPINFOA = POINTER TO NMTTDISPINFOA;

CONST
  NMTTDISPINFOA_V1_SIZE = SIZE (NMTTDISPINFOA) - SIZE (LPARAM);

TYPE
  NMTTDISPINFOW = RECORD
    hdr     : NMHDR;
    lpszText: PWSTR;
    szText  : ARRAY [0..80-1] OF WCHAR;
    hinst   : HINSTANCE;
    uFlags  : TTF_SET;
(* IF _WIN32_IE >= 0x0300 THEN *)
    lParam  : LPARAM;
(* END *)
  END;
  PNMTTDISPINFOW = POINTER TO NMTTDISPINFOW;

CONST
  NMTTDISPINFOW_V1_SIZE = SIZE (NMTTDISPINFOW) - SIZE (LPARAM);

<* IF DEFINED (UNICODE) THEN *>
TYPE
  NMTTDISPINFO  = NMTTDISPINFOW;
  PNMTTDISPINFO = PNMTTDISPINFOW;
CONST
  NMTTDISPINFO_V1_SIZE = NMTTDISPINFOA_V1_SIZE;
<* ELSE *>
TYPE
  NMTTDISPINFO  = NMTTDISPINFOA;
  PNMTTDISPINFO = PNMTTDISPINFOA;
CONST
  NMTTDISPINFO_V1_SIZE = NMTTDISPINFOW_V1_SIZE;
<* END *>

TYPE
  TOOLTIPTEXT   = NMTTDISPINFO;
  TOOLTIPTEXTW  = NMTTDISPINFOW;
  TOOLTIPTEXTA  = NMTTDISPINFOA;
  PTOOLTIPTEXT  = PNMTTDISPINFO;
  PTOOLTIPTEXTA = PNMTTDISPINFOA;
  PTOOLTIPTEXTW = PNMTTDISPINFOW;

(* ====== STATUS BAR CONTROL =================================================== *)

TYPE
  SBT_ENUM = (
    SBT__0, SBT__1, SBT__2, SBT__3, SBT__4, SBT__5, SBT__6, SBT__7,
    SBT__NOBORDERS,     (*  8 *)
    SBT__POPOUT,        (*  9 *)
    SBT__RTLREADING,    (* 10 *)
    SBT__TOOLTIPS,      (* 11 *)
    SBT__OWNERDRAW      (* 12 *)
  );
  SBT_SET = SET OF SBT_ENUM;

CONST
  SBT_OWNERDRAW  = SBT_SET {SBT__OWNERDRAW};  (* 1000H *)
  SBT_NOBORDERS  = SBT_SET {SBT__NOBORDERS};  (* 0100H *)
  SBT_POPOUT     = SBT_SET {SBT__POPOUT};     (* 0200H *)
  SBT_RTLREADING = SBT_SET {SBT__RTLREADING}; (* 0400H *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  SBT_TOOLTIPS   = WS_SET {WS__11};
(* END *)

  SBARS_SIZEGRIP = WS_SET {WS__8}; (* 00000100H *)

PROCEDURE DrawStatusTextA ( hDC: HDC; prc: PRECT; pszText: PCSTR; uFlags: SBT_SET );
PROCEDURE DrawStatusTextW ( hDC: HDC; prc: PRECT; pszText: PCWSTR; uFlags: SBT_SET );

PROCEDURE CreateStatusWindowA ( style: WS_SET; pszText: PCSTR;
                                hwndParent: HWND; wID: UINT ): HWND;
PROCEDURE CreateStatusWindowW ( style: WS_SET; pszText: PCWSTR;
                                hwndParent: HWND; wID: UINT ): HWND;

CONST
<* IF DEFINED (UNICODE) THEN *>
  DrawStatusText = DrawStatusTextW;
  CreateStatusWindow = CreateStatusWindowW;
<* ELSE *>
  DrawStatusText = DrawStatusTextA;
  CreateStatusWindow = CreateStatusWindowA;
<* END *>

CONST
  STATUSCLASSNAMEW = ARRAY OF WCHAR {ORD('m'),ORD('s'),ORD('c'),ORD('t'),ORD('l'),ORD('s'),ORD('_'),ORD('s'),
                                     ORD('t'),ORD('a'),ORD('t'),ORD('u'),ORD('s'),ORD('b'),ORD('a'),ORD('r'),
                                     ORD('3'),ORD('2'),0};
  STATUSCLASSNAMEA = 'msctls_statusbar32';
<* IF DEFINED (UNICODE) THEN *>
  STATUSCLASSNAME = STATUSCLASSNAMEW;
<* ELSE *>
  STATUSCLASSNAME = STATUSCLASSNAMEA;
<* END *>

  SB_SETTEXTA         = WM_USER+1;
  SB_SETTEXTW         = WM_USER+11;
  SB_GETTEXTA         = WM_USER+2;
  SB_GETTEXTW         = WM_USER+13;
  SB_GETTEXTLENGTHA   = WM_USER+3;
  SB_GETTEXTLENGTHW   = WM_USER+12;
  SB_SETPARTS         = WM_USER+4;
  SB_GETPARTS         = WM_USER+6;
  SB_GETBORDERS       = WM_USER+7;
  SB_SETMINHEIGHT     = WM_USER+8;
  SB_SIMPLE           = WM_USER+9;
  SB_GETRECT          = WM_USER+10;
(* IF _WIN32_IE >= 0x0300 THEN *)
  SB_ISSIMPLE         = WM_USER+14;
(* END *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  SB_SETICON          = WM_USER+15;
  SB_SETTIPTEXTA      = WM_USER+16;
  SB_SETTIPTEXTW      = WM_USER+17;
  SB_GETTIPTEXTA      = WM_USER+18;
  SB_GETTIPTEXTW      = WM_USER+19;
  SB_GETICON          = WM_USER+20;
  SB_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT;
  SB_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT;
(* END *)

<* IF DEFINED (UNICODE) THEN *>
  SB_SETTEXT          = SB_SETTEXTW;
  SB_GETTEXT          = SB_GETTEXTW;
  SB_GETTEXTLENGTH    = SB_GETTEXTLENGTHW;
  SB_SETTIPTEXT       = SB_SETTIPTEXTW;
  SB_GETTIPTEXT       = SB_GETTIPTEXTW;
<* ELSE *>
  SB_SETTEXT          = SB_SETTEXTA;
  SB_GETTEXT          = SB_GETTEXTA;
  SB_GETTEXTLENGTH    = SB_GETTEXTLENGTHA;
  SB_SETTIPTEXT       = SB_SETTIPTEXTA;
  SB_GETTIPTEXT       = SB_GETTIPTEXTA;
<* END *>

  SB_SETBKCOLOR = CCM_SETBKCOLOR;      (* lParam = bkColor *)

(* IF _WIN32_IE >= 0x0400 THEN *)
(* / status bar notifications *)
  SBN_SIMPLEMODECHANGE = SBN_FIRST-0;
(* END *)

(* ====== MENU HELP ============================================================ *)

PROCEDURE MenuHelp ( uMsg: UINT; wParam: WPARAM; lParam: LPARAM; hMainMenu: HMENU;
                     hInst: HINSTANCE; hwndStatus: HWND; lpwIDs: PUINT );
PROCEDURE ShowHideMenuCtl ( hWnd: HWND; uFlags: UINT; lpInfo: INTARRAY ): BOOL;
PROCEDURE GetEffectiveClientRect ( hWnd: HWND; lprc: PRECT; lpInfo: INTARRAY );

CONST
  MINSYSCOMMAND = SC_SIZE;

(* ====== TRACKBAR CONTROL ===================================================== *)
CONST
  TRACKBAR_CLASSW = ARRAY OF WCHAR {ORD('m'),ORD('s'),ORD('c'),ORD('t'),ORD('l'),ORD('s'),ORD('_'),ORD('t'),
                                    ORD('r'),ORD('a'),ORD('c'),ORD('k'),ORD('b'),ORD('a'),ORD('r'),ORD('3'),ORD('2'),0};
  TRACKBAR_CLASSA = 'msctls_trackbar32';
<* IF DEFINED (UNICODE) THEN *>
  TRACKBAR_CLASS = TRACKBAR_CLASSW;
<* ELSE *>
  TRACKBAR_CLASS = TRACKBAR_CLASSA;
<* END *>

  TBS_AUTOTICKS      = WS_SET {WS__0}; (* 0001H *)
  TBS_VERT           = WS_SET {WS__1}; (* 0002H *)
  TBS_HORZ           = WS_SET {};      (* 0000H *)
  TBS_TOP            = WS_SET {WS__2}; (* 0004H *)
  TBS_BOTTOM         = WS_SET {};      (* 0000H *)
  TBS_LEFT           = WS_SET {WS__2}; (* 0004H *)
  TBS_RIGHT          = WS_SET {};      (* 0000H *)
  TBS_BOTH           = WS_SET {WS__3}; (* 0008H *)
  TBS_NOTICKS        = WS_SET {WS__4}; (* 0010H *)
  TBS_ENABLESELRANGE = WS_SET {WS__5}; (* 0020H *)
  TBS_FIXEDLENGTH    = WS_SET {WS__6}; (* 0040H *)
  TBS_NOTHUMB        = WS_SET {WS__7}; (* 0080H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  TBS_TOOLTIPS       = WS_SET {WS__8}; (* 0100H *)
(* END *)

  TBM_GETPOS         = WM_USER;
  TBM_GETRANGEMIN    = WM_USER+1;
  TBM_GETRANGEMAX    = WM_USER+2;
  TBM_GETTIC         = WM_USER+3;
  TBM_SETTIC         = WM_USER+4;
  TBM_SETPOS         = WM_USER+5;
  TBM_SETRANGE       = WM_USER+6;
  TBM_SETRANGEMIN    = WM_USER+7;
  TBM_SETRANGEMAX    = WM_USER+8;
  TBM_CLEARTICS      = WM_USER+9;
  TBM_SETSEL         = WM_USER+10;
  TBM_SETSELSTART    = WM_USER+11;
  TBM_SETSELEND      = WM_USER+12;
  TBM_GETPTICS       = WM_USER+14;
  TBM_GETTICPOS      = WM_USER+15;
  TBM_GETNUMTICS     = WM_USER+16;
  TBM_GETSELSTART    = WM_USER+17;
  TBM_GETSELEND      = WM_USER+18;
  TBM_CLEARSEL       = WM_USER+19;
  TBM_SETTICFREQ     = WM_USER+20;
  TBM_SETPAGESIZE    = WM_USER+21;
  TBM_GETPAGESIZE    = WM_USER+22;
  TBM_SETLINESIZE    = WM_USER+23;
  TBM_GETLINESIZE    = WM_USER+24;
  TBM_GETTHUMBRECT   = WM_USER+25;
  TBM_GETCHANNELRECT = WM_USER+26;
  TBM_SETTHUMBLENGTH = WM_USER+27;
  TBM_GETTHUMBLENGTH = WM_USER+28;
(* IF _WIN32_IE >= 0x0300 THEN *)
  TBM_SETTOOLTIPS    = WM_USER+29;
  TBM_GETTOOLTIPS    = WM_USER+30;
  TBM_SETTIPSIDE     = WM_USER+31;

(*  TrackBar Tip Side flags *)
  TBTS_TOP    = 0;
  TBTS_LEFT   = 1;
  TBTS_BOTTOM = 2;
  TBTS_RIGHT  = 3;

  TBM_SETBUDDY = WM_USER+32;  (* wparam = BOOL fLeft; (or right) *)
  TBM_GETBUDDY = WM_USER+33;  (* wparam = BOOL fLeft; (or right) *)
(* END *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  TBM_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT;
  TBM_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT;
(* END *)

  TB_LINEUP        = 0;
  TB_LINEDOWN      = 1;
  TB_PAGEUP        = 2;
  TB_PAGEDOWN      = 3;
  TB_THUMBPOSITION = 4;
  TB_THUMBTRACK    = 5;
  TB_TOP           = 6;
  TB_BOTTOM        = 7;
  TB_ENDTRACK      = 8;

(* IF _WIN32_IE >= 0x0300 THEN *)
(*  custom draw item specs *)
  TBCD_TICS    = 1H;
  TBCD_THUMB   = 2H;
  TBCD_CHANNEL = 3H;
(* END *)

(* ====== DRAG LIST CONTROL ==================================================== *)
TYPE
  DL_ENUM = (
    DL_CURSORSET,  (* 0 *)
    DL_STOPCURSOR, (* 1 *)
    DL_COPYCURSOR, (* 2 *)
    DL_MOVECURSOR  (* 3 *)
  );

  DRAGLISTINFO = RECORD
    uNotification: DL_ENUM;
    hWnd         : HWND;
    ptCursor     : POINT;
  END;
  PDRAGLISTINFO = POINTER TO DRAGLISTINFO;

CONST
  DL_BEGINDRAG  = WM_USER+133;
  DL_DRAGGING   = WM_USER+134;
  DL_DROPPED    = WM_USER+135;
  DL_CANCELDRAG = WM_USER+136;

DRAGLISTMSGSTRINGW = ARRAY OF WCHAR {ORD('c'),ORD('o'),ORD('m'),ORD('m'),ORD('c'),ORD('t'),ORD('r'),ORD('l'),
                                     ORD('_'),ORD('D'),ORD('r'),ORD('a'),ORD('g'),ORD('L'),ORD('i'),ORD('s'),
                                     ORD('t'),ORD('M'),ORD('s'),ORD('g')};

DRAGLISTMSGSTRINGA = "commctrl_DragListMsg";

<* IF DEFINED (UNICODE) THEN *>
  DRAGLISTMSGSTRING = DRAGLISTMSGSTRINGW;
<* ELSE *>
  DRAGLISTMSGSTRING = DRAGLISTMSGSTRINGA;
<* END *>

PROCEDURE MakeDragList ( hLB: HWND ): BOOL;
PROCEDURE DrawInsert ( handParent: HWND; hLB: HWND; nItem: INTEGER );

(* Following procedure implemented as a macro because of POINT parameter *)

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlLBItemFromPt ( hLB: HWND; pt: POINT; bAutoScroll: BOOL ): INTEGER;
CONST LBItemFromPt = rtlLBItemFromPt;
<* ELSE *>
PROCEDURE LBItemFromPt ( hLB: HWND; pt: POINT; bAutoScroll: BOOL ): INTEGER;
<* END *>

(* ====== UPDOWN CONTROL ======================================================= *)
CONST
  UPDOWN_CLASSW = ARRAY OF WCHAR {ORD('m'),ORD('s'),ORD('c'),ORD('t'),ORD('l'),ORD('s'),ORD('_'),ORD('u'),
                                  ORD('p'),ORD('d'),ORD('o'),ORD('w'),ORD('n'),ORD('3'),ORD('2'),0};
  UPDOWN_CLASSA = 'msctls_updown32';
<* IF DEFINED (UNICODE) THEN *>
  UPDOWN_CLASS = UPDOWN_CLASSW;
<* ELSE *>
  UPDOWN_CLASS = UPDOWN_CLASSA;
<* END *>

TYPE
  UDACCEL = RECORD
    nSec: UINT;
    nInc: UINT;
  END;
  PUDACCEL = POINTER TO UDACCEL;

CONST
  UD_MAXVAL = 7FFFH;
  UD_MINVAL = -UD_MAXVAL;

  UDS_WRAP        = WS_SET {WS__0}; (* 0001H *)
  UDS_SETBUDDYINT = WS_SET {WS__1}; (* 0002H *)
  UDS_ALIGNRIGHT  = WS_SET {WS__2}; (* 0004H *)
  UDS_ALIGNLEFT   = WS_SET {WS__3}; (* 0008H *)
  UDS_AUTOBUDDY   = WS_SET {WS__4}; (* 0010H *)
  UDS_ARROWKEYS   = WS_SET {WS__5}; (* 0020H *)
  UDS_HORZ        = WS_SET {WS__6}; (* 0040H *)
  UDS_NOTHOUSANDS = WS_SET {WS__7}; (* 0080H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  UDS_HOTTRACK    = WS_SET {WS__8}; (* 0100H *)
(* END *)

  UDM_SETRANGE         = WM_USER+101;
  UDM_GETRANGE         = WM_USER+102;
  UDM_SETPOS           = WM_USER+103;
  UDM_GETPOS           = WM_USER+104;
  UDM_SETBUDDY         = WM_USER+105;
  UDM_GETBUDDY         = WM_USER+106;
  UDM_SETACCEL         = WM_USER+107;
  UDM_GETACCEL         = WM_USER+108;
  UDM_SETBASE          = WM_USER+109;
  UDM_GETBASE          = WM_USER+110;
(* IF _WIN32_IE >= 0x0400 THEN *)
  UDM_SETRANGE32       = WM_USER+111;
  UDM_GETRANGE32       = WM_USER+112;   (*  wParam & lParam are PINT *)
  UDM_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT;
  UDM_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT;
(* END *)

PROCEDURE CreateUpDownControl ( dwStyle: WS_SET; x, y, cx, cy: INTEGER; hParent: HWND;
                                nID: INTEGER; hInst: HINSTANCE; hBuddy: HWND;
                                nUpper, nLower, nPos: INTEGER ): HWND;

TYPE 
  NMUPDOWN = RECORD
    hdr   : NMHDR;
    iPos  : INTEGER;
    iDelta: INTEGER;
  END;
  PNMUPDOWN = POINTER TO NMUPDOWN;

  NM_UPDOWN  = NMUPDOWN;
  PNM_UPDOWN = PNMUPDOWN;

CONST
  UDN_DELTAPOS = UDN_FIRST-1;

(* ====== PROGRESS CONTROL ===================================================== *)
  PROGRESS_CLASSW = ARRAY OF WCHAR {ORD('m'),ORD('s'),ORD('c'),ORD('t'),ORD('l'),ORD('s'),ORD('_'),ORD('p'),
                                    ORD('r'),ORD('o'),ORD('g'),ORD('r'),ORD('e'),ORD('s'),ORD('s'),ORD('3'),ORD('2'),0};
  PROGRESS_CLASSA = 'msctls_progress32';
<* IF DEFINED (UNICODE) THEN *>
  PROGRESS_CLASS = PROGRESS_CLASSW;
<* ELSE *>
  PROGRESS_CLASS = PROGRESS_CLASSA;
<* END *>

(* IF _WIN32_IE >= 0x0300 THEN *)
  PBS_SMOOTH   = WS_SET {WS__0}; (* 0001H *)
  PBS_VERTICAL = WS_SET {WS__2}; (* 0004H *)
(* END *)

  PBM_SETRANGE   = WM_USER+1;
  PBM_SETPOS     = WM_USER+2;
  PBM_DELTAPOS   = WM_USER+3;
  PBM_SETSTEP    = WM_USER+4;
  PBM_STEPIT     = WM_USER+5;
(* IF _WIN32_IE >= 0x0300 THEN *)
  PBM_SETRANGE32 = WM_USER+6;   (*  lParam = high, wParam = low *)

TYPE
  PBRANGE = RECORD
    iLow : INTEGER;
    iHigh: INTEGER;
  END;
  PPBRANGE = POINTER TO PBRANGE;

CONST
  PBM_GETRANGE    = WM_USER+7;   (*  wParam = return (TRUE ? low : high). lParam = PPBRANGE or NULL *)
  PBM_GETPOS      = WM_USER+8;
(* IF _WIN32_IE >= 0x0400 THEN *)
  PBM_SETBARCOLOR = WM_USER+9;   (*  lParam = bar color *)
(* END *)
  PBM_SETBKCOLOR  = CCM_SETBKCOLOR;
(* END *)

(* ====== HOTKEY CONTROL ======================================================= *)
  HOTKEYF_SHIFT   = 0001H;
  HOTKEYF_CONTROL = 0002H;
  HOTKEYF_ALT     = 0004H;
  HOTKEYF_EXT     = 0008H;

  HKCOMB_NONE = 0001H;
  HKCOMB_S    = 0002H;
  HKCOMB_C    = 0004H;
  HKCOMB_A    = 0008H;
  HKCOMB_SC   = 0010H;
  HKCOMB_SA   = 0020H;
  HKCOMB_CA   = 0040H;
  HKCOMB_SCA  = 0080H;

  HKM_SETHOTKEY = WM_USER+1;
  HKM_GETHOTKEY = WM_USER+2;
  HKM_SETRULES  = WM_USER+3;

  HOTKEY_CLASSW = ARRAY OF WCHAR {ORD('m'),ORD('s'),ORD('c'),ORD('t'),ORD('l'),ORD('s'),ORD('_'),ORD('h'),
                                  ORD('o'),ORD('t'),ORD('k'),ORD('e'),ORD('y'),ORD('3'),ORD('2'),0};
  HOTKEY_CLASSA = 'msctls_hotkey32';

<* IF DEFINED (UNICODE) THEN *>
  HOTKEY_CLASS = HOTKEY_CLASSW;
<* ELSE *>
  HOTKEY_CLASS = HOTKEY_CLASSA;
<* END *>

(* ====== COMMON CONTROL STYLES ================================================ *)
  CCS_TOP           = WS_SET {WS__0};        (* 0001H *)
  CCS_NOMOVEY       = WS_SET {WS__1};        (* 0002H *)
  CCS_BOTTOM        = WS_SET {WS__0, WS__1}; (* 0003H *)
  CCS_NORESIZE      = WS_SET {WS__2};        (* 0004H *)
  CCS_NOPARENTALIGN = WS_SET {WS__3};        (* 0008H *)
  CCS_ADJUSTABLE    = WS_SET {WS__5};        (* 0020H *)
  CCS_NODIVIDER     = WS_SET {WS__6};        (* 0040H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  CCS_VERT          = WS_SET {WS__7};        (* 0080H *)
  CCS_LEFT          = CCS_VERT + CCS_TOP;
  CCS_RIGHT         = CCS_VERT + CCS_BOTTOM;
  CCS_NOMOVEX       = CCS_VERT + CCS_NOMOVEY;
(* END *)

(* ====== LISTVIEW CONTROL ===================================================== *)
  WC_LISTVIEWW = ARRAY OF WCHAR {ORD('S'),ORD('y'),ORD('s'),ORD('L'),ORD('i'),ORD('s'),ORD('t'),ORD('V'),
                                 ORD('i'),ORD('e'),ORD('w'),ORD('3'),ORD('2'),0};
  WC_LISTVIEWA = 'SysListView32';
<* IF DEFINED (UNICODE) THEN *>
  WC_LISTVIEW = WC_LISTVIEWW;
<* ELSE *>
  WC_LISTVIEW = WC_LISTVIEWA;
<* END *>

  LVS_ICON            = WS_SET {};             (* 0000H *)
  LVS_REPORT          = WS_SET {WS__0};        (* 0001H *)
  LVS_SMALLICON       = WS_SET {WS__1};        (* 0002H *)
  LVS_LIST            = WS_SET {WS__0, WS__1}; (* 0003H *)
  LVS_TYPEMASK        = WS_SET {WS__0, WS__1}; (* 0003H *)
  LVS_SINGLESEL       = WS_SET {WS__2};        (* 0004H *)
  LVS_SHOWSELALWAYS   = WS_SET {WS__3};        (* 0008H *)
  LVS_SORTASCENDING   = WS_SET {WS__4};        (* 0010H *)
  LVS_SORTDESCENDING  = WS_SET {WS__5};        (* 0020H *)
  LVS_SHAREIMAGELISTS = WS_SET {WS__6};        (* 0040H *)
  LVS_NOLABELWRAP     = WS_SET {WS__7};        (* 0080H *)
  LVS_AUTOARRANGE     = WS_SET {WS__8};        (* 0100H *)
  LVS_EDITLABELS      = WS_SET {WS__9};        (* 0200H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  LVS_OWNERDATA       = WS_SET {WS__12};       (* 1000H *)
(* END *)
  LVS_NOSCROLL        = WS_SET {WS__13};       (* 2000H *)

  LVS_TYPESTYLEMASK   = WS_SET {WS__10..WS__15}; (* 0FC00H *)

  LVS_ALIGNTOP        = WS_SET {};               (* 0000H *)
  LVS_ALIGNLEFT       = WS_SET {WS__11};         (* 0800H *)
  LVS_ALIGNMASK       = WS_SET {WS__10, WS__11}; (* 0C00H *)

  LVS_OWNERDRAWFIXED  = WS_SET {WS__10}; (* 0400H *)
  LVS_NOCOLUMNHEADER  = WS_SET {WS__14}; (* 4000H *)
  LVS_NOSORTHEADER    = WS_SET {WS__15}; (* 8000H *)

(* IF _WIN32_IE >= 0x0400 THEN *)
  LVM_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetUnicodeFormat ( hwndLV: HWND; fUnicode: BOOL ): BOOL;

CONST
  LVM_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetUnicodeFormat ( hwndLV: HWND ): BOOL;
(* END *)

CONST
  LVM_GETBKCOLOR = LVM_FIRST+0;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetBkColor ( hwndLV: HWND ): COLORREF;

CONST 
  LVM_SETBKCOLOR = LVM_FIRST+1;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetBkColor ( hwndLV: HWND; clrBk: COLORREF ): BOOL;

TYPE
  LVSIL_ENUM = (
    LVSIL_NORMAL,       (* 0 *)
    LVSIL_SMALL,        (* 1 *)
    LVSIL_STATE         (* 2 *)
  );

CONST 
  LVM_GETIMAGELIST = LVM_FIRST+2;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetImageList ( hwndLV: HWND; iImageList: LVSIL_ENUM ): HIMAGELIST;

CONST
  LVM_SETIMAGELIST = LVM_FIRST+3;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetImageList ( hwndLV: HWND; himl: HIMAGELIST;
                                  iImageList: LVSIL_ENUM ): HIMAGELIST;

CONST 
  LVM_GETITEMCOUNT = LVM_FIRST+4;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetItemCount ( hwndLV: HWND ): INTEGER;

TYPE
  LVIF_ENUM = (
    LVIF__TEXT,         (*  0 *)
    LVIF__IMAGE,        (*  1 *)
    LVIF__PARAM,        (*  2 *)
    LVIF__STATE,        (*  3 *)
    LVIF__INDENT,       (*  4 *)
    LVIF__5, LVIF__6,
    LVIF__7, LVIF__8,
    LVIF__9, LVIF__10,
    LVIF__NORECOMPUTE,  (* 11 *)
    LVIF__DI_SETITEM    (* 12 *)
  );
  LVIF_SET = SET OF LVIF_ENUM;

  LVIS_SET = BIT_SET;

CONST 
  LVIF_TEXT        = LVIF_SET {LVIF__TEXT};        (* 0001H *)
  LVIF_IMAGE       = LVIF_SET {LVIF__IMAGE};       (* 0002H *)
  LVIF_PARAM       = LVIF_SET {LVIF__PARAM};       (* 0004H *)
  LVIF_STATE       = LVIF_SET {LVIF__STATE};       (* 0008H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  LVIF_INDENT      = LVIF_SET {LVIF__INDENT};      (* 0010H *)
  LVIF_NORECOMPUTE = LVIF_SET {LVIF__NORECOMPUTE}; (* 0800H *)
(* END *)
  LVIF_DI_SETITEM = LVIF_SET {LVIF__DI_SETITEM};   (* 1000H *)

  LVIS_FOCUSED        = LVIS_SET {BIT__0}; (* 00001H *)
  LVIS_SELECTED       = LVIS_SET {BIT__1}; (* 00002H *)
  LVIS_CUT            = LVIS_SET {BIT__2}; (* 00004H *)
  LVIS_DROPHILITED    = LVIS_SET {BIT__3}; (* 00008H *)
  LVIS_ACTIVATING     = LVIS_SET {BIT__5}; (* 00020H *)

  LVIS_OVERLAYMASK    = LVIS_SET {BIT__8 .. BIT__11}; (* 00F00H *)
  LVIS_STATEIMAGEMASK = LVIS_SET {BIT__12.. BIT__15}; (* 0F000H *)

(* This procedure corresponds to a macro. *)
PROCEDURE INDEXTOSTATEIMAGEMASK ( i: UINT ): BIT_SET;

(* IF _WIN32_IE >= 0x0300 THEN *)
CONST
  I_INDENTCALLBACK = -1;
(* END *)

TYPE
  LVITEMA = RECORD
    mask      : LVIF_SET;
    iItem     : INTEGER;
    iSubItem  : INTEGER;
    state     : LVIS_SET;
    stateMask : LVIS_SET;
    pszText   : PSTR;
    cchTextMax: INTEGER;
    iImage    : INTEGER;
    lParam    : LPARAM;
(* IF _WIN32_IE >= 0x0300 THEN *)
    iIndent   : INTEGER;
(* END *)
  END;
  PLVITEMA = POINTER TO LVITEMA;

CONST
  LVITEMA_V1_SIZE = SIZE (LVITEMA) - SIZE (INTEGER);

TYPE
  LVITEMW = RECORD
    mask      : LVIF_SET;
    iItem     : INTEGER;
    iSubItem  : INTEGER;
    state     : LVIS_SET;
    stateMask : LVIS_SET;
    pszText   : PWSTR;
    cchTextMax: INTEGER;
    iImage    : INTEGER;
    lParam    : LPARAM;
(* IF _WIN32_IE >= 0x0300 THEN *)
    iIndent   : INTEGER;
(* END *)
  END;
  PLVITEMW = POINTER TO LVITEMW;

CONST
  LVITEMW_V1_SIZE = SIZE (LVITEMW) - SIZE (INTEGER);

<* IF DEFINED (UNICODE) THEN *>
TYPE
  LVITEM  = LVITEMW;
  PLVITEM = PLVITEMW;
CONST
  LVITEM_V1_SIZE = LVITEMW_V1_SIZE;
<* ELSE *>
TYPE
  LVITEM  = LVITEMA;
  PLVITEM = PLVITEMA;
CONST
  LVITEM_V1_SIZE = LVITEMA_V1_SIZE;
<* END *>

TYPE
  LV_ITEM  = LVITEM;
  LV_ITEMA = LVITEMA;
  LV_ITEMW = LVITEMW;

CONST 
  PSTR_TEXTCALLBACKW = SYSTEM.CAST(PWSTR, VAL(LONG, -1));
  PSTR_TEXTCALLBACKA = SYSTEM.CAST(PSTR, VAL(LONG, -1));

  I_IMAGECALLBACK = -1;

  LVM_GETITEMA = LVM_FIRST+5;
  LVM_GETITEMW = LVM_FIRST+75;

<* IF DEFINED (UNICODE) THEN *>
  PSTR_TEXTCALLBACK = PSTR_TEXTCALLBACKW;
  LVM_GETITEM = LVM_GETITEMW;
<* ELSE *>
  PSTR_TEXTCALLBACK = PSTR_TEXTCALLBACKA;
  LVM_GETITEM = LVM_GETITEMA;
<* END *>

(* These procedures correspond to a macro. *)
PROCEDURE ListView_GetItemA ( hwndLV: HWND; VAR item: LVITEMA ): BOOL;
PROCEDURE ListView_GetItemW ( hwndLV: HWND; VAR item: LVITEMW ): BOOL;

CONST
<* IF DEFINED (UNICODE) THEN *>
  ListView_GetItem = ListView_GetItemW;
<* ELSE *>
  ListView_GetItem = ListView_GetItemA;
<* END *>

CONST 
  LVM_SETITEMA = LVM_FIRST+6;
  LVM_SETITEMW = LVM_FIRST+76;
<* IF DEFINED (UNICODE) THEN *>
  LVM_SETITEM = LVM_SETITEMW;
<* ELSE *>
  LVM_SETITEM = LVM_SETITEMA;
<* END *>

(* These procedures correspond to a macro. *)
<* IF BACKEND # "C" THEN *>
PROCEDURE ListView_SetItemA ( hwndLV: HWND; item: LVITEMA (*!*) ): BOOL;
<* ELSE *>
PROCEDURE ListView_SetItemA ( hwndLV: HWND; item: PLVITEMA (*!*) ): BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE ListView_SetItemW ( hwndLV: HWND; item: LVITEMW (*!*) ): BOOL;
<* ELSE *>
PROCEDURE ListView_SetItemW ( hwndLV: HWND; item: PLVITEMW (*!*) ): BOOL;
<* END *>

CONST
<* IF DEFINED (UNICODE) THEN *>
  ListView_SetItem = ListView_SetItemW;
<* ELSE *>
  ListView_SetItem = ListView_SetItemA;
<* END *>

CONST 
  LVM_INSERTITEMA = LVM_FIRST+7;
  LVM_INSERTITEMW = LVM_FIRST+77;
<* IF DEFINED (UNICODE) THEN *>
  LVM_INSERTITEM = LVM_INSERTITEMW;
<* ELSE *>
  LVM_INSERTITEM = LVM_INSERTITEMA;
<* END *>

(* These procedures correspond to a macro. *)
<* IF BACKEND # "C" THEN *>
PROCEDURE ListView_InsertItemA ( hwndLV: HWND; item: LVITEMA (*!*) ): INTEGER;
<* ELSE *>
PROCEDURE ListView_InsertItemA ( hwndLV: HWND; item: PLVITEMA (*!*) ): INTEGER;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE ListView_InsertItemW ( hwndLV: HWND; item: LVITEMW (*!*) ): INTEGER;
<* ELSE *>
PROCEDURE ListView_InsertItemW ( hwndLV: HWND; item: PLVITEMW (*!*) ): INTEGER;
<* END *>

CONST
<* IF DEFINED (UNICODE) THEN *>
  ListView_InsertItem = ListView_InsertItemW;
<* ELSE *>
  ListView_InsertItem = ListView_InsertItemA;
<* END *>

CONST 
  LVM_DELETEITEM = LVM_FIRST+8;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_DeleteItem ( hwndLV: HWND; iItem: INTEGER ): BOOL;

CONST 
  LVM_DELETEALLITEMS = LVM_FIRST+9;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_DeleteAllItems ( hwndLV: HWND ): BOOL;

CONST 
  LVM_GETCALLBACKMASK = LVM_FIRST+10;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetCallbackMask ( hwndLV: HWND ): LVIS_SET;

CONST 
  LVM_SETCALLBACKMASK = LVM_FIRST+11;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetCallbackMask ( hwndLV: HWND; mask: LVIS_SET ): BOOL;

TYPE
  LVNI_ENUM = (
    LVNI__FOCUSED,      (*  0 *)
    LVNI__SELECTED,     (*  1 *)
    LVNI__CUT,          (*  2 *)
    LVNI__DROPHILITED,  (*  3 *)
    LVNI__4, LVNI__5, LVNI__6, LVNI__7,
    LVNI__ABOVE,        (*  8 *)
    LVNI__BELOW,        (*  9 *)
    LVNI__TOLEFT,       (* 10 *)
    LVNI__TORIGHT       (* 11 *)
  );
  LVNI_SET = SET OF LVNI_ENUM;

CONST 
  LVNI_ALL         = LVNI_SET {};                  (* 0000H *)
  LVNI_FOCUSED     = LVNI_SET {LVNI__FOCUSED};     (* 0001H *)
  LVNI_SELECTED    = LVNI_SET {LVNI__SELECTED};    (* 0002H *)
  LVNI_CUT         = LVNI_SET {LVNI__CUT};         (* 0004H *)
  LVNI_DROPHILITED = LVNI_SET {LVNI__DROPHILITED}; (* 0008H *)

  LVNI_ABOVE       = LVNI_SET {LVNI__ABOVE};       (* 0100H *)
  LVNI_BELOW       = LVNI_SET {LVNI__BELOW};       (* 0200H *)
  LVNI_TOLEFT      = LVNI_SET {LVNI__TOLEFT};      (* 0400H *)
  LVNI_TORIGHT     = LVNI_SET {LVNI__TORIGHT};     (* 0800H *)

  LVM_GETNEXTITEM = LVM_FIRST+12;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetNextItem ( hwndLV: HWND; iStart: INTEGER; flags: LVNI_SET ): INTEGER;

TYPE
  LVFI_ENUM = (
    LVFI__PARAM,        (* 0 *)
    LVFI__STRING,       (* 1 *)
    LVFI__2,
    LVFI__PARTIAL,      (* 3 *)
    LVFI__4,
    LVFI__WRAP,         (* 5 *)
    LVFI__NEARESTXY     (* 6 *)
  );
  LVFI_SET = SET OF LVFI_ENUM;

CONST 
  LVFI_PARAM     = LVFI_SET {LVFI__PARAM};     (* 0001H *)
  LVFI_STRING    = LVFI_SET {LVFI__STRING};    (* 0002H *)
  LVFI_PARTIAL   = LVFI_SET {LVFI__PARTIAL};   (* 0008H *)
  LVFI_WRAP      = LVFI_SET {LVFI__WRAP};      (* 0020H *)
  LVFI_NEARESTXY = LVFI_SET {LVFI__NEARESTXY}; (* 0040H *)

TYPE
  LVFINDINFOA = RECORD
    flags      : LVFI_SET;
    psz        : PCSTR;
    lParam     : LPARAM;
    pt         : POINT;
    vkDirection: UINT;
  END;
  PLVFINDINFOA = POINTER TO LVFINDINFOA;

  LVFINDINFOW = RECORD
    flags      : LVFI_SET;
    psz        : PCWSTR;
    lParam     : LPARAM;
    pt         : POINT;
    vkDirection: UINT;
  END;
  PLVFINDINFOW = POINTER TO LVFINDINFOW;

<* IF DEFINED (UNICODE) THEN *>
  LVFINDINFO = LVFINDINFOW;
<* ELSE *>
  LVFINDINFO = LVFINDINFOA;
<* END *>

  LV_FINDINFO  = LVFINDINFO;
  LV_FINDINFOA = LVFINDINFOA;
  LV_FINDINFOW = LVFINDINFOW;

CONST
  LVM_FINDITEMA = LVM_FIRST+13;
  LVM_FINDITEMW = LVM_FIRST+83;
<* IF DEFINED (UNICODE) THEN *>
  LVM_FINDITEM = LVM_FINDITEMW;
<* ELSE *>
  LVM_FINDITEM = LVM_FINDITEMA;
<* END *>

(* These procedures correspond to a macro. *)
<* IF BACKEND # "C" THEN *>
PROCEDURE ListView_FindItemA ( hwndLV: HWND; iStart: INTEGER; lvfi: LVFINDINFOA (*!*) ): INTEGER;
<* ELSE *>
PROCEDURE ListView_FindItemA ( hwndLV: HWND; iStart: INTEGER; lvfi: PLVFINDINFOA (*!*) ): INTEGER;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE ListView_FindItemW ( hwndLV: HWND; iStart: INTEGER; lvfi: LVFINDINFOW (*!*) ): INTEGER;
<* ELSE *>
PROCEDURE ListView_FindItemW ( hwndLV: HWND; iStart: INTEGER; lvfi: PLVFINDINFOW (*!*) ): INTEGER;
<* END *>

CONST
<* IF DEFINED (UNICODE) THEN *>
  ListView_FindItem = ListView_FindItemW;
<* ELSE *>
  ListView_FindItem = ListView_FindItemA;
<* END *>

TYPE
  LVIR_ENUM = (
    LVIR_BOUNDS,        (* 0 *)
    LVIR_ICON,          (* 1 *)
    LVIR_LABEL,         (* 2 *)
    LVIR_SELECTBOUNDS   (* 3 *)
  );

CONST
  LVM_GETITEMRECT = LVM_FIRST+14;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetItemRect ( hwndLV: HWND; iItem: INTEGER; VAR rc: RECT;
                                 code: LVIR_ENUM ): BOOL;

CONST 
  LVM_SETITEMPOSITION = LVM_FIRST+15;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetItemPosition ( hwndLV: HWND; iItem: INTEGER; x, y: INTEGER ): BOOL;

CONST 
  LVM_GETITEMPOSITION = LVM_FIRST+16;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetItemPosition ( hwndLV: HWND; iItem: INTEGER; VAR pt: POINT ): BOOL;

CONST 
  LVM_GETSTRINGWIDTHA = LVM_FIRST+17;
  LVM_GETSTRINGWIDTHW = LVM_FIRST+87;
<* IF DEFINED (UNICODE) THEN *>
  LVM_GETSTRINGWIDTH = LVM_GETSTRINGWIDTHW;
<* ELSE *>
  LVM_GETSTRINGWIDTH = LVM_GETSTRINGWIDTHA;
<* END *>

(* These procedures correspond to a macro. *)
PROCEDURE ListView_GetStringWidthA ( hwndLV: HWND; szText: ARRAY OF CHAR ): INTEGER;
PROCEDURE ListView_GetStringWidthW ( hwndLV: HWND; szText: ARRAY OF WCHAR ): INTEGER;

CONST
<* IF DEFINED (UNICODE) THEN *>
  ListView_GetStringWidth = ListView_GetStringWidthW;
<* ELSE *>
  ListView_GetStringWidth = ListView_GetStringWidthA;
<* END *>

TYPE
  LVHT_ENUM = (
    LVHT__NOWHERE,              (* 0 *)
    LVHT__ONITEMICON,           (* 1 *)
    LVHT__ONITEMLABEL,          (* 2 *)
    LVHT__ONITEMSTATEICON,      (* 3 *)
    LVHT__BELOW,                (* 4 *)
    LVHT__TORIGHT,              (* 5 *)
    LVHT__TOLEFT                (* 6 *)
  );
  LVHT_SET = SET OF LVHT_ENUM;

CONST 
  LVHT_NOWHERE         = LVHT_SET {LVHT__NOWHERE};         (* 0001H *)
  LVHT_ONITEMICON      = LVHT_SET {LVHT__ONITEMICON};      (* 0002H *)
  LVHT_ONITEMLABEL     = LVHT_SET {LVHT__ONITEMLABEL};     (* 0004H *)
  LVHT_ONITEMSTATEICON = LVHT_SET {LVHT__ONITEMSTATEICON}; (* 0008H *)
  LVHT_ONITEM          = LVHT_ONITEMSTATEICON + LVHT_ONITEMLABEL + LVHT_ONITEMICON;

  LVHT_ABOVE           = LVHT_SET {LVHT__ONITEMSTATEICON}; (* 0008H *)
  LVHT_BELOW           = LVHT_SET {LVHT__BELOW};           (* 0010H *)
  LVHT_TORIGHT         = LVHT_SET {LVHT__TORIGHT};         (* 0020H *)
  LVHT_TOLEFT          = LVHT_SET {LVHT__TOLEFT};          (* 0040H *)

TYPE
  LVHITTESTINFO = RECORD
    pt      : POINT;
    flags   : LVHT_SET;
    iItem   : INTEGER;
(* IF _WIN32_IE >= 0x0300 THEN *)
    iSubItem: INTEGER;      (*  this is was NOT in win95.  valid only for LVM_SUBITEMHITTEST *)
(* END *)
  END;
  PLVHITTESTINFO = POINTER TO LVHITTESTINFO;

  LV_HITTESTINFO = LVHITTESTINFO;

CONST
  LVHITTESTINFO_V1_SIZE = SIZE (LVHITTESTINFO) - SIZE (INTEGER);

  LVM_HITTEST = LVM_FIRST+18;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_HitTest ( hwndLV: HWND; VAR info: LVHITTESTINFO ): INTEGER;

CONST 
  LVM_ENSUREVISIBLE = LVM_FIRST+19;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_EnsureVisible ( hwndLV: HWND; iItem: INTEGER; fPartialOK: BOOL ): BOOL;

CONST 
  LVM_SCROLL = LVM_FIRST+20;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_Scroll ( hwndLV: HWND; dx, dy: INTEGER ): BOOL;

CONST 
  LVM_REDRAWITEMS = LVM_FIRST+21;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_RedrawItems ( hwndLV: HWND; iFirst, iLast: INTEGER ): BOOL;

TYPE
  LVA_ENUM = (
    LVA_DEFAULT,        (* 0H *)
    LVA_ALIGNLEFT,      (* 1H *)
    LVA_ALIGNTOP,       (* 2H *)
    LVA_3, LVA_4,
    LVA_SNAPTOGRID      (* 5H *)
  );

CONST
  LVM_ARRANGE = LVM_FIRST+22;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_Arrange ( hwndLV: HWND; code: LVA_ENUM ): BOOL;

CONST 
  LVM_EDITLABELA = LVM_FIRST+23;
  LVM_EDITLABELW = LVM_FIRST+118;
<* IF DEFINED (UNICODE) THEN *>
  LVM_EDITLABEL = LVM_EDITLABELW;
<* ELSE *>
  LVM_EDITLABEL = LVM_EDITLABELA;
<* END *>

(* These procedures correspond to a macro. *)
PROCEDURE ListView_EditLabelA ( hwndLV: HWND; iItem: INTEGER ): HWND;
PROCEDURE ListView_EditLabelW ( hwndLV: HWND; iItem: INTEGER ): HWND;

CONST
<* IF DEFINED (UNICODE) THEN *>
  ListView_EditLabel = ListView_EditLabelW;
<* ELSE *>
  ListView_EditLabel = ListView_EditLabelA;
<* END *>

CONST 
  LVM_GETEDITCONTROL = LVM_FIRST+24;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetEditControl ( hwndLV: HWND ): HWND;

TYPE
  LVCF_ENUM = (
    LVCF__FMT,          (* 0 *)
    LVCF__WIDTH,        (* 1 *)
    LVCF__TEXT,         (* 2 *)
    LVCF__SUBITEM,      (* 3 *)
    LVCF__IMAGE,        (* 4 *)
    LVCF__ORDER         (* 5 *)
  );
  LVCF_SET = SET OF LVCF_ENUM;

  LVCFMT_ENUM = (LVCFMT__0,  LVCFMT__1,  LVCFMT__2,  LVCFMT__3,
                 LVCFMT__4,  LVCFMT__5,  LVCFMT__6,  LVCFMT__7,
                 LVCFMT__8,  LVCFMT__9,  LVCFMT__10, LVCFMT__11,
                 LVCFMT__12, LVCFMT__13, LVCFMT__14, LVCFMT__15);
  LVCFMT_SET = SET OF LVCFMT_ENUM;

CONST
  LVCF_FMT     = LVCF_SET {LVCF__FMT};     (* 0001H *)
  LVCF_WIDTH   = LVCF_SET {LVCF__WIDTH};   (* 0002H *)
  LVCF_TEXT    = LVCF_SET {LVCF__TEXT};    (* 0004H *)
  LVCF_SUBITEM = LVCF_SET {LVCF__SUBITEM}; (* 0008H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  LVCF_IMAGE   = LVCF_SET {LVCF__IMAGE};   (* 0010H *)
  LVCF_ORDER   = LVCF_SET {LVCF__ORDER};   (* 0020H *)
(* END *)

  LVCFMT_LEFT            = LVCFMT_SET {};                     (* 0000H *)
  LVCFMT_RIGHT           = LVCFMT_SET {LVCFMT__0};            (* 0001H *)
  LVCFMT_CENTER          = LVCFMT_SET {LVCFMT__1};            (* 0002H *)
  LVCFMT_JUSTIFYMASK     = LVCFMT_SET {LVCFMT__0, LVCFMT__1}; (* 0003H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  LVCFMT_IMAGE           = LVCFMT_SET {LVCFMT__11};           (* 0800H *)
  LVCFMT_BITMAP_ON_RIGHT = LVCFMT_SET {LVCFMT__12};           (* 1000H *)
  LVCFMT_COL_HAS_IMAGES  = LVCFMT_SET {LVCFMT__15};           (* 8000H *)
(* END *)

TYPE
  LVCOLUMNA = RECORD
    mask      : LVCF_SET;
    fmt       : LVCFMT_SET;
    cx        : INTEGER;
    pszText   : PSTR;
    cchTextMax: INTEGER;
    iSubItem  : INTEGER;
(* IF _WIN32_IE >= 0x0300 THEN *)
    iImage    : INTEGER;
    iOrder    : INTEGER;
(* END *)
  END;
  PLVCOLUMNA = POINTER TO LVCOLUMNA;

CONST
  LVCOLUMNA_V1_SIZE = SIZE (LVCOLUMNA) - SIZE (INTEGER) * 2;

TYPE
  LVCOLUMNW = RECORD
    mask      : LVCF_SET;
    fmt       : LVCFMT_SET;
    cx        : INTEGER;
    pszText   : PWSTR;
    cchTextMax: INTEGER;
    iSubItem  : INTEGER;
(* IF _WIN32_IE >= 0x0300 THEN *)
    iImage    : INTEGER;
    iOrder    : INTEGER;
(* END *)
  END;
  PLVCOLUMNW = POINTER TO LVCOLUMNW;

CONST
  LVCOLUMNW_V1_SIZE = SIZE (LVCOLUMNW) - SIZE (INTEGER) * 2;

<* IF DEFINED (UNICODE) THEN *>
TYPE
  LVCOLUMN  = LVCOLUMNW;
  PLVCOLUMN = PLVCOLUMNW;
CONST
  LVCOLUMN_V1_SIZE = LVCOLUMNW_V1_SIZE;
<* ELSE *>
TYPE
  LVCOLUMN  = LVCOLUMNA;
  PLVCOLUMN = PLVCOLUMNA;
CONST
  LVCOLUMN_V1_SIZE = LVCOLUMNA_V1_SIZE;
<* END *>

TYPE
  LV_COLUMN  = LVCOLUMN;
  LV_COLUMNA = LVCOLUMNA;
  LV_COLUMNW = LVCOLUMNW;

CONST 
  LVM_GETCOLUMNA = LVM_FIRST+25;
  LVM_GETCOLUMNW = LVM_FIRST+95;
<* IF DEFINED (UNICODE) THEN *>
  LVM_GETCOLUMN = LVM_GETCOLUMNW;
<* ELSE *>
  LVM_GETCOLUMN = LVM_GETCOLUMNA;
<* END *>

(* These procedures correspond to a macro. *)
PROCEDURE ListView_GetColumnA ( hwndLV: HWND; iCol: INTEGER; VAR col: LVCOLUMNA ): BOOL;
PROCEDURE ListView_GetColumnW ( hwndLV: HWND; iCol: INTEGER; VAR col: LVCOLUMNW ): BOOL;

CONST
<* IF DEFINED (UNICODE) THEN *>
  ListView_GetColumn = ListView_GetColumnW;
<* ELSE *>
  ListView_GetColumn = ListView_GetColumnA;
<* END *>

CONST 
  LVM_SETCOLUMNA = LVM_FIRST+26;
  LVM_SETCOLUMNW = LVM_FIRST+96;
<* IF DEFINED (UNICODE) THEN *>
  LVM_SETCOLUMN = LVM_SETCOLUMNW;
<* ELSE *>
  LVM_SETCOLUMN = LVM_SETCOLUMNA;
<* END *>

(* This procedure corresponds to a macro. *)
<* IF BACKEND # "C" THEN *>
PROCEDURE ListView_SetColumnA ( hwndLV: HWND; iCol: INTEGER; col: LVCOLUMNA (*!*) ): BOOL;
<* ELSE *>
PROCEDURE ListView_SetColumnA ( hwndLV: HWND; iCol: INTEGER; col: PLVCOLUMNA (*!*) ): BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE ListView_SetColumnW ( hwndLV: HWND; iCol: INTEGER; col: LVCOLUMNW (*!*) ): BOOL;
<* ELSE *>
PROCEDURE ListView_SetColumnW ( hwndLV: HWND; iCol: INTEGER; col: PLVCOLUMNW (*!*) ): BOOL;
<* END *>

CONST
<* IF DEFINED (UNICODE) THEN *>
  ListView_SetColumn = ListView_SetColumnW;
<* ELSE *>
  ListView_SetColumn = ListView_SetColumnA;
<* END *>

CONST 
  LVM_INSERTCOLUMNA = LVM_FIRST+27;
  LVM_INSERTCOLUMNW = LVM_FIRST+97;
<* IF DEFINED (UNICODE) THEN *>
  LVM_INSERTCOLUMN = LVM_INSERTCOLUMNW;
<* ELSE *>
  LVM_INSERTCOLUMN = LVM_INSERTCOLUMNA;
<* END *>

(* This procedure corresponds to a macro. *)
<* IF BACKEND # "C" THEN *>
PROCEDURE ListView_InsertColumnA ( hwndLV: HWND; iCol: INTEGER;
                                   col: LVCOLUMNA (*!*) ): INTEGER;
<* ELSE *>
PROCEDURE ListView_InsertColumnA ( hwndLV: HWND; iCol: INTEGER;
                                   col: PLVCOLUMNA (*!*) ): INTEGER;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE ListView_InsertColumnW ( hwndLV: HWND; iCol: INTEGER;
                                   col: LVCOLUMNW (*!*) ): INTEGER;
<* ELSE *>
PROCEDURE ListView_InsertColumnW ( hwndLV: HWND; iCol: INTEGER;
                                   col: PLVCOLUMNW (*!*) ): INTEGER;
<* END *>

CONST
<* IF DEFINED (UNICODE) THEN *>
  ListView_InsertColumn = ListView_InsertColumnW;
<* ELSE *>
  ListView_InsertColumn = ListView_InsertColumnA;
<* END *>

CONST 
  LVM_DELETECOLUMN = LVM_FIRST+28;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_DeleteColumn ( hwndLV: HWND; iCol: INTEGER ): BOOL;

CONST 
  LVM_GETCOLUMNWIDTH = LVM_FIRST+29;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetColumnWidth ( hwndLV: HWND; iCol: INTEGER ): INTEGER;

CONST 
  LVSCW_AUTOSIZE           = -1;
  LVSCW_AUTOSIZE_USEHEADER = -2;

  LVM_SETCOLUMNWIDTH = LVM_FIRST+30;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetColumnWidth ( hwndLV: HWND; iCol: INTEGER; cx: INTEGER ): BOOL;

(* IF _WIN32_IE >= 0x0300 THEN *)
CONST
  LVM_GETHEADER = LVM_FIRST+31;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetHeader ( hwndLV: HWND ): HWND;
(* END *)

CONST 
  LVM_CREATEDRAGIMAGE = LVM_FIRST+33;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_CreateDragImage ( hwndLV: HWND; iItem: INTEGER;
                                     VAR ptUpLeft: POINT ): HIMAGELIST;

CONST 
  LVM_GETVIEWRECT = LVM_FIRST+34;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetViewRect ( hwndLV: HWND; VAR rc: RECT ): BOOL;

CONST 
  LVM_GETTEXTCOLOR = LVM_FIRST+35;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetTextColor ( hwndLV: HWND ): COLORREF;

CONST 
  LVM_SETTEXTCOLOR = LVM_FIRST+36;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetTextColor ( hwndLV: HWND; clrText: COLORREF ): BOOL;

CONST 
  LVM_GETTEXTBKCOLOR = LVM_FIRST+37;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetTextBkColor ( hwndLV: HWND ): COLORREF;

CONST 
  LVM_SETTEXTBKCOLOR = LVM_FIRST+38;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetTextBkColor ( hwndLV: HWND; clrText: COLORREF ): BOOL;

CONST 
  LVM_GETTOPINDEX = LVM_FIRST+39;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetTopIndex ( hwndLV: HWND ): INTEGER;

CONST 
  LVM_GETCOUNTPERPAGE = LVM_FIRST+40;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetCountPerPage ( hwndLV: HWND ): INTEGER;

CONST 
  LVM_GETORIGIN = LVM_FIRST+41;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetOrigin ( hwndLV: HWND; VAR ptOrg: POINT ): BOOL;

CONST 
  LVM_UPDATE = LVM_FIRST+42;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_Update ( hwndLV: HWND; iItem: INTEGER ): BOOL;

CONST 
  LVM_SETITEMSTATE = LVM_FIRST+43;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetItemState ( hwndLV: HWND; iItem: INTEGER; state, mask: LVIS_SET ): BOOL;

CONST 
  LVM_GETITEMSTATE = LVM_FIRST+44;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetItemState ( hwndLV: HWND; iItem: INTEGER; mask: LVIS_SET ): LVIS_SET;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetCheckState ( hwndLV: HWND; iIndex: UINT ): BOOL;

CONST 
  LVM_GETITEMTEXTA = LVM_FIRST+45;
  LVM_GETITEMTEXTW = LVM_FIRST+115;
<* IF DEFINED (UNICODE) THEN *>
  LVM_GETITEMTEXT = LVM_GETITEMTEXTW;
<* ELSE *>
  LVM_GETITEMTEXT = LVM_GETITEMTEXTA;
<* END *>

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetItemTextA ( hwndLV: HWND; iItem, iSubItem: INTEGER;
                                  VAR szText: ARRAY OF CHAR; cchTextMax: INTEGER );
PROCEDURE ListView_GetItemTextW ( hwndLV: HWND; iItem, iSubItem: INTEGER;
                                  VAR szText: ARRAY OF WCHAR; cchTextMax: INTEGER );

CONST
<* IF DEFINED (UNICODE) THEN *>
  ListView_GetItemText = ListView_GetItemTextW;
<* ELSE *>
  ListView_GetItemText = ListView_GetItemTextA;
<* END *>

CONST 
  LVM_SETITEMTEXTA = LVM_FIRST+46;
  LVM_SETITEMTEXTW = LVM_FIRST+116;
<* IF DEFINED (UNICODE) THEN *>
  LVM_SETITEMTEXT = LVM_SETITEMTEXTW;
<* ELSE *>
  LVM_SETITEMTEXT = LVM_SETITEMTEXTA;
<* END *>

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetItemTextA ( hwndLV: HWND; iItem, iSubItem: INTEGER; szText: PCSTR (* NIL *) ): BOOL;
PROCEDURE ListView_SetItemTextW ( hwndLV: HWND; iItem, iSubItem: INTEGER; szText: PCWSTR (* NIL *) ): BOOL;

CONST
<* IF DEFINED (UNICODE) THEN *>
  ListView_SetItemText = ListView_SetItemTextW;
<* ELSE *>
  ListView_SetItemText = ListView_SetItemTextA;
<* END *>

TYPE
  LVSICF_ENUM = (
    LVSICF__NOINVALIDATEALL,    (* 0 *)
    LVSICF__NOSCROLL            (* 1 *)
  );
  LVSICF_SET = SET OF LVSICF_ENUM;

CONST 
(* IF _WIN32_IE >= 0x0300 THEN *)
(*  these flags only apply to LVS_OWNERDATA listviews in report or list mode *)
  LVSICF_NOINVALIDATEALL = LVSICF_SET {LVSICF__NOINVALIDATEALL}; (* 0001H *)
  LVSICF_NOSCROLL        = LVSICF_SET {LVSICF__NOSCROLL};        (* 0002H *)
(* END *)

  LVM_SETITEMCOUNT = LVM_FIRST+47;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetItemCount ( hwndLV: HWND; cItems: INTEGER ): BOOL;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetItemCountEx ( hwndLV: HWND; cItems: INTEGER; dwFlags: LVSICF_SET ): BOOL;

TYPE
  PFNLVCOMPARE = PROCEDURE [CALLBACK] ( (* lParam1 : *) LPARAM,
                                        (* lParam2 : *) LPARAM,
                                        (* lParamSort : *) LPARAM ): INTEGER;

CONST 
  LVM_SORTITEMS = LVM_FIRST+48;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SortItems ( hwndLV: HWND; pfnCompare: PFNLVCOMPARE;
                               lParamSort: LPARAM ): BOOL;

CONST 
  LVM_SETITEMPOSITION32 = LVM_FIRST+49;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetItemPosition32 ( hwndLV: HWND; iItem: INTEGER; x, y: INTEGER );

CONST 
  LVM_GETSELECTEDCOUNT = LVM_FIRST+50;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetSelectedCount ( hwndLV: HWND ): UINT;

CONST 
  LVM_GETITEMSPACING = LVM_FIRST+51;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetItemSpacing ( hwndLV: HWND; fSmall: BOOL ): DWORD;

CONST 
  LVM_GETISEARCHSTRINGA = LVM_FIRST+52;
  LVM_GETISEARCHSTRINGW = LVM_FIRST+117;
<* IF DEFINED (UNICODE) THEN *>
  LVM_GETISEARCHSTRING = LVM_GETISEARCHSTRINGW;
<* ELSE *>
  LVM_GETISEARCHSTRING = LVM_GETISEARCHSTRINGA;
<* END *>

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetISearchStringA ( hwndLV: HWND; szText: PSTR (* NIL *) ): BOOL;
PROCEDURE ListView_GetISearchStringW ( hwndLV: HWND; szText: PWSTR (* NIL *) ): BOOL;

CONST
<* IF DEFINED (UNICODE) THEN *>
  ListView_GetISearchString = ListView_GetISearchStringW;
<* ELSE *>
  ListView_GetISearchString = ListView_GetISearchStringA;
<* END *>

(* IF _WIN32_IE >= 0x0300 THEN *)
CONST
  LVM_SETICONSPACING = LVM_FIRST+53;

(*  -1 for cx and cy means we'll use the default (system settings) *)
(*  0 for cx or cy means use the current setting (allows you to change just one param) *)

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetIconSpacing ( hwndLV: HWND; cx, cy: INTEGER ): DWORD;

TYPE
  LVS_EX_ENUM = (
    LVS_EX__GRIDLINES,          (*  0 *)
    LVS_EX__SUBITEMIMAGES,      (*  1 *)
    LVS_EX__CHECKBOXES,         (*  2 *)
    LVS_EX__TRACKSELECT,        (*  3 *)
    LVS_EX__HEADERDRAGDROP,     (*  4 *)
    LVS_EX__FULLROWSELECT,      (*  5 *)
    LVS_EX__ONECLICKACTIVATE,   (*  6 *)
    LVS_EX__TWOCLICKACTIVATE,   (*  7 *)
    LVS_EX__FLATSB,             (*  8 *)
    LVS_EX__REGIONAL,           (*  9 *)
    LVS_EX__INFOTIP,            (* 10 *)
    LVS_EX__UNDERLINEHOT,       (* 11 *)
    LVS_EX__UNDERLINECOLD,      (* 12 *)
    LVS_EX__MULTIWORKAREAS      (* 13 *)
  );
  LVS_EX_SET = SET OF LVS_EX_ENUM;

CONST
  LVS_EX_GRIDLINES        = LVS_EX_SET {LVS_EX__GRIDLINES};        (* 0001H *)
  LVS_EX_SUBITEMIMAGES    = LVS_EX_SET {LVS_EX__SUBITEMIMAGES};    (* 0002H *)
  LVS_EX_CHECKBOXES       = LVS_EX_SET {LVS_EX__CHECKBOXES};       (* 0004H *)
  LVS_EX_TRACKSELECT      = LVS_EX_SET {LVS_EX__TRACKSELECT};      (* 0008H *)
  LVS_EX_HEADERDRAGDROP   = LVS_EX_SET {LVS_EX__HEADERDRAGDROP};   (* 0010H *)
  LVS_EX_FULLROWSELECT    = LVS_EX_SET {LVS_EX__FULLROWSELECT};    (* 0020H *)   (*  applies to report mode only *)
  LVS_EX_ONECLICKACTIVATE = LVS_EX_SET {LVS_EX__ONECLICKACTIVATE}; (* 0040H *)
  LVS_EX_TWOCLICKACTIVATE = LVS_EX_SET {LVS_EX__TWOCLICKACTIVATE}; (* 0080H *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  LVS_EX_FLATSB           = LVS_EX_SET {LVS_EX__FLATSB};           (* 0100H *)
  LVS_EX_REGIONAL         = LVS_EX_SET {LVS_EX__REGIONAL};         (* 0200H *)
  LVS_EX_INFOTIP          = LVS_EX_SET {LVS_EX__INFOTIP};          (* 0400H *)   (*  listview does InfoTips for you *)
  LVS_EX_UNDERLINEHOT     = LVS_EX_SET {LVS_EX__UNDERLINEHOT};     (* 0800H *)
  LVS_EX_UNDERLINECOLD    = LVS_EX_SET {LVS_EX__UNDERLINECOLD};    (* 1000H *)
  LVS_EX_MULTIWORKAREAS   = LVS_EX_SET {LVS_EX__MULTIWORKAREAS};   (* 2000H *)
(* END *)

  LVM_SETEXTENDEDLISTVIEWSTYLE = LVM_FIRST+54;   (*  optional wParam == mask *)

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetExtendedListViewStyle ( hwndLV: HWND; dwExStyle: LVS_EX_SET ): LVS_EX_SET;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetExtendedListViewStyleEx ( hwndLV: HWND; dwExMask, dwExStyle: LVS_EX_SET ): LVS_EX_SET;

CONST
  LVM_GETEXTENDEDLISTVIEWSTYLE = LVM_FIRST+55;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetExtendedListViewStyle ( hwndLV: HWND ): LVS_EX_SET;

CONST
  LVM_GETSUBITEMRECT = LVM_FIRST+56;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetSubItemRect ( hwndLV: HWND; iItem, iSubItem: INTEGER;
                                    code: LVIR_ENUM; VAR rc: RECT ): BOOL;

CONST
  LVM_SUBITEMHITTEST = LVM_FIRST+57;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SubItemHitTest ( hwndLV: HWND; VAR Info: LVHITTESTINFO ): INTEGER;

CONST
  LVM_SETCOLUMNORDERARRAY = LVM_FIRST+58;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetColumnOrderArray ( hwndLV: HWND; iCount: INTEGER;
                                         iArray: ARRAY OF INTEGER (*!*) ): BOOL;

CONST
  LVM_GETCOLUMNORDERARRAY = LVM_FIRST+59;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetColumnOrderArray ( hwndLV: HWND; iCount: INTEGER;
                                         VAR iArray: ARRAY OF INTEGER ): BOOL;

CONST
  LVM_SETHOTITEM = LVM_FIRST+60;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetHotItem ( hwndLV: HWND; iIndex: INTEGER ): INTEGER;

CONST
  LVM_GETHOTITEM = LVM_FIRST+61;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetHotItem ( hwndLV: HWND ): INTEGER;

CONST
  LVM_SETHOTCURSOR = LVM_FIRST+62;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetHotCursor ( hwndLV: HWND; hCursor: HCURSOR ): HCURSOR;

CONST
  LVM_GETHOTCURSOR = LVM_FIRST+63;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetHotCursor ( hwndLV: HWND ): HCURSOR;

CONST
  LVM_APPROXIMATEVIEWRECT = LVM_FIRST+64;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_ApproximateViewRect ( hwndLV: HWND; cx, cy: INTEGER;
                                         iCount: INTEGER ): DWORD;

(* IF _WIN32_IE >= 0x0400 THEN *)
CONST
  LV_MAX_WORKAREAS = 16;
  LVM_SETWORKAREAS = LVM_FIRST+65;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetWorkAreas ( hwndLV: HWND; nWorkAreas: INTEGER; prc: PCRECT (* NIL *) );

CONST
  LVM_GETWORKAREAS = LVM_FIRST+70;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetWorkAreas ( hwndLV: HWND; nWorkAreas: INTEGER;
                                  VAR rc: ARRAY OF RECT );

CONST
  LVM_GETNUMBEROFWORKAREAS = LVM_FIRST+73;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetNumberOfWorkAreas ( hwndLV: HWND; VAR WorkAreas: UINT ): BOOL;

CONST
  LVM_GETSELECTIONMARK = LVM_FIRST+66;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetSelectionMark ( hwndLV: HWND ): INTEGER;

CONST
  LVM_SETSELECTIONMARK = LVM_FIRST+67;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetSelectionMark ( hwndLV: HWND; iIndex: INTEGER ): INTEGER;

CONST
  LVM_SETHOVERTIME = LVM_FIRST+71;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetHoverTime ( hwndLV: HWND; dwHoverTime: DWORD ): DWORD;

CONST
  LVM_GETHOVERTIME = LVM_FIRST+72;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetHoverTime ( hwndLV: HWND ): DWORD;

CONST
  LVM_SETTOOLTIPS = LVM_FIRST+74;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_SetToolTips ( hwndLV: HWND; hwndToolTip: HWND ): HWND;

CONST
  LVM_GETTOOLTIPS = LVM_FIRST+78;

(* This procedure corresponds to a macro. *)
PROCEDURE ListView_GetToolTips ( hwndLV: HWND ): HWND;

TYPE
  LVBKIF_ENUM = (
    LVBKIF__SOURCE_HBITMAP,     (* 0 *)
    LVBKIF__SOURCE_URL,         (* 1 *)
    LVBKIF__2,
    LVBKIF__3,
    LVBKIF__STYLE_TILE          (* 4 *)
  );
  LVBKIF_SET = SET OF LVBKIF_ENUM;

CONST
  LVBKIF_SOURCE_NONE    = LVBKIF_SET {};                             (* 0000H *)
  LVBKIF_SOURCE_HBITMAP = LVBKIF_SET {LVBKIF__SOURCE_HBITMAP};       (* 0001H *)
  LVBKIF_SOURCE_URL     = LVBKIF_SET {LVBKIF__SOURCE_URL};           (* 0002H *)
  LVBKIF_SOURCE_MASK    = LVBKIF_SOURCE_HBITMAP + LVBKIF_SOURCE_URL; (* 0003H *)
  LVBKIF_STYLE_NORMAL   = LVBKIF_SET {};                             (* 0000H *)
  LVBKIF_STYLE_TILE     = LVBKIF_SET {LVBKIF__STYLE_TILE};           (* 0010H *)
  LVBKIF_STYLE_MASK     = LVBKIF_STYLE_NORMAL + LVBKIF_STYLE_TILE;   (* 0010H *)

TYPE
  LVBKIMAGEA = RECORD
    ulFlags       : LVBKIF_SET;       (*  LVBKIF_* *)
    hbm           : HBITMAP;
    pszImage      : PSTR;
    cchImageMax   : UINT;
    xOffsetPercent: INTEGER;
    yOffsetPercent: INTEGER;
  END;
  PLVBKIMAGEA = POINTER TO LVBKIMAGEA;

  LVBKIMAGEW = RECORD
    ulFlags       : LVBKIF_SET;       (*  LVBKIF_* *)
    hbm           : HBITMAP;
    pszImage      : PWSTR;
    cchImageMax   : UINT;
    xOffsetPercent: INTEGER;
    yOffsetPercent: INTEGER;
  END;
  PLVBKIMAGEW = POINTER TO LVBKIMAGEW;

<* IF DEFINED (UNICODE) THEN *>
  LVBKIMAGE  = LVBKIMAGEW;
  PLVBKIMAGE = PLVBKIMAGEW;
<* ELSE *>
  LVBKIMAGE  = LVBKIMAGEA;
  PLVBKIMAGE = PLVBKIMAGEA;
<* END *>

CONST
  LVM_SETBKIMAGEA = LVM_FIRST+68;
  LVM_SETBKIMAGEW = LVM_FIRST+138;
  LVM_GETBKIMAGEA = LVM_FIRST+69;
  LVM_GETBKIMAGEW = LVM_FIRST+139;
<* IF DEFINED (UNICODE) THEN *>
  LVM_SETBKIMAGE = LVM_SETBKIMAGEW;
  LVM_GETBKIMAGE = LVM_GETBKIMAGEW;
<* ELSE *>
  LVM_SETBKIMAGE = LVM_SETBKIMAGEA;
  LVM_GETBKIMAGE = LVM_GETBKIMAGEA;
<* END *>

(* Thess procedures correspond to a macro. *)
<* IF BACKEND # "C" THEN *>
PROCEDURE ListView_SetBkImageA ( hwndLV: HWND; lvbki: LVBKIMAGEA (*!*) ): BOOL;
<* ELSE *>
PROCEDURE ListView_SetBkImageA ( hwndLV: HWND; lvbki: PLVBKIMAGEA (*!*) ): BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE ListView_SetBkImageW ( hwndLV: HWND; lvbki: LVBKIMAGEW (*!*) ): BOOL;
<* ELSE *>
PROCEDURE ListView_SetBkImageW ( hwndLV: HWND; lvbki: PLVBKIMAGEW (*!*) ): BOOL;
<* END *>

(* These procedures correspond to a macro. *)
PROCEDURE ListView_GetBkImageA ( hwndLV: HWND; VAR lvbki: LVBKIMAGEA ): BOOL;
PROCEDURE ListView_GetBkImageW ( hwndLV: HWND; VAR lvbki: LVBKIMAGEW ): BOOL;

CONST
<* IF DEFINED (UNICODE) THEN *>
  ListView_SetBkImage = ListView_SetBkImageW;
  ListView_GetBkImage = ListView_GetBkImageW;
<* ELSE *>
  ListView_SetBkImage = ListView_SetBkImageA;
  ListView_GetBkImage = ListView_GetBkImageA;
<* END *>

(* END *)
(* END *)

TYPE
  NMLISTVIEW = RECORD
    hdr      : NMHDR;
    iItem    : INTEGER;
    iSubItem : INTEGER;
    uNewState: LVIS_SET;
    uOldState: LVIS_SET;
    uChanged : LVIF_SET;
    ptAction : POINT;
    lParam   : LPARAM;
  END;
  PNMLISTVIEW = POINTER TO NMLISTVIEW;

  PNM_LISTVIEW = PNMLISTVIEW;
  NM_LISTVIEW  = NMLISTVIEW;

(* IF _WIN32_IE >= 0x0400 THEN *)
(*  NMITEMACTIVATE is used instead of NMLISTVIEW in IE >= 0x400 *)
(*  therefore all the fields are the same except for extra uKeyFlags *)
(*  they are used to store key flags at the time of the single click with *)
(*  delayed activation - because by the time the timer goes off a user may *)
(*  not hold the keys (shift, ctrl) any more *)
(*  key flags stored in uKeyFlags *)
  LVKF_ENUM = (
    LVKF__ALT,          (* 0 *)
    LVKF__CONTROL,      (* 1 *)
    LVKF__SHIFT         (* 2 *)
  );
  LVKF_SET = SET OF LVKF_ENUM;

CONST
  LVKF_ALT     = LVKF_SET {LVKF__ALT};     (* 0001H *)
  LVKF_CONTROL = LVKF_SET {LVKF__CONTROL}; (* 0002H *)
  LVKF_SHIFT   = LVKF_SET {LVKF__SHIFT};   (* 0004H *)

TYPE
  NMITEMACTIVATE = RECORD
    hdr      : NMHDR;
    iItem    : INTEGER;
    iSubItem : INTEGER;
    uNewState: LVIS_SET;
    uOldState: LVIS_SET;
    uChanged : LVIF_SET;
    ptAction : POINT;
    lParam   : LPARAM;
    uKeyFlags: LVKF_SET;
  END;
  PNMITEMACTIVATE = POINTER TO NMITEMACTIVATE;

(* END *)

(* IF _WIN32_IE >= 0x0300 THEN *)
TYPE
  NMLVCUSTOMDRAW = RECORD
    nmcd     : NMCUSTOMDRAW;
    clrText  : COLORREF;
    clrTextBk: COLORREF;
(* IF _WIN32_IE >= 0x0400 THEN *)
    iSubItem : INTEGER;
(* END *)
  END;
  PNMLVCUSTOMDRAW = POINTER TO NMLVCUSTOMDRAW;

CONST
  NMLVCUSTOMDRAW_V3_SIZE = SIZE (NMLVCUSTOMDRAW) - SIZE (INTEGER);

TYPE
  NMLVCACHEHINT = RECORD
    hdr      : NMHDR;
    iFrom    : INTEGER;
    iTo      : INTEGER;
  END;
  PNMLVCACHEHINT = POINTER TO NMLVCACHEHINT;

  PNM_CACHEHINT = PNMLVCACHEHINT;
  NM_CACHEHINT  = NMLVCACHEHINT;

  NMLVFINDITEMA = RECORD
    hdr   : NMHDR;
    iStart: INTEGER;
    lvfi  : LVFINDINFOA;
  END;
  PNMLVFINDITEMA = POINTER TO NMLVFINDITEMA;

  NMLVFINDITEMW = RECORD
    hdr   : NMHDR;
    iStart: INTEGER;
    lvfi  : LVFINDINFOW;
  END;
  PNMLVFINDITEMW = POINTER TO NMLVFINDITEMW;

<* IF DEFINED (UNICODE) THEN *>
  NMLVFINDITEM  = NMLVFINDITEMW;
  PNMLVFINDITEM = PNMLVFINDITEMW;
<* ELSE *>
  NMLVFINDITEM = NMLVFINDITEMA;
  PNMLVFINDITEM = PNMLVFINDITEMA;
<* END *>

  PNM_FINDITEMA = PNMLVFINDITEMA;
  PNM_FINDITEMW = PNMLVFINDITEMW;
  PNM_FINDITEM  = PNMLVFINDITEM;
  NM_FINDITEMA  = NMLVFINDITEMA;
  NM_FINDITEMW  = NMLVFINDITEMW;
  NM_FINDITEM   = NMLVFINDITEM;

  NMLVODSTATECHANGE = RECORD
    hdr      : NMHDR;
    iFrom    : INTEGER;
    iTo      : INTEGER;
    uNewState: UINT;
    uOldState: UINT;
  END;
  PNMLVODSTATECHANGE = POINTER TO NMLVODSTATECHANGE;

  PNM_ODSTATECHANGE  = PNMLVODSTATECHANGE;
  NM_ODSTATECHANGE   = NMLVODSTATECHANGE;

(* END *)

CONST
  LVN_ITEMCHANGING    = LVN_FIRST-0;
  LVN_ITEMCHANGED     = LVN_FIRST-1;
  LVN_INSERTITEM      = LVN_FIRST-2;
  LVN_DELETEITEM      = LVN_FIRST-3;
  LVN_DELETEALLITEMS  = LVN_FIRST-4;
  LVN_BEGINLABELEDITA = LVN_FIRST-5;
  LVN_BEGINLABELEDITW = LVN_FIRST-75;
  LVN_ENDLABELEDITA   = LVN_FIRST-6;
  LVN_ENDLABELEDITW   = LVN_FIRST-76;
  LVN_COLUMNCLICK     = LVN_FIRST-8;
  LVN_BEGINDRAG       = LVN_FIRST-9;
  LVN_BEGINRDRAG      = LVN_FIRST-11;

(* IF _WIN32_IE >= 0x0300 THEN *)
  LVN_ODCACHEHINT     = LVN_FIRST-13;
  LVN_ODFINDITEMA     = LVN_FIRST-52;
  LVN_ODFINDITEMW     = LVN_FIRST-79;

  LVN_ITEMACTIVATE    = LVN_FIRST-14;
  LVN_ODSTATECHANGED  = LVN_FIRST-15;
(* END *)

(* IF _WIN32_IE >= 0x0400 THEN *)
  LVN_HOTTRACK        = LVN_FIRST-21;
(* END *)

  LVN_GETDISPINFOA    = LVN_FIRST-50;
  LVN_GETDISPINFOW    = LVN_FIRST-77;
  LVN_SETDISPINFOA    = LVN_FIRST-51;
  LVN_SETDISPINFOW    = LVN_FIRST-78;

<* IF DEFINED (UNICODE) THEN *>
  LVN_BEGINLABELEDIT  = LVN_BEGINLABELEDITW;
  LVN_ENDLABELEDIT    = LVN_ENDLABELEDITW;
  LVN_ODFINDITEM      = LVN_ODFINDITEMW;
  LVN_GETDISPINFO     = LVN_GETDISPINFOW;
  LVN_SETDISPINFO     = LVN_SETDISPINFOW;
<* ELSE *>
  LVN_BEGINLABELEDIT  = LVN_BEGINLABELEDITA;
  LVN_ENDLABELEDIT    = LVN_ENDLABELEDITA;
  LVN_ODFINDITEM      = LVN_ODFINDITEMA;
  LVN_GETDISPINFO     = LVN_GETDISPINFOA;
  LVN_SETDISPINFO     = LVN_SETDISPINFOA;
<* END *>

TYPE
  NMLVDISPINFOA = RECORD
    hdr : NMHDR;
    item: LVITEMA;
  END;
  PNMLVDISPINFOA = POINTER TO NMLVDISPINFOA;

  NMLVDISPINFOW = RECORD
    hdr : NMHDR;
    item: LVITEMW;
  END;
  PNMLVDISPINFOW = POINTER TO NMLVDISPINFOW;

<* IF DEFINED (UNICODE) THEN *>
  NMLVDISPINFO = NMLVDISPINFOW;
<* ELSE *>
  NMLVDISPINFO = NMLVDISPINFOA;
<* END *>

  LV_DISPINFO  = NMLVDISPINFO;
  LV_DISPINFOA = NMLVDISPINFOA;
  LV_DISPINFOW = NMLVDISPINFOW;

CONST
  LVN_KEYDOWN = LVN_FIRST-55;

TYPE
  NMLVKEYDOWN = RECORD
    hdr  : NMHDR;
    wVKey: WORD;
    flags: KF_SET;
  END;
  PNMLVKEYDOWN = POINTER TO NMLVKEYDOWN;

  LV_KEYDOWN = NMLVKEYDOWN;

(* IF _WIN32_IE >= 0x0300 THEN *)
CONST
  LVN_MARQUEEBEGIN = LVN_FIRST-56;
(* END *)

(* IF _WIN32_IE >= 0x0400 THEN *)
(*  NMLVGETINFOTIPA.dwFlag values *)

CONST
  LVGIT_UNFOLDED = 0001H;

TYPE
  NMLVGETINFOTIPA = RECORD
    hdr       : NMHDR;
    dwFlags   : DWORD;          (* LVGIT_* *)
    pszText   : PSTR;
    cchTextMax: INTEGER;
    iItem     : INTEGER;
    iSubItem  : INTEGER;
    lParam    : LPARAM;
  END;
  PNMLVGETINFOTIPA = POINTER TO NMLVGETINFOTIPA;

  NMLVGETINFOTIPW = RECORD
    hdr       : NMHDR;
    dwFlags   : DWORD;          (* LVGIT_* *)
    pszText   : PWSTR;
    cchTextMax: INTEGER;
    iItem     : INTEGER;
    iSubItem  : INTEGER;
    lParam    : LPARAM;
  END;
  PNMLVGETINFOTIPW = POINTER TO NMLVGETINFOTIPW;

<* IF DEFINED (UNICODE) THEN *>
  NMLVGETINFOTIP  = NMLVGETINFOTIPW;
  PNMLVGETINFOTIP = PNMLVGETINFOTIPW;
<* ELSE *>
  NMLVGETINFOTIP  = NMLVGETINFOTIPA;
  PNMLVGETINFOTIP = PNMLVGETINFOTIPA;
<* END *>

CONST
  LVN_GETINFOTIPA = LVN_FIRST-57;
  LVN_GETINFOTIPW = LVN_FIRST-58;

<* IF DEFINED (UNICODE) THEN *>
  LVN_GETINFOTIP = LVN_GETINFOTIPW;
<* ELSE *>
  LVN_GETINFOTIP = LVN_GETINFOTIPA;
<* END *>
(* END *)

(* ====== TREEVIEW CONTROL ===================================================== *)
CONST
  WC_TREEVIEWW = ARRAY OF WCHAR {ORD('S'),ORD('y'),ORD('s'),ORD('T'),ORD('r'),ORD('e'),ORD('e'),ORD('V'),
                                 ORD('i'),ORD('e'),ORD('w'),ORD('3'),ORD('2'),0};
  WC_TREEVIEWA = 'SysTreeView32';
<* IF DEFINED (UNICODE) THEN *>
  WC_TREEVIEW = WC_TREEVIEWW;
<* ELSE *>
  WC_TREEVIEW = WC_TREEVIEWA;
<* END *>

  TVS_HASBUTTONS      = WS_SET {WS__0};  (* 0001H *)
  TVS_HASLINES        = WS_SET {WS__1};  (* 0002H *)
  TVS_LINESATROOT     = WS_SET {WS__2};  (* 0004H *)
  TVS_EDITLABELS      = WS_SET {WS__3};  (* 0008H *)
  TVS_DISABLEDRAGDROP = WS_SET {WS__4};  (* 0010H *)
  TVS_SHOWSELALWAYS   = WS_SET {WS__5};  (* 0020H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  TVS_RTLREADING      = WS_SET {WS__6};  (* 0040H *)

  TVS_NOTOOLTIPS      = WS_SET {WS__7};  (* 0080H *)
  TVS_CHECKBOXES      = WS_SET {WS__8};  (* 0100H *)
(* END *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  TVS_TRACKSELECT     = WS_SET {WS__9};  (* 0200H *)
  TVS_SINGLEEXPAND    = WS_SET {WS__10}; (* 0400H *)
  TVS_INFOTIP         = WS_SET {WS__11}; (* 0800H *)
  TVS_FULLROWSELECT   = WS_SET {WS__12}; (* 1000H *)
  TVS_NOSCROLL        = WS_SET {WS__13}; (* 2000H *)
  TVS_NONEVENHEIGHT   = WS_SET {WS__14}; (* 4000H *)
(* END *)

TYPE
  HTREEITEM = POINTER TO RECORD END;

  TVIF_ENUM = (
    TVIF__TEXT,                 (*  0 *)
    TVIF__IMAGE,                (*  1 *)
    TVIF__PARAM,                (*  2 *)
    TVIF__STATE,                (*  3 *)
    TVIF__HANDLE,               (*  4 *)
    TVIF__SELECTEDIMAGE,        (*  5 *)
    TVIF__CHILDREN,             (*  6 *)
    TVIF__INTEGRAL,             (*  7 *)
    TVIF__8, TVIF__9, TVIF__10, TVIF__11,
    TVIF__DI_SETITEM            (* 12 *)
  );
  TVIF_SET = SET OF TVIF_ENUM;

  TVIS_SET = BIT_SET;

CONST
  TVIF_TEXT          = TVIF_SET {TVIF__TEXT};            (* 0001H *)
  TVIF_IMAGE         = TVIF_SET {TVIF__IMAGE};           (* 0002H *)
  TVIF_PARAM         = TVIF_SET {TVIF__PARAM};           (* 0004H *)
  TVIF_STATE         = TVIF_SET {TVIF__STATE};           (* 0008H *)
  TVIF_HANDLE        = TVIF_SET {TVIF__HANDLE};          (* 0010H *)
  TVIF_SELECTEDIMAGE = TVIF_SET {TVIF__SELECTEDIMAGE};   (* 0020H *)
  TVIF_CHILDREN      = TVIF_SET {TVIF__CHILDREN};        (* 0040H *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  TVIF_INTEGRAL      = TVIF_SET {TVIF__INTEGRAL};        (* 0080H *)
(* END *)
  TVIF_DI_SETITEM    = TVIF_SET {TVIF__DI_SETITEM};      (* 1000H *)

  TVIS_FOCUSED       = TVIS_SET {BIT__0};       (* 0001H *)
  TVIS_SELECTED      = TVIS_SET {BIT__1};       (* 0002H *)
  TVIS_CUT           = TVIS_SET {BIT__2};       (* 0004H *)
  TVIS_DROPHILITED   = TVIS_SET {BIT__3};       (* 0008H *)
  TVIS_BOLD          = TVIS_SET {BIT__4};       (* 0010H *)
  TVIS_EXPANDED      = TVIS_SET {BIT__5};       (* 0020H *)
  TVIS_EXPANDEDONCE  = TVIS_SET {BIT__6};       (* 0040H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  TVIS_EXPANDPARTIAL = TVIS_SET {BIT__7};       (* 0080H *)
(* END *)

  TVIS_OVERLAYMASK    = TVIS_SET {BIT__8,  BIT__9,  BIT__10, BIT__11}; (* 00F00H *)
  TVIS_STATEIMAGEMASK = TVIS_SET {BIT__12, BIT__13, BIT__14, BIT__15}; (* 0F000H *)
  TVIS_USERMASK       = TVIS_SET {BIT__12, BIT__13, BIT__14, BIT__15}; (* 0F000H *)

  I_CHILDRENCALLBACK = -1;

TYPE
  TVITEMA = RECORD
    mask          : TVIF_SET;
    hItem         : HTREEITEM;
    state         : TVIS_SET;
    stateMask     : TVIS_SET;
    pszText       : PSTR;
    cchTextMax    : INTEGER;
    iImage        : INTEGER;
    iSelectedImage: INTEGER;
    cChildren     : INTEGER;
    lParam        : LPARAM;
  END;
  PTVITEMA = POINTER TO TVITEMA;

  TVITEMW = RECORD
    mask          : TVIF_SET;
    hItem         : HTREEITEM;
    state         : TVIS_SET;
    stateMask     : TVIS_SET;
    pszText       : PWSTR;
    cchTextMax    : INTEGER;
    iImage        : INTEGER;
    iSelectedImage: INTEGER;
    cChildren     : INTEGER;
    lParam        : LPARAM;
  END;
  PTVITEMW = POINTER TO TVITEMW;

(* IF _WIN32_IE >= 0x0400 THEN *)
(*  only used for Get and Set messages.  no notifies *)
  TVITEMEXA = RECORD
    mask          : TVIF_SET;
    hItem         : HTREEITEM;
    state         : TVIS_SET;
    stateMask     : TVIS_SET;
    pszText       : PSTR;
    cchTextMax    : INTEGER;
    iImage        : INTEGER;
    iSelectedImage: INTEGER;
    cChildren     : INTEGER;
    lParam        : LPARAM;
    iIntegral     : INTEGER;
  END;
  PTVITEMEXA = POINTER TO TVITEMEXA;

(*  only used for Get and Set messages.  no notifies *)
  TVITEMEXW = RECORD
    mask          : TVIF_SET;
    hItem         : HTREEITEM;
    state         : TVIS_SET;
    stateMask     : TVIS_SET;
    pszText       : PWSTR;
    cchTextMax    : INTEGER;
    iImage        : INTEGER;
    iSelectedImage: INTEGER;
    cChildren     : INTEGER;
    lParam        : LPARAM;
    iIntegral     : INTEGER;
  END;
  PTVITEMEXW = POINTER TO TVITEMEXW;
(* END *)

<* IF DEFINED (UNICODE) THEN *>
  TVITEMEX   = TVITEMEXW;
  PTVITEMEX  = PTVITEMEXW;
  TVITEM     = TVITEMW;
  PTVITEM    = PTVITEMW;
<* ELSE *>
  TVITEMEX   = TVITEMEXA;
  PTVITEMEX  = PTVITEMEXA;
  TVITEM     = TVITEMA;
  PTVITEM    = PTVITEMA;
<* END *>

  PTV_ITEM  = PTVITEM;
  TV_ITEM   = TVITEM;
  PTV_ITEMW = PTVITEMW;
  PTV_ITEMA = PTVITEMA;
  TV_ITEMW  = TVITEMW;
  TV_ITEMA  = TVITEMA;

CONST
  TVI_ROOT  = SYSTEM.CAST(HTREEITEM, 0FFFF0000H);
  TVI_FIRST = SYSTEM.CAST(HTREEITEM, 0FFFF0001H);
  TVI_LAST  = SYSTEM.CAST(HTREEITEM, 0FFFF0002H);
  TVI_SORT  = SYSTEM.CAST(HTREEITEM, 0FFFF0003H);

TYPE
  TVINSERTSTRUCTA = RECORD
    hParent     : HTREEITEM;
    hInsertAfter: HTREEITEM;
    CASE : INTEGER OF
        0: itemex: TVITEMEXA;
       |1: item  : TVITEMA;
    END;
  END;
  PTVINSERTSTRUCTA = POINTER TO TVINSERTSTRUCTA;

CONST
  TVINSERTSTRUCTA_V1_SIZE = SIZE (TVINSERTSTRUCTA) - SIZE (TVITEMEXA);

TYPE
  TVINSERTSTRUCTW = RECORD
    hParent     : HTREEITEM;
    hInsertAfter: HTREEITEM;
    CASE : INTEGER OF
       0: itemex: TVITEMEXW;
      |1: item  : TVITEMW;
    END;
  END;
  PTVINSERTSTRUCTW = POINTER TO TVINSERTSTRUCTW;

CONST
  TVINSERTSTRUCTW_V1_SIZE = SIZE (TVINSERTSTRUCTW) - SIZE (TVITEMEXW);

<* IF DEFINED (UNICODE) THEN *>
TYPE
  TVINSERTSTRUCT  = TVINSERTSTRUCTW;
  PTVINSERTSTRUCT = PTVINSERTSTRUCTW;
CONST
  TVINSERTSTRUCT_V1_SIZE = TVINSERTSTRUCTW_V1_SIZE;
<* ELSE *>
TYPE
  TVINSERTSTRUCT  = TVINSERTSTRUCTA;
  PTVINSERTSTRUCT = PTVINSERTSTRUCTA;
CONST
  TVINSERTSTRUCT_V1_SIZE = TVINSERTSTRUCTA_V1_SIZE;
<* END *>

TYPE
  TV_INSERTSTRUCT   = TVINSERTSTRUCT;
  PTV_INSERTSTRUCT  = PTVINSERTSTRUCT;
  PTV_INSERTSTRUCTA = PTVINSERTSTRUCTA;
  PTV_INSERTSTRUCTW = PTVINSERTSTRUCTW;
  TV_INSERTSTRUCTA  = TVINSERTSTRUCTA;
  TV_INSERTSTRUCTW  = TVINSERTSTRUCTW;

CONST
  TVM_INSERTITEMA = TV_FIRST+0;
  TVM_INSERTITEMW = TV_FIRST+50;
<* IF DEFINED (UNICODE) THEN *>
  TVM_INSERTITEM = TVM_INSERTITEMW;
<* ELSE *>
  TVM_INSERTITEM = TVM_INSERTITEMA;
<* END *>

(* This procedure corresponds to a macro. *)
<* IF BACKEND # "C" THEN *>
PROCEDURE TreeView_InsertItemA ( hwndTV: HWND; is: TVINSERTSTRUCTA (*!*) ): HTREEITEM;
<* ELSE *>
PROCEDURE TreeView_InsertItemA ( hwndTV: HWND; is: PTVINSERTSTRUCTA (*!*) ): HTREEITEM;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE TreeView_InsertItemW ( hwndTV: HWND; is: TVINSERTSTRUCTW (*!*) ): HTREEITEM;
<* ELSE *>
PROCEDURE TreeView_InsertItemW ( hwndTV: HWND; is: PTVINSERTSTRUCTW (*!*) ): HTREEITEM;
<* END *>

CONST
<* IF DEFINED (UNICODE) THEN *>
  TreeView_InsertItem = TreeView_InsertItemW;
<* ELSE *>
  TreeView_InsertItem = TreeView_InsertItemA;
<* END *>

CONST 
  TVM_DELETEITEM = TV_FIRST+1;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_DeleteItem ( hwndTV: HWND; hitem: HTREEITEM ): BOOL;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_DeleteAllItems ( hwndTV: HWND ): BOOL;

TYPE
  TVE_ENUM = (
    TVE__COLLAPSE,               (*  0 *)
    TVE__EXPAND,                 (*  1 *)
    TVE__2, TVE__3, TVE__4,  TVE__5,  TVE__6,  TVE__7,
    TVE__8, TVE__9, TVE__10, TVE__11, TVE__12, TVE__13,
    TVE__EXPANDPARTIAL,          (* 14 *)
    TVE__COLLAPSERESET           (* 15 *)
  );
  TVE_SET = SET OF TVE_ENUM;

CONST
  TVE_COLLAPSE      = TVE_SET {TVE__COLLAPSE};      (* 0001H *)
  TVE_EXPAND        = TVE_SET {TVE__EXPAND};        (* 0002H *)
  TVE_TOGGLE        = TVE_COLLAPSE + TVE_EXPAND;    (* 0003H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  TVE_EXPANDPARTIAL = TVE_SET {TVE__EXPANDPARTIAL}; (* 4000H *)
(* END *)
  TVE_COLLAPSERESET = TVE_SET {TVE__COLLAPSERESET}; (* 8000H *)

  TVM_EXPAND = TV_FIRST+2;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_Expand ( hwndTV: HWND; hItem: HTREEITEM; flag: TVE_SET ): BOOL;

CONST
  TVM_GETITEMRECT = TV_FIRST+4;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetItemRect ( hwndTV: HWND; hitem: HTREEITEM; VAR rc: RECT;
                                 fItemRect: BOOL ): BOOL;

CONST 
  TVM_GETCOUNT = TV_FIRST+5;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetCount ( hwndTV: HWND ): UINT;

CONST 
  TVM_GETINDENT = TV_FIRST+6;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetIndent ( hwndTV: HWND ): UINT;

CONST 
  TVM_SETINDENT = TV_FIRST+7;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_SetIndent ( hwndTV: HWND; indent: INTEGER ): BOOL;

CONST 
  TVM_GETIMAGELIST = TV_FIRST+8;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetImageList ( hwndTV: HWND; iImage: INTEGER ): HIMAGELIST;

CONST 
  TVSIL_NORMAL = 0;
  TVSIL_STATE  = 2;

  TVM_SETIMAGELIST = TV_FIRST+9;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_SetImageList ( hwndTV: HWND; himl: HIMAGELIST; iImage: INTEGER ): HIMAGELIST;

TYPE
  TVGN_ENUM = (
    TVGN_ROOT,              (* 0H *)
    TVGN_NEXT,              (* 1H *)
    TVGN_PREVIOUS,          (* 2H *)
    TVGN_PARENT,            (* 3H *)
    TVGN_CHILD,             (* 4H *)
    TVGN_FIRSTVISIBLE,      (* 5H *)
    TVGN_NEXTVISIBLE,       (* 6H *)
    TVGN_PREVIOUSVISIBLE,   (* 7H *)
    TVGN_DROPHILITE,        (* 8H *)
    TVGN_CARET,             (* 9H *)
(* IF _WIN32_IE >= 0x0400 THEN *)
    TVGN_LASTVISIBLE        (* 0AH *)
(* END *)
  );

CONST 
  TVM_GETNEXTITEM = TV_FIRST+10;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetNextItem ( hwndTV: HWND; hitem: HTREEITEM;
                                 flag: TVGN_ENUM ): HTREEITEM;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetChild ( hwndTV: HWND; hitem: HTREEITEM ): HTREEITEM;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetNextSibling ( hwndTV: HWND; hitem: HTREEITEM ): HTREEITEM;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetPrevSibling ( hwndTV: HWND; hitem: HTREEITEM ): HTREEITEM;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetParent ( hwndTV: HWND; hitem: HTREEITEM ): HTREEITEM;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetFirstVisible ( hwndTV: HWND ): HTREEITEM;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetNextVisible ( hwndTV: HWND; hitem: HTREEITEM ): HTREEITEM;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetPrevVisible ( hwndTV: HWND; hitem: HTREEITEM ): HTREEITEM;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetSelection ( hwndTV: HWND ): HTREEITEM;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetDropHilight ( hwndTV: HWND ): HTREEITEM;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetRoot ( hwndTV: HWND ): HTREEITEM;

(* IF _WIN32_IE >= 0x0400 THEN *)
(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetLastVisible ( hwndTV: HWND ): HTREEITEM;
(* END *)

CONST 
  TVM_SELECTITEM = TV_FIRST+11;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_Select ( hwndTV: HWND; hitem: HTREEITEM; flag: TVGN_ENUM ): BOOL;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_SelectItem ( hwndTV: HWND; hitem: HTREEITEM ): BOOL;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_SelectDropTarget ( hwndTV: HWND; hitem: HTREEITEM ): BOOL;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_SelectSetFirstVisible ( hwndTV: HWND; hitem: HTREEITEM ): BOOL;

CONST 
  TVM_GETITEMA = TV_FIRST+12;
  TVM_GETITEMW = TV_FIRST+62;
<* IF DEFINED (UNICODE) THEN *>
  TVM_GETITEM = TVM_GETITEMW;
<* ELSE *>
  TVM_GETITEM = TVM_GETITEMA;
<* END *>

(* These procedures correspond to a macro. *)
PROCEDURE TreeView_GetItemA ( hwndTV: HWND; VAR item: TVITEMA ): BOOL;
PROCEDURE TreeView_GetItemW ( hwndTV: HWND; VAR item: TVITEMW ): BOOL;

CONST
<* IF DEFINED (UNICODE) THEN *>
  TreeView_GetItem = TreeView_GetItemW;
<* ELSE *>
  TreeView_GetItem = TreeView_GetItemA;
<* END *>

CONST 
  TVM_SETITEMA = TV_FIRST+13;
  TVM_SETITEMW = TV_FIRST+63;
<* IF DEFINED (UNICODE) THEN *>
  TVM_SETITEM = TVM_SETITEMW;
<* ELSE *>
  TVM_SETITEM = TVM_SETITEMA;
<* END *>

(* These procedures correspond to a macro. *)
<* IF BACKEND # "C" THEN *>
PROCEDURE TreeView_SetItemA ( hwndTV: HWND; item: TVITEMA (*!*) ): BOOL;
<* ELSE *>
PROCEDURE TreeView_SetItemA ( hwndTV: HWND; item: PTVITEMA (*!*) ): BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE TreeView_SetItemW ( hwndTV: HWND; item: TVITEMW (*!*) ): BOOL;
<* ELSE *>
PROCEDURE TreeView_SetItemW ( hwndTV: HWND; item: PTVITEMW (*!*) ): BOOL;
<* END *>

CONST
<* IF DEFINED (UNICODE) THEN *>
  TreeView_SetItem = TreeView_SetItemW;
<* ELSE *>
  TreeView_SetItem = TreeView_SetItemA;
<* END *>

CONST 
  TVM_EDITLABELA = TV_FIRST+14;
  TVM_EDITLABELW = TV_FIRST+65;
<* IF DEFINED (UNICODE) THEN *>
  TVM_EDITLABEL = TVM_EDITLABELW;
<* ELSE *>
  TVM_EDITLABEL = TVM_EDITLABELA;
<* END *>

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_EditLabelW ( hwndTV: HWND; hitem: HTREEITEM ): HWND;
PROCEDURE TreeView_EditLabelA ( hwndTV: HWND; hitem: HTREEITEM ): HWND;

CONST
<* IF DEFINED (UNICODE) THEN *>
  TreeView_EditLabel = TreeView_EditLabelW;
<* ELSE *>
  TreeView_EditLabel = TreeView_EditLabelA;
<* END *>

CONST 
  TVM_GETEDITCONTROL = TV_FIRST+15;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetEditControl ( hwndTV: HWND ): HWND;

CONST 
  TVM_GETVISIBLECOUNT = TV_FIRST+16;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetVisibleCount ( hwndTV: HWND ): UINT;

TYPE
  TVHT_ENUM = (
    TVHT__NOWHERE,              (*  0 *)
    TVHT__ONITEMICON,           (*  1 *)
    TVHT__ONITEMLABEL,          (*  2 *)
    TVHT__ONITEMINDENT,         (*  3 *)
    TVHT__ONITEMBUTTON,         (*  4 *)
    TVHT__ONITEMRIGHT,          (*  5 *)
    TVHT__ONITEMSTATEICON,      (*  6 *)
    TVHT__7,
    TVHT__ABOVE,                (*  8 *)
    TVHT__BELOW,                (*  9 *)
    TVHT__TORIGHT,              (* 10 *)
    TVHT__TOLEFT                (* 11 *)
  );
  TVHT_SET = SET OF TVHT_ENUM;

CONST
  TVHT_NOWHERE         = TVHT_SET {TVHT__NOWHERE};         (* 0001H *)
  TVHT_ONITEMICON      = TVHT_SET {TVHT__ONITEMICON};      (* 0002H *)
  TVHT_ONITEMLABEL     = TVHT_SET {TVHT__ONITEMLABEL};     (* 0004H *)
  TVHT_ONITEMINDENT    = TVHT_SET {TVHT__ONITEMINDENT};    (* 0008H *)
  TVHT_ONITEMBUTTON    = TVHT_SET {TVHT__ONITEMBUTTON};    (* 0010H *)
  TVHT_ONITEMRIGHT     = TVHT_SET {TVHT__ONITEMRIGHT};     (* 0020H *)
  TVHT_ONITEMSTATEICON = TVHT_SET {TVHT__ONITEMSTATEICON}; (* 0040H *)
  TVHT_ONITEM          = TVHT_ONITEMICON + TVHT_ONITEMLABEL + TVHT_ONITEMSTATEICON;

  TVHT_ABOVE           = TVHT_SET {TVHT__ABOVE};           (* 0100H *)
  TVHT_BELOW           = TVHT_SET {TVHT__BELOW};           (* 0200H *)
  TVHT_TORIGHT         = TVHT_SET {TVHT__TORIGHT};         (* 0400H *)
  TVHT_TOLEFT          = TVHT_SET {TVHT__TOLEFT};          (* 0800H *)

TYPE
  TVHITTESTINFO = RECORD
    pt   : POINT;
    flags: TVHT_SET;
    hItem: HTREEITEM;
  END;
  PTVHITTESTINFO = POINTER TO TVHITTESTINFO;

  TV_HITTESTINFO  = TVHITTESTINFO;
  PTV_HITTESTINFO = PTVHITTESTINFO;

CONST
  TVM_HITTEST = TV_FIRST+17;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_HitTest ( hwndTV: HWND; VAR ht: TVHITTESTINFO ): HTREEITEM;

CONST
  TVM_CREATEDRAGIMAGE = TV_FIRST+18;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_CreateDragImage ( hwndTV: HWND; hitem: HTREEITEM ): HIMAGELIST;

CONST 
  TVM_SORTCHILDREN = TV_FIRST+19;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_SortChildren ( hwndTV: HWND; hitem: HTREEITEM;
                                  fRecurse: BOOL ): BOOL;

CONST 
  TVM_ENSUREVISIBLE = TV_FIRST+20;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_EnsureVisible ( hwndTV: HWND; hitem: HTREEITEM ): BOOL;

TYPE
  PFNTVCOMPARE = PROCEDURE [CALLBACK] ( (* lparam1 : *) LPARAM,
                                        (* lparam2 : *) LPARAM,
                                        (* lparam3 : *) LPARAM ): INTEGER;

  TVSORTCB = RECORD
    hParent    : HTREEITEM;
    lpfnCompare: PFNTVCOMPARE;
    lParam     : LPARAM;
  END;
  PTVSORTCB = POINTER TO TVSORTCB;

  PTV_SORTCB = PTVSORTCB;
  TV_SORTCB  = TVSORTCB;

CONST
  TVM_SORTCHILDRENCB = TV_FIRST+21;

(* This procedure corresponds to a macro. *)
<* IF BACKEND # "C" THEN *>
PROCEDURE TreeView_SortChildrenCB ( hwndTV: HWND; sort: TVSORTCB (*!*);
                                    fRecurse: BOOL ): BOOL;
<* ELSE *>
PROCEDURE TreeView_SortChildrenCB ( hwndTV: HWND; sort: PTVSORTCB (*!*);
                                    fRecurse: BOOL ): BOOL;
<* END *>

CONST 
  TVM_ENDEDITLABELNOW = TV_FIRST+22;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_EndEditLabelNow ( hwndTV: HWND; fCancel: BOOL ): BOOL;

CONST 
  TVM_GETISEARCHSTRINGA = TV_FIRST+23;
  TVM_GETISEARCHSTRINGW = TV_FIRST+64;
<* IF DEFINED (UNICODE) THEN *>
  TVM_GETISEARCHSTRING = TVM_GETISEARCHSTRINGW;
<* ELSE *>
  TVM_GETISEARCHSTRING = TVM_GETISEARCHSTRINGA;
<* END *>

(* These procedures correspond to a macro. *)
PROCEDURE TreeView_GetISearchStringA ( hwndTV: HWND; szText: PSTR (* NIL *) ): BOOL;
PROCEDURE TreeView_GetISearchStringW ( hwndTV: HWND; szText: PWSTR (* NIL *) ): BOOL;

CONST
<* IF DEFINED (UNICODE) THEN *>
  TreeView_GetISearchString = TreeView_GetISearchStringW;
<* ELSE *>
  TreeView_GetISearchString = TreeView_GetISearchStringA;
<* END *>

CONST
  TVM_SETTOOLTIPS = TV_FIRST+24;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_SetToolTips ( hwndTV: HWND; hwndTooltip: HWND ): HWND;

CONST
  TVM_GETTOOLTIPS = TV_FIRST+25;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetToolTips ( hwndTV: HWND ): HWND;
(* END *)

(* IF _WIN32_IE >= 0x0400 THEN *)
CONST
  TVM_SETINSERTMARK = TV_FIRST+26;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_SetInsertMark ( hwndTV: HWND; htiInsert: HTREEITEM;
                                   fAfter: BOOL ): BOOL;

CONST
  TVM_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_SetUnicodeFormat ( hwndTV: HWND; fUnicode: BOOL ): BOOL;

CONST
  TVM_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetUnicodeFormat ( hwndTV: HWND ): BOOL;

CONST
  TVM_SETITEMHEIGHT = TV_FIRST+27;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_SetItemHeight ( hwndTV: HWND; cyItem: INTEGER ): INTEGER;

CONST
  TVM_GETITEMHEIGHT = TV_FIRST+28;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetItemHeight ( hwndTV: HWND ): INTEGER;

CONST
  TVM_SETBKCOLOR = TV_FIRST+29;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_SetBkColor ( hwndTV: HWND; clrBk: COLORREF ): COLORREF;

CONST
  TVM_SETTEXTCOLOR = TV_FIRST+30;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_SetTextColor ( hwndTV: HWND; clrText: COLORREF ): COLORREF;

CONST
  TVM_GETBKCOLOR = TV_FIRST+31;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetBkColor ( hwndTV: HWND ): COLORREF;

CONST
  TVM_GETTEXTCOLOR = TV_FIRST+32;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetTextColor ( hwndTV: HWND ): COLORREF;

CONST
  TVM_SETSCROLLTIME = TV_FIRST+33;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_SetScrollTime ( hwndTV: HWND; uMaxScrollTime: UINT ): UINT;

CONST
  TVM_GETSCROLLTIME = TV_FIRST+34;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetScrollTime ( hwndTV: HWND ): UINT;

CONST
  TVM_SETINSERTMARKCOLOR = TV_FIRST+37;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_SetInsertMarkColor ( hwndTV: HWND; clrInsertMark: COLORREF ): COLORREF;

CONST
  TVM_GETINSERTMARKCOLOR = TV_FIRST+38;

(* This procedure corresponds to a macro. *)
PROCEDURE TreeView_GetInsertMarkColor ( hwndTV: HWND ): COLORREF;
(* END *)

TYPE
  NMTREEVIEWA = RECORD
    hdr    : NMHDR;
    action : UINT;
    itemOld: TVITEMA;
    itemNew: TVITEMA;
    ptDrag : POINT;
  END;
  PNMTREEVIEWA = POINTER TO NMTREEVIEWA;

  NMTREEVIEWW = RECORD
    hdr    : NMHDR;
    action : UINT;
    itemOld: TVITEMW;
    itemNew: TVITEMW;
    ptDrag : POINT;
  END;
  PNMTREEVIEWW = POINTER TO NMTREEVIEWW;

<* IF DEFINED (UNICODE) THEN *>
  NMTREEVIEW  = NMTREEVIEWW;
  PNMTREEVIEW = PNMTREEVIEWW;
<* ELSE *>
  NMTREEVIEW  = NMTREEVIEWA;
  PNMTREEVIEW = PNMTREEVIEWA;
<* END *>

  PNM_TREEVIEW  = PNMTREEVIEW;
  NM_TREEVIEW   = NMTREEVIEW;
  PNM_TREEVIEWA = PNMTREEVIEWA;
  PNM_TREEVIEWW = PNMTREEVIEWW;
  NM_TREEVIEWW  = NMTREEVIEWW;
  NM_TREEVIEWA  = NMTREEVIEWA;

CONST 
  TVN_SELCHANGINGA = TVN_FIRST-1;
  TVN_SELCHANGINGW = TVN_FIRST-50;
  TVN_SELCHANGEDA  = TVN_FIRST-2;
  TVN_SELCHANGEDW  = TVN_FIRST-51;

  TVC_UNKNOWN    = 0H;
  TVC_BYMOUSE    = 1H;
  TVC_BYKEYBOARD = 2H;

  TVN_GETDISPINFOA = TVN_FIRST-3;
  TVN_GETDISPINFOW = TVN_FIRST-52;
  TVN_SETDISPINFOA = TVN_FIRST-4;
  TVN_SETDISPINFOW = TVN_FIRST-53;

<* IF DEFINED (UNICODE) THEN *>
  TVN_SELCHANGING = TVN_SELCHANGINGW;
  TVN_SELCHANGED  = TVN_SELCHANGEDW;
  TVN_GETDISPINFO = TVN_GETDISPINFOW;
  TVN_SETDISPINFO = TVN_SETDISPINFOW;
<* ELSE *>
  TVN_SELCHANGING = TVN_SELCHANGINGA;
  TVN_SELCHANGED  = TVN_SELCHANGEDA;
  TVN_GETDISPINFO = TVN_GETDISPINFOA;
  TVN_SETDISPINFO = TVN_SETDISPINFOA;
<* END *>

TYPE
  NMTVDISPINFOA = RECORD
    hdr : NMHDR;
    item: TVITEMA;
  END;
  PNMTVDISPINFOA = POINTER TO NMTVDISPINFOA;

  NMTVDISPINFOW = RECORD
    hdr : NMHDR;
    item: TVITEMW;
  END;
  PNMTVDISPINFOW = POINTER TO NMTVDISPINFOW;

<* IF DEFINED (UNICODE) THEN *>
  NMTVDISPINFO  = NMTVDISPINFOW;
  PNMTVDISPINFO = PNMTVDISPINFOW;
<* ELSE *>
  NMTVDISPINFO  = NMTVDISPINFOA;
  PNMTVDISPINFO = PNMTVDISPINFOA;
<* END *>

  TV_DISPINFOA = NMTVDISPINFOA;
  TV_DISPINFOW = NMTVDISPINFOW;

CONST
  TVN_ITEMEXPANDINGA  = TVN_FIRST-5;
  TVN_ITEMEXPANDINGW  = TVN_FIRST-54;
  TVN_ITEMEXPANDEDA   = TVN_FIRST-6;
  TVN_ITEMEXPANDEDW   = TVN_FIRST-55;

  TVN_BEGINDRAGA      = TVN_FIRST-7;
  TVN_BEGINDRAGW      = TVN_FIRST-56;
  TVN_BEGINRDRAGA     = TVN_FIRST-8;
  TVN_BEGINRDRAGW     = TVN_FIRST-57;

  TVN_DELETEITEMA     = TVN_FIRST-9;
  TVN_DELETEITEMW     = TVN_FIRST-58;

  TVN_BEGINLABELEDITA = TVN_FIRST-10;
  TVN_BEGINLABELEDITW = TVN_FIRST-59;
  TVN_ENDLABELEDITA   = TVN_FIRST-11;
  TVN_ENDLABELEDITW   = TVN_FIRST-60;

  TVN_KEYDOWN         = TVN_FIRST-12;

(* IF _WIN32_IE >= 0x0400 THEN *)
  TVN_GETINFOTIPA     = TVN_FIRST-13;
  TVN_GETINFOTIPW     = TVN_FIRST-14;
  TVN_SINGLEEXPAND    = TVN_FIRST-15;
(* END *)

<* IF DEFINED (UNICODE) THEN *>
  TVN_ITEMEXPANDING   = TVN_ITEMEXPANDINGW;
  TVN_ITEMEXPANDED    = TVN_ITEMEXPANDEDW;
  TVN_BEGINDRAG       = TVN_BEGINDRAGW;
  TVN_BEGINRDRAG      = TVN_BEGINRDRAGW;
  TVN_DELETEITEM      = TVN_DELETEITEMW;
  TVN_BEGINLABELEDIT  = TVN_BEGINLABELEDITW;
  TVN_ENDLABELEDIT    = TVN_ENDLABELEDITW;
  TVN_GETINFOTIP      = TVN_GETINFOTIPW;
<* ELSE *>
  TVN_ITEMEXPANDING   = TVN_ITEMEXPANDINGA;
  TVN_ITEMEXPANDED    = TVN_ITEMEXPANDEDA;
  TVN_BEGINDRAG       = TVN_BEGINDRAGA;
  TVN_BEGINRDRAG      = TVN_BEGINRDRAGA;
  TVN_DELETEITEM      = TVN_DELETEITEMA;
  TVN_BEGINLABELEDIT  = TVN_BEGINLABELEDITA;
  TVN_ENDLABELEDIT    = TVN_ENDLABELEDITA;
  TVN_GETINFOTIP      = TVN_GETINFOTIPA;
<* END *>

TYPE
  NMTVKEYDOWN = RECORD
    hdr  : NMHDR;
    wVKey: WORD;
    flags: KF_SET;
  END;
  PNMTVKEYDOWN = POINTER TO NMTVKEYDOWN;

  TV_KEYDOWN = NMTVKEYDOWN;

(* IF _WIN32_IE >= 0x0300 THEN *)
  NMTVCUSTOMDRAW = RECORD
    nmcd     : NMCUSTOMDRAW;
    clrText  : COLORREF;
    clrTextBk: COLORREF;
(* IF _WIN32_IE >= 0x0400 THEN *)
    iSubItem : INTEGER;
(* END *)
  END;
  PNMTVCUSTOMDRAW = POINTER TO NMTVCUSTOMDRAW;

CONST
  NMTVCUSTOMDRAW_V3_SIZE = SIZE (NMTVCUSTOMDRAW) - SIZE (INTEGER);

(* END *)

(* IF _WIN32_IE >= 0x0400 THEN *)
(*  for tooltips *)

TYPE
  NMTVGETINFOTIPA = RECORD
    hdr       : NMHDR;
    pszText   : PSTR;
    cchTextMax: INTEGER;
    hItem     : HTREEITEM;
    lParam    : LPARAM;
  END;
  PNMTVGETINFOTIPA = POINTER TO NMTVGETINFOTIPA;

  NMTVGETINFOTIPW = RECORD
    hdr       : NMHDR;
    pszText   : PWSTR;
    cchTextMax: INTEGER;
    hItem     : HTREEITEM;
    lParam    : LPARAM;
  END;
  PNMTVGETINFOTIPW = POINTER TO NMTVGETINFOTIPW;

<* IF DEFINED (UNICODE) THEN *>
  NMTVGETINFOTIP  = NMTVGETINFOTIPW;
  PNMTVGETINFOTIP = PNMTVGETINFOTIPW;
<* ELSE *>
  NMTVGETINFOTIP  = NMTVGETINFOTIPA;
  PNMTVGETINFOTIP = PNMTVGETINFOTIPA;
<* END *>

(*  treeview's customdraw return meaning don't draw images.  valid on CDRF_NOTIFYITEMPREPAINT *)
CONST
  TVCDRF_NOIMAGES = 10000H;
(* END *)

(* IF _WIN32_IE >= 0x0300 THEN *)
(* //////////////////  ComboBoxEx //////////////////////////////// *)
CONST
  WC_COMBOBOXEXW = ARRAY OF WCHAR {ORD('C'),ORD('o'),ORD('m'),ORD('b'),ORD('o'),ORD('B'),ORD('o'),ORD('x'),
                                   ORD('E'),ORD('x'),ORD('3'),ORD('2'),0};
  WC_COMBOBOXEXA = 'ComboBoxEx32';
<* IF DEFINED (UNICODE) THEN *>
  WC_COMBOBOXEX = WC_COMBOBOXEXW;
<* ELSE *>
  WC_COMBOBOXEX = WC_COMBOBOXEXA;
<* END *>

TYPE
  CBEIF_ENUM = [0 .. 28];
  CBEIF_SET = SET OF CBEIF_ENUM;

CONST
  CBEIF__TEXT          = 0;
  CBEIF__IMAGE         = 1;
  CBEIF__SELECTEDIMAGE = 2;
  CBEIF__OVERLAY       = 3;
  CBEIF__INDENT        = 4;
  CBEIF__LPARAM        = 5;
  CBEIF__DI_SETITEM    = 28;

CONST
  CBEIF_TEXT          = CBEIF_SET {CBEIF__TEXT};          (* 00000001H *)
  CBEIF_IMAGE         = CBEIF_SET {CBEIF__IMAGE};         (* 00000002H *)
  CBEIF_SELECTEDIMAGE = CBEIF_SET {CBEIF__SELECTEDIMAGE}; (* 00000004H *)
  CBEIF_OVERLAY       = CBEIF_SET {CBEIF__OVERLAY};       (* 00000008H *)
  CBEIF_INDENT        = CBEIF_SET {CBEIF__INDENT};        (* 00000010H *)
  CBEIF_LPARAM        = CBEIF_SET {CBEIF__LPARAM};        (* 00000020H *)

  CBEIF_DI_SETITEM    = CBEIF_SET {CBEIF__DI_SETITEM};    (* 10000000H *)

TYPE
  COMBOBOXEXITEMA = RECORD
    mask          : CBEIF_SET;
    iItem         : INTEGER;
    pszText       : PSTR;
    cchTextMax    : INTEGER;
    iImage        : INTEGER;
    iSelectedImage: INTEGER;
    iOverlay      : INTEGER;
    iIndent       : INTEGER;
    lParam        : LPARAM;
  END;
  PCOMBOBOXEXITEMA = POINTER TO COMBOBOXEXITEMA;
  PCCOMBOEXITEMA   = PCOMBOBOXEXITEMA;

  COMBOBOXEXITEMW = RECORD
    mask          : CBEIF_SET;
    iItem         : INTEGER;
    pszText       : PWSTR;
    cchTextMax    : INTEGER;
    iImage        : INTEGER;
    iSelectedImage: INTEGER;
    iOverlay      : INTEGER;
    iIndent       : INTEGER;
    lParam        : LPARAM;
  END;
  PCOMBOBOXEXITEMW = POINTER TO COMBOBOXEXITEMW;
  PCCOMBOEXITEMW   = PCOMBOBOXEXITEMW;

<* IF DEFINED (UNICODE) THEN *>
  COMBOBOXEXITEM   = COMBOBOXEXITEMW;
  PCOMBOBOXEXITEM  = PCOMBOBOXEXITEMW;
<* ELSE *>
  COMBOBOXEXITEM   = COMBOBOXEXITEMA;
  PCOMBOBOXEXITEM  = PCOMBOBOXEXITEMA;
<* END *>

CONST
  CBEM_INSERTITEMA      = WM_USER+1;
  CBEM_SETIMAGELIST     = WM_USER+2;
  CBEM_GETIMAGELIST     = WM_USER+3;
  CBEM_GETITEMA         = WM_USER+4;
  CBEM_SETITEMA         = WM_USER+5;
  CBEM_DELETEITEM       = CB_DELETESTRING;
  CBEM_GETCOMBOCONTROL  = WM_USER+6;
  CBEM_GETEDITCONTROL   = WM_USER+7;
(* IF _WIN32_IE >= 0x0400 THEN *)
  CBEM_SETEXSTYLE       = WM_USER+8;   (*  use SETEXTENDEDSTYLE instead *)
  CBEM_SETEXTENDEDSTYLE = WM_USER+14;   (*  lparam == new style, wParam (optional) == mask *)
  CBEM_GETEXSTYLE       = WM_USER+9;   (*  use GETEXTENDEDSTYLE instead *)
  CBEM_GETEXTENDEDSTYLE = WM_USER+9;
  CBEM_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT;
  CBEM_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT;
(* END *)
  CBEM_HASEDITCHANGED   = WM_USER+10;
  CBEM_INSERTITEMW      = WM_USER+11;
  CBEM_SETITEMW         = WM_USER+12;
  CBEM_GETITEMW         = WM_USER+13;

<* IF DEFINED (UNICODE) THEN *>
  CBEM_INSERTITEM       = CBEM_INSERTITEMW;
  CBEM_GETITEM          = CBEM_GETITEMW;
  CBEM_SETITEM          = CBEM_SETITEMW;
<* ELSE *>
  CBEM_INSERTITEM       = CBEM_INSERTITEMA;
  CBEM_GETITEM          = CBEM_GETITEMA;
  CBEM_SETITEM          = CBEM_SETITEMA;
<* END *>

TYPE
  CBES_EX_ENUM = (
    CBES_EX__NOEDITIMAGE,       (* 0 *)
    CBES_EX__NOEDITIMAGEINDENT, (* 1 *)
    CBES_EX__PATHWORDBREAKPROC, (* 2 *)
    CBES_EX__NOSIZELIMIT,       (* 3 *)
    CBES_EX__CASESENSITIVE      (* 4 *)
  );
  CBES_EX_SET = SET OF CBES_EX_ENUM;

CONST
  CBES_EX_NOEDITIMAGE       = CBES_EX_SET {CBES_EX__NOEDITIMAGE};       (* 0001H *)
  CBES_EX_NOEDITIMAGEINDENT = CBES_EX_SET {CBES_EX__NOEDITIMAGEINDENT}; (* 0002H *)
  CBES_EX_PATHWORDBREAKPROC = CBES_EX_SET {CBES_EX__PATHWORDBREAKPROC}; (* 0004H *)

(* IF _WIN32_IE >= 0x0400 THEN *)
  CBES_EX_NOSIZELIMIT       = CBES_EX_SET {CBES_EX__NOSIZELIMIT};       (* 0008H *)
  CBES_EX_CASESENSITIVE     = CBES_EX_SET {CBES_EX__CASESENSITIVE};     (* 0010H *)

TYPE
  NMCOMBOBOXEXA = RECORD
    hdr   : NMHDR;
    ceItem: COMBOBOXEXITEMA;
  END;
  PNMCOMBOBOXEXA = POINTER TO NMCOMBOBOXEXA;

  NMCOMBOBOXEXW = RECORD
    hdr   : NMHDR;
    ceItem: COMBOBOXEXITEMW;
  END;
  PNMCOMBOBOXEXW = POINTER TO NMCOMBOBOXEXW;

<* IF DEFINED (UNICODE) THEN *>
  NMCOMBOBOXEX  = NMCOMBOBOXEXW;
  PNMCOMBOBOXEX = PNMCOMBOBOXEXW;
<* ELSE *>
  NMCOMBOBOXEX  = NMCOMBOBOXEXA;
  PNMCOMBOBOXEX = PNMCOMBOBOXEXA;
<* END *>
(* END *)

CONST
  CBEN_GETDISPINFOA = CBEN_FIRST-0;
  CBEN_GETDISPINFOW = CBEN_FIRST-7;
  CBEN_INSERTITEM   = CBEN_FIRST-1;
  CBEN_DELETEITEM   = CBEN_FIRST-2;
  CBEN_BEGINEDIT    = CBEN_FIRST-4;
  CBEN_ENDEDITA     = CBEN_FIRST-5;
  CBEN_ENDEDITW     = CBEN_FIRST-6;

  CBEN_DRAGBEGINA   = CBEN_FIRST-8;
  CBEN_DRAGBEGINW   = CBEN_FIRST-9;

<* IF DEFINED (UNICODE) THEN *>
  CBEN_ENDEDIT      = CBEN_ENDEDITW;
(* IF _WIN32_IE >= 0x0400 THEN *)
  CBEN_GETDISPINFO  = CBEN_GETDISPINFOW;
  CBEN_DRAGBEGIN    = CBEN_DRAGBEGINW;
(* END *)
<* ELSE *>
  CBEN_ENDEDIT      = CBEN_ENDEDITA;
(* IF _WIN32_IE >= 0x0400 THEN *)
  CBEN_GETDISPINFO  = CBEN_GETDISPINFOA;
  CBEN_DRAGBEGIN    = CBEN_DRAGBEGINA;
(* END *)
<* END *>

(*  lParam specifies why the endedit is happening *)
TYPE
  CBENF_ENUM = (
    CBENF_0,
    CBENF_KILLFOCUS,    (* 1 *)
    CBENF_RETURN,       (* 2 *)
    CBENF_ESCAPE,       (* 3 *)
    CBENF_DROPDOWN      (* 4 *)
  );

CONST
  CBEMAXSTRLEN = 260;

(* IF _WIN32_IE >= 0x0400 THEN *)
(* CBEN_DRAGBEGIN sends this information ... *)
TYPE
  NMCBEDRAGBEGINW = RECORD
    hdr    : NMHDR;
    iItemid: INTEGER;
    szText : ARRAY [0..CBEMAXSTRLEN-1] OF WCHAR;
  END;
  PNMCBEDRAGBEGINW = POINTER TO NMCBEDRAGBEGINW;

  NMCBEDRAGBEGINA = RECORD
    hdr    : NMHDR;
    iItemid: INTEGER;
    szText : ARRAY [0..CBEMAXSTRLEN-1] OF CHAR;
  END;
  PNMCBEDRAGBEGINA = POINTER TO NMCBEDRAGBEGINA;

<* IF DEFINED (UNICODE) THEN *>
  NMCBEDRAGBEGIN  = NMCBEDRAGBEGINW;
  PNMCBEDRAGBEGIN = PNMCBEDRAGBEGINW;
<* ELSE *>
  NMCBEDRAGBEGIN  = NMCBEDRAGBEGINA;
  PNMCBEDRAGBEGIN = PNMCBEDRAGBEGINA;
<* END *>
(* END *)

(*  CBEN_ENDEDIT sends this information... *)
(*  fChanged if the user actually did anything *)
(*  iNewSelection gives what would be the new selection unless the notify is failed *)
(*                       iNewSelection may be CB_ERR if there's no match *)
  NMCBEENDEDITW = RECORD
    hdr          : NMHDR;
    fChanged     : BOOL;
    iNewSelection: INTEGER;
    szText       : ARRAY [0..CBEMAXSTRLEN-1] OF WCHAR;
    iWhy         : CBENF_ENUM;
  END;
  PNMCBEENDEDITW = POINTER TO NMCBEENDEDITW;

  NMCBEENDEDITA = RECORD
    hdr          : NMHDR;
    fChanged     : BOOL;
    iNewSelection: INTEGER;
    szText       : ARRAY [0..CBEMAXSTRLEN-1] OF CHAR;
    iWhy         : CBENF_ENUM;
  END;
  PNMCBEENDEDITA = POINTER TO NMCBEENDEDITA;

<* IF DEFINED (UNICODE) THEN *>
  NMCBEENDEDIT  = NMCBEENDEDITW;
  PNMCBEENDEDIT = PNMCBEENDEDITW;
<* ELSE *>
  NMCBEENDEDIT  = NMCBEENDEDITA;
  PNMCBEENDEDIT = PNMCBEENDEDITA;
<* END *>
(* END *)

(* ====== TAB CONTROL ========================================================== *)
CONST
  WC_TABCONTROLW = ARRAY OF WCHAR {ORD('S'),ORD('y'),ORD('s'),ORD('T'),ORD('a'),ORD('b'),ORD('C'),ORD('o'),
                                   ORD('n'),ORD('t'),ORD('r'),ORD('o'),ORD('l'),ORD('3'),ORD('2'),0};
  WC_TABCONTROLA = 'SysTabControl32';
<* IF DEFINED (UNICODE) THEN *>
  WC_TABCONTROL = WC_TABCONTROLW;
<* ELSE *>
  WC_TABCONTROL = WC_TABCONTROLA;
<* END *>

TYPE
  TCS_EX_ENUM = (
    TCS_EX__FLATSEPARATORS,     (* 0 *)
    TCS_EX__REGISTERDROP        (* 1 *)
  );
  TCS_EX_SET = SET OF TCS_EX_ENUM;

CONST
(* IF _WIN32_IE >= 0x0300 THEN *)
  TCS_SCROLLOPPOSITE    = WS_SET {WS__0};  (* 0001H *)   (*  assumes multiline tab *)
  TCS_BOTTOM            = WS_SET {WS__1};  (* 0002H *)
  TCS_RIGHT             = WS_SET {WS__1};  (* 0002H *)
  TCS_MULTISELECT       = WS_SET {WS__2};  (* 0004H *)   (*  allow multi-select in button mode *)
(* END *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  TCS_FLATBUTTONS       = WS_SET {WS__3};  (* 0008H *)
(* END *)
  TCS_FORCEICONLEFT     = WS_SET {WS__4};  (* 0010H *)
  TCS_FORCELABELLEFT    = WS_SET {WS__5};  (* 0020H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  TCS_HOTTRACK          = WS_SET {WS__6};  (* 0040H *)
  TCS_VERTICAL          = WS_SET {WS__7};  (* 0080H *)
(* END *)
  TCS_TABS              = WS_SET {};       (* 0000H *)
  TCS_BUTTONS           = WS_SET {WS__8};  (* 0100H *)
  TCS_SINGLELINE        = WS_SET {};       (* 0000H *)
  TCS_MULTILINE         = WS_SET {WS__9};  (* 0200H *)
  TCS_RIGHTJUSTIFY      = WS_SET {};       (* 0000H *)
  TCS_FIXEDWIDTH        = WS_SET {WS__10}; (* 0400H *)
  TCS_RAGGEDRIGHT       = WS_SET {WS__11}; (* 0800H *)
  TCS_FOCUSONBUTTONDOWN = WS_SET {WS__12}; (* 1000H *)
  TCS_OWNERDRAWFIXED    = WS_SET {WS__13}; (* 2000H *)
  TCS_TOOLTIPS          = WS_SET {WS__14}; (* 4000H *)
  TCS_FOCUSNEVER        = WS_SET {WS__15}; (* 8000H *)

(* IF _WIN32_IE >= 0x0400 THEN *)
(*  EX styles for use with TCM_SETEXTENDEDSTYLE *)
  TCS_EX_FLATSEPARATORS = TCS_EX_SET {TCS_EX__FLATSEPARATORS}; (* 0001H *)
  TCS_EX_REGISTERDROP   = TCS_EX_SET {TCS_EX__REGISTERDROP};   (* 0002H *)
(* END *)

  TCM_GETIMAGELIST = TCM_FIRST+2;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_GetImageList ( hwndTab: HWND ): HIMAGELIST;

CONST 
  TCM_SETIMAGELIST = TCM_FIRST+3;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_SetImageList ( hwndTab: HWND; himl: HIMAGELIST ): HIMAGELIST;

CONST 
  TCM_GETITEMCOUNT = TCM_FIRST+4;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_GetItemCount ( hwndTab: HWND ): INTEGER;

TYPE
  TCIF_ENUM = (
    TCIF__TEXT,         (* 0 *)
    TCIF__IMAGE,        (* 1 *)
    TCIF__RTLREADING,   (* 2 *)
    TCIF__PARAM,        (* 3 *)
    TCIF__STATE         (* 4 *)
  );
  TCIF_SET = SET OF TCIF_ENUM;

  TCIS_ENUM = (
    TCIS__BUTTONPRESSED,        (* 0 *)
    TCIS__HIGHLIGHTED           (* 1 *)
  );
  TCIS_SET = SET OF TCIS_ENUM;

CONST 
  TCIF_TEXT       = TCIF_SET {TCIF__TEXT};       (* 0001H *)
  TCIF_IMAGE      = TCIF_SET {TCIF__IMAGE};      (* 0002H *)
  TCIF_RTLREADING = TCIF_SET {TCIF__RTLREADING}; (* 0004H *)
  TCIF_PARAM      = TCIF_SET {TCIF__PARAM};      (* 0008H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  TCIF_STATE      = TCIF_SET {TCIF__STATE};      (* 0010H *)

  TCIS_BUTTONPRESSED = TCIS_SET {TCIS__BUTTONPRESSED}; (* 0001H *)
(* END *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  TCIS_HIGHLIGHTED   = TCIS_SET {TCIS__HIGHLIGHTED};   (* 0002H *)
(* END *)

TYPE
  TCITEMHEADERA = RECORD
    mask       : TCIF_SET;
    lpReserved1: UINT;
    lpReserved2: UINT;
    pszText    : PSTR;
    cchTextMax : INTEGER;
    iImage     : INTEGER;
  END;
  PTCITEMHEADERA = POINTER TO TCITEMHEADERA;

  TCITEMHEADERW = RECORD
    mask       : TCIF_SET;
    lpReserved1: UINT;
    lpReserved2: UINT;
    pszText    : PWSTR;
    cchTextMax : INTEGER;
    iImage     : INTEGER;
  END;
  PTCITEMHEADERW = POINTER TO TCITEMHEADERW;

<* IF DEFINED (UNICODE) THEN *>
  TCITEMHEADER  = TCITEMHEADERW;
  PTCITEMHEADER = PTCITEMHEADERW;
<* ELSE *>
  TCITEMHEADER  = TCITEMHEADERA;
  PTCITEMHEADER = PTCITEMHEADERA;
<* END *>

  TC_ITEMHEADER  = TCITEMHEADER;
  TC_ITEMHEADERA = TCITEMHEADERA;
  TC_ITEMHEADERW = TCITEMHEADERW;

  TCITEMA = RECORD
    mask       : TCIF_SET;
    dwState    : TCIS_SET;
    dwStateMask: TCIS_SET;
    pszText    : PSTR;
    cchTextMax : INTEGER;
    iImage     : INTEGER;
    lParam     : LPARAM;
  END;
  PTCITEMA = POINTER TO TCITEMA;

  TCITEMW = RECORD
    mask       : TCIF_SET;
    dwState    : TCIS_SET;
    dwStateMask: TCIS_SET;
    pszText    : PWSTR;
    cchTextMax : INTEGER;
    iImage     : INTEGER;
    lParam     : LPARAM;
  END;
  PTCITEMW = POINTER TO TCITEMW;

<* IF DEFINED (UNICODE) THEN *>
  TCITEM  = TCITEMW;
  PTCITEM = PTCITEMW;
<* ELSE *>
  TCITEM  = TCITEMA;
  PTCITEM = PTCITEMA;
<* END *>

  TC_ITEM  = TCITEM;
  TC_ITEMA = TCITEMA;
  TC_ITEMW = TCITEMW;

CONST
  TCM_GETITEMA = TCM_FIRST+5;
  TCM_GETITEMW = TCM_FIRST+60;
<* IF DEFINED (UNICODE) THEN *>
  TCM_GETITEM = TCM_GETITEMW;
<* ELSE *>
  TCM_GETITEM = TCM_GETITEMA;
<* END *>

(* Thess procedures correspond to a macro. *)
PROCEDURE TabCtrl_GetItemA ( hwndTab: HWND; iItem: INTEGER; VAR item: TCITEMA ): BOOL;
PROCEDURE TabCtrl_GetItemw ( hwndTab: HWND; iItem: INTEGER; VAR item: TCITEMW ): BOOL;

CONST
<* IF DEFINED (UNICODE) THEN *>
  TabCtrl_GetItem = TabCtrl_GetItemW;
<* ELSE *>
  TabCtrl_GetItem = TabCtrl_GetItemA;
<* END *>

CONST 
  TCM_SETITEMA = TCM_FIRST+6;
  TCM_SETITEMW = TCM_FIRST+61;
<* IF DEFINED (UNICODE) THEN *>
  TCM_SETITEM = TCM_SETITEMW;
<* ELSE *>
  TCM_SETITEM = TCM_SETITEMA;
<* END *>

(* These procedures correspond to a macro. *)
<* IF BACKEND # "C" THEN *>
PROCEDURE TabCtrl_SetItemA ( hwndTab: HWND; iItem: INTEGER; item: TCITEMA (*!*) ): BOOL;
<* ELSE *>
PROCEDURE TabCtrl_SetItemA ( hwndTab: HWND; iItem: INTEGER; item: PTCITEMA (*!*) ): BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE TabCtrl_SetItemW ( hwndTab: HWND; iItem: INTEGER; item: TCITEMA (*!*) ): BOOL;
<* ELSE *>
PROCEDURE TabCtrl_SetItemW ( hwndTab: HWND; iItem: INTEGER; item: PTCITEMA (*!*) ): BOOL;
<* END *>

CONST
<* IF DEFINED (UNICODE) THEN *>
  TabCtrl_SetItem = TabCtrl_SetItemW;
<* ELSE *>
  TabCtrl_SetItem = TabCtrl_SetItemA;
<* END *>

CONST 
  TCM_INSERTITEMA = TCM_FIRST+7;
  TCM_INSERTITEMW = TCM_FIRST+62;
<* IF DEFINED (UNICODE) THEN *>
  TCM_INSERTITEM = TCM_INSERTITEMW;
<* ELSE *>
  TCM_INSERTITEM = TCM_INSERTITEMA;
<* END *>

(* These procedures correspond to a macro. *)
<* IF BACKEND # "C" THEN *>
PROCEDURE TabCtrl_InsertItemA ( hwndTab: HWND; iItem: INTEGER; item: TCITEMA (*!*) ): INTEGER;
<* ELSE *>
PROCEDURE TabCtrl_InsertItemA ( hwndTab: HWND; iItem: INTEGER; item: PTCITEMA (*!*) ): INTEGER;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE TabCtrl_InsertItemW ( hwndTab: HWND; iItem: INTEGER; item: TCITEMW (*!*) ): INTEGER;
<* ELSE *>
PROCEDURE TabCtrl_InsertItemW ( hwndTab: HWND; iItem: INTEGER; item: PTCITEMW (*!*) ): INTEGER;
<* END *>

CONST
<* IF DEFINED (UNICODE) THEN *>
  TabCtrl_InsertItem = TabCtrl_InsertItemW;
<* ELSE *>
  TabCtrl_InsertItem = TabCtrl_InsertItemA;
<* END *>

CONST 
  TCM_DELETEITEM = TCM_FIRST+8;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_DeleteItem ( hwndTab: HWND; iItem: INTEGER ): BOOL;

CONST 
  TCM_DELETEALLITEMS = TCM_FIRST+9;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_DeleteAllItems ( hwndTab: HWND ): BOOL;

CONST 
  TCM_GETITEMRECT = TCM_FIRST+10;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_GetItemRect ( hwndTab: HWND; iItem: INTEGER; VAR rc: RECT ): BOOL;

CONST 
  TCM_GETCURSEL = TCM_FIRST+11;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_GetCurSel ( hwndTab: HWND ): INTEGER;

CONST 
  TCM_SETCURSEL = TCM_FIRST+12;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_SetCurSel ( hwndTab: HWND; iItem: INTEGER ): INTEGER;

TYPE
  TCHT_ENUM = (
    TCHT__NOWHERE,      (* 0 *)
    TCHT__ONITEMICON,   (* 1 *)
    TCHT__ONITEMLABEL   (* 2 *)
  );
  TCHT_SET = SET OF TCHT_ENUM;

CONST 
  TCHT_NOWHERE     = TCHT_SET {TCHT__NOWHERE};     (* 0001H *)
  TCHT_ONITEMICON  = TCHT_SET {TCHT__ONITEMICON};  (* 0002H *)
  TCHT_ONITEMLABEL = TCHT_SET {TCHT__ONITEMLABEL}; (* 0004H *)
  TCHT_ONITEM      = TCHT_ONITEMICON + TCHT_ONITEMLABEL;

TYPE
  TCHITTESTINFO = RECORD
    pt   : POINT;
    flags: TCHT_SET;
  END;
  PTCHITTESTINFO = POINTER TO TCHITTESTINFO;

  PTC_HITTESTINFO = PTCHITTESTINFO;
  TC_HITTESTINFO  = TCHITTESTINFO;

CONST
  TCM_HITTEST = TCM_FIRST+13;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_HitTest ( hwndTab: HWND; VAR info: TCHITTESTINFO ): INTEGER;

CONST 
  TCM_SETITEMEXTRA = TCM_FIRST+14;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_SetItemExtra ( hwndTab: HWND; cb: INTEGER ): BOOL;

CONST 
  TCM_ADJUSTRECT = TCM_FIRST+40;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_AdjustRect ( hwndTab: HWND; fLarger: BOOL; VAR rc: RECT );

CONST 
  TCM_SETITEMSIZE = TCM_FIRST+41;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_SetItemSize ( hwndTab: HWND; cx, cy: INTEGER ): DWORD;

CONST 
  TCM_REMOVEIMAGE = TCM_FIRST+42;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_RemoveImage ( hwndTab: HWND; iImage: INTEGER );

CONST 
  TCM_SETPADDING = TCM_FIRST+43;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_SetPadding ( hwndTab: HWND; cx, cy: INTEGER );

CONST 
  TCM_GETROWCOUNT = TCM_FIRST+44;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_GetRowCount ( hwndTab: HWND ): INTEGER;

CONST 
  TCM_GETTOOLTIPS = TCM_FIRST+45;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_GetToolTips ( hwndTab: HWND ): HWND;

CONST 
  TCM_SETTOOLTIPS = TCM_FIRST+46;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_SetToolTips ( hwndTab: HWND; hwndTT: HWND );

CONST 
  TCM_GETCURFOCUS = TCM_FIRST+47;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_GetCurFocus ( hwndTab: HWND ): INTEGER;

CONST 
  TCM_SETCURFOCUS = TCM_FIRST+48;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_SetCurFocus ( hwndTab: HWND; iItem: INTEGER );

(* IF _WIN32_IE >= 0x0300 THEN *)
CONST
  TCM_SETMINTABWIDTH = TCM_FIRST+49;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_SetMinTabWidth ( hwndTab: HWND; cx: INTEGER ): INTEGER;

CONST
  TCM_DESELECTALL = TCM_FIRST+50;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_DeselectAll ( hwndTab: HWND; fExcludeFocus: BOOL );
(* END *)

(* IF _WIN32_IE >= 0x0400 THEN *)
CONST
  TCM_HIGHLIGHTITEM = TCM_FIRST+51;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_HighlightItem ( hwndTab: HWND; iItem: INTEGER; fHighlight: BOOL ): BOOL;

CONST
  TCM_SETEXTENDEDSTYLE = TCM_FIRST+52;   (*  optional wParam == mask *)

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_SetExtendedStyle ( hwndTab: HWND; dwExStyle: TCS_EX_SET ): TCS_EX_SET;

CONST
  TCM_GETEXTENDEDSTYLE = TCM_FIRST+53;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_GetExtendedStyle ( hwndTab: HWND ): TCS_EX_SET;

CONST
    TCM_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_SetUnicodeFormat ( hwndTab: HWND; fUnicode: BOOL ): BOOL;

CONST
    TCM_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT;

(* This procedure corresponds to a macro. *)
PROCEDURE TabCtrl_GetUnicodeFormat ( hwndTab: HWND ): BOOL;
(* END *)

CONST 
  TCN_KEYDOWN = TCN_FIRST-0;

TYPE
  NMTCKEYDOWN = RECORD
    hdr  : NMHDR;
    wVKey: WORD;
    flags: KF_SET;
  END;
  PNMTCKEYDOWN = POINTER TO NMTCKEYDOWN;

  TC_KEYDOWN = NMTCKEYDOWN;

CONST
  TCN_SELCHANGE   = TCN_FIRST-1;
  TCN_SELCHANGING = TCN_FIRST-2;
(* IF _WIN32_IE >= 0x0400 THEN *)
  TCN_GETOBJECT   = TCN_FIRST-3;
(* END *)

(* ====== ANIMATE CONTROL ====================================================== *)
  ANIMATE_CLASSW = ARRAY OF WCHAR {ORD('S'),ORD('y'),ORD('s'),ORD('A'),ORD('n'),ORD('i'),ORD('m'),ORD('a'),
                                   ORD('t'),ORD('e'),ORD('3'),ORD('2'),0};
  ANIMATE_CLASSA = 'SysAnimate32';
<* IF DEFINED (UNICODE) THEN *>
  ANIMATE_CLASS = ANIMATE_CLASSW;
<* ELSE *>
  ANIMATE_CLASS = ANIMATE_CLASSA;
<* END *>

  ACS_CENTER      = WS_SET {WS__0}; (* 0001H *)
  ACS_TRANSPARENT = WS_SET {WS__1}; (* 0002H *)
  ACS_AUTOPLAY    = WS_SET {WS__2}; (* 0004H *)
(* IF _WIN32_IE >= 0x0300 THEN *)
  ACS_TIMER       = WS_SET {WS__3}; (* 0008H *)  (*  don't use threads... use timers *)
(* END *)

  ACM_OPENA = WM_USER+100;
  ACM_OPENW = WM_USER+103;
<* IF DEFINED (UNICODE) THEN *>
  ACM_OPEN  = ACM_OPENW;
<* ELSE *>
  ACM_OPEN  = ACM_OPENA;
<* END *>

  ACM_PLAY = WM_USER+101;
  ACM_STOP = WM_USER+102;

  ACN_START = 1;
  ACN_STOP  = 2;

(* This procedure corresponds to a macro. *)
PROCEDURE Animate_Create ( hwnd: HWND; id: UINT; dwStyle: WS_SET;
                           hInstance: HINSTANCE ): HWND;

(* These procedures correspond to a macro. *)
PROCEDURE Animate_OpenA ( hwnd: HWND; szName: PSTR (* NIL *) ): BOOL;
PROCEDURE Animate_OpenW ( hwnd: HWND; szName: PWSTR (* NIL *) ): BOOL;

CONST
<* IF DEFINED (UNICODE) THEN *>
  Animate_Open = Animate_OpenW;
<* ELSE *>
  Animate_Open = Animate_OpenA;
<* END *>

(* These procedures correspond to a macro. *)
PROCEDURE Animate_OpenExA ( hwnd: HWND; hinst: HINSTANCE; szName: PSTR (* NIL *) ): BOOL;
PROCEDURE Animate_OpenExW ( hwnd: HWND; hinst: HINSTANCE; szName: PWSTR (* NIL *) ): BOOL;

CONST
<* IF DEFINED (UNICODE) THEN *>
  Animate_OpenEx = Animate_OpenExW;
<* ELSE *>
  Animate_OpenEx = Animate_OpenExA;
<* END *>

(* This procedure corresponds to a macro. *)
PROCEDURE Animate_Play ( hwnd: HWND; wFrom, wTo, cRepeat: UINT ): BOOL;

(* This procedure corresponds to a macro. *)
PROCEDURE Animate_Stop ( hwnd: HWND ): BOOL;

(* This procedure corresponds to a macro. *)
PROCEDURE Animate_Close ( hwnd: HWND ): BOOL;

(* This procedure corresponds to a macro. *)
PROCEDURE Animate_Seek ( hwnd: HWND; wFrame: UINT ): BOOL;

(* IF _WIN32_IE >= 0x0300 THEN *)
(* ====== MONTHCAL CONTROL ====================================================== *)
CONST
  MONTHCAL_CLASSW = ARRAY OF WCHAR {ORD('S'),ORD('y'),ORD('s'),ORD('M'),ORD('o'),ORD('n'),ORD('t'),ORD('h'),
                                    ORD('C'),ORD('a'),ORD('l'),ORD('3'),ORD('2'),0};
  MONTHCAL_CLASSA = 'SysMonthCal32';
<* IF DEFINED (UNICODE) THEN *>
  MONTHCAL_CLASS = MONTHCAL_CLASSW;
<* ELSE *>
  MONTHCAL_CLASS = MONTHCAL_CLASSA;
<* END *>

(*  bit-packed array of "bold" info for a month *)
(*  if a bit is on, that day is drawn bold *)
TYPE
  MONTHDAYSTATE = DWORD;
  PMONTHDAYSTATE = POINTER TO MONTHDAYSTATE;

CONST
  MCM_FIRST = 1000H;

(*  BOOL MonthCal_GetCurSel(HWND hmc, PSYSTEMTIME pst) *)
(*    returns FALSE if MCS_MULTISELECT *)
(*    returns TRUE and sets *pst to the currently selected date otherwise *)
CONST
  MCM_GETCURSEL = MCM_FIRST+1;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_GetCurSel ( hwndMC: HWND; VAR SysTime: SYSTEMTIME ): BOOL;

(*  BOOL MonthCal_SetCurSel(HWND hmc, PSYSTEMTIME pst) *)
(*    returns FALSE if MCS_MULTISELECT *)
(*    returns TURE and sets the currently selected date to *pst otherwise *)
CONST
  MCM_SETCURSEL = MCM_FIRST+2;

(* This procedure corresponds to a macro. *)
<* IF BACKEND # "C" THEN *>
PROCEDURE MonthCal_SetCurSel ( hwndMC: HWND; SysTime: SYSTEMTIME (*!*) ): BOOL;
<* ELSE *>
PROCEDURE MonthCal_SetCurSel ( hwndMC: HWND; SysTime: PSYSTEMTIME (*!*) ): BOOL;
<* END *>

(*  DWORD MonthCal_GetMaxSelCount(HWND hmc) *)
(*    returns the maximum number of selectable days allowed *)
CONST
  MCM_GETMAXSELCOUNT = MCM_FIRST+3;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_GetMaxSelCount ( hwndMC: HWND ): DWORD;

(*  BOOL MonthCal_SetMaxSelCount(HWND hmc, UINT n) *)
(*    sets the max number days that can be selected iff MCS_MULTISELECT *)
CONST
  MCM_SETMAXSELCOUNT = MCM_FIRST+4;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_SetMaxSelCount ( hwndMC: HWND; iMax: UINT ): BOOL;

(*  BOOL MonthCal_GetSelRange(HWND hmc, PSYSTEMTIME rgst) *)
(*    sets rgst[0] to the first day of the selection range *)
(*    sets rgst[1] to the last day of the selection range *)
CONST
  MCM_GETSELRANGE = MCM_FIRST+5;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_GetSelRange ( hwndMC: HWND; VAR rgSysTimeArray: ARRAY OF SYSTEMTIME ): BOOL;

(*  BOOL MonthCal_SetSelRange(HWND hmc, PSYSTEMTIME rgst) *)
(*    selects the range of days from rgst[0] to rgst[1] *)
CONST
  MCM_SETSELRANGE = MCM_FIRST+6;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_SetSelRange ( hwndMC: HWND; rgSysTimeArray: ARRAY OF SYSTEMTIME (*!*) ): BOOL;

TYPE
  GMR_ENUM = (
    GMR_VISIBLE,  (* 0 *)   (*  visible portion of display *)
    GMR_DAYSTATE  (* 1 *)   (*  above plus the grayed out parts of *)
                            (*  partially displayed months *)
  );

(*  DWORD MonthCal_GetMonthRange(HWND hmc, DWORD gmr, PSYSTEMTIME rgst) *)
(*    if rgst specified, sets rgst[0] to the starting date and *)
(*       and rgst[1] to the ending date of the the selectable (non-grayed) *)
(*       days if GMR_VISIBLE or all the displayed days (including grayed) *)
(*       if GMR_DAYSTATE. *)
(*    returns the number of months spanned by the above range. *)
CONST
  MCM_GETMONTHRANGE = MCM_FIRST+7;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_GetMonthRange ( hwndMC: HWND; dwFlag: GMR_ENUM;
                                   VAR [NIL] rgSysTimeArray: ARRAY OF SYSTEMTIME ): DWORD;

(*  BOOL MonthCal_SetDayState(HWND hmc, int cbds, DAYSTATE *rgds) *)
(*    cbds is the count of DAYSTATE items in rgds and it must be equal *)
(*    to the value returned from MonthCal_GetMonthRange(hmc, GMR_DAYSTATE, NULL) *)
(*    This sets the DAYSTATE bits for each month (grayed and non-grayed *)
(*    days) displayed in the calendar. The first bit in a month's DAYSTATE *)
(*    corresponts to bolding day 1, the second bit affects day 2, etc. *)
CONST
  MCM_SETDAYSTATE = MCM_FIRST+8;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_SetDayState ( hwndMC: HWND; iMonths: INTEGER;
                                 DayStateArray: ARRAY OF MONTHDAYSTATE (*!*) ): BOOL;

(*  BOOL MonthCal_GetMinReqRect(HWND hmc, PRECT prc) *)
(*    sets *prc the minimal size needed to display one month *)
(*    To display two months, undo the AdjustWindowRect calculation already done to *)
(*    this rect, double the width, and redo the AdjustWindowRect calculation -- *)
(*    the monthcal control will display two calendars in this window (if you also *)
(*    double the vertical size, you will get 4 calendars) *)
(*    NOTE: if you want to gurantee that the "Today" string is not clipped, *)
(*    get the MCM_GETMAXTODAYWIDTH and use the max of that width and this width *)
CONST
  MCM_GETMINREQRECT = MCM_FIRST+9;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_GetMinReqRect ( hwndMC: HWND; VAR RectInfo: RECT ): BOOL;

TYPE
  MCSC_ENUM = (
    MCSC_BACKGROUND,    (* 0 *)  (*  the background color (between months) *)
    MCSC_TEXT,          (* 1 *)  (*  the dates *)
    MCSC_TITLEBK,       (* 2 *)  (*  background of the title *)
    MCSC_TITLETEXT,     (* 3 *)
    MCSC_MONTHBK,       (* 4 *)  (*  background within the month cal *)
    MCSC_TRAILINGTEXT   (* 5 *)  (*  the text color of header & trailing days *)
  );

(*  set colors to draw control with -- see MCSC_ bits below *)
CONST
  MCM_SETCOLOR = MCM_FIRST+10;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_SetColor ( hwndMC: HWND; iColor: MCSC_ENUM; clr: COLORREF ): COLORREF;

CONST
  MCM_GETCOLOR = MCM_FIRST+11;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_GetColor ( hwndMC: HWND; iColor: MCSC_ENUM ): COLORREF;

(*  set what day is "today"   send NULL to revert back to real date *)
CONST
  MCM_SETTODAY = MCM_FIRST+12;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_SetToday ( hwndMC: HWND; pSysTime: PSYSTEMTIME (* NIL *) );

(*  get what day is "today" *)
(*  returns BOOL for success/failure *)
CONST
  MCM_GETTODAY = MCM_FIRST+13;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_GetToday ( hwndMC: HWND; VAR Today: SYSTEMTIME ): BOOL;

TYPE
  MCHT_ENUM = [0 .. 28];
  MCHT_SET  = SET OF MCHT_ENUM;

CONST
  MCHT__0    = 0;
  MCHT__1    = 1;
  MCHT__16   = 16;
  MCHT__17   = 17;
  MCHT__NEXT = 24;
  MCHT__PREV = 25;

CONST
  MCHT_TITLE            = MCHT_SET {MCHT__16};           (* 0010000H *)
  MCHT_CALENDAR         = MCHT_SET {MCHT__17};           (* 0020000H *)
  MCHT_TODAYLINK        = MCHT_SET {MCHT__16, MCHT__17}; (* 0030000H *)

  MCHT_NEXT             = MCHT_SET {MCHT__NEXT}; (* 1000000H *)   (*  these indicate that hitting *)
  MCHT_PREV             = MCHT_SET {MCHT__PREV}; (* 2000000H *)   (*  here will go to the next/prev month *)

  MCHT_NOWHERE          = MCHT_SET {};         (* 0000000H *)

  MCHT_TITLEBK          = MCHT_TITLE;
  MCHT_TITLEMONTH       = MCHT_TITLE + MCHT_SET {MCHT__0}                      (* 0001H *);
  MCHT_TITLEYEAR        = MCHT_TITLE + MCHT_SET {MCHT__1}                      (* 0002H *);
  MCHT_TITLEBTNNEXT     = MCHT_TITLE + MCHT_NEXT + MCHT_SET {MCHT__0, MCHT__1} (* 0003H *);
  MCHT_TITLEBTNPREV     = MCHT_TITLE + MCHT_PREV + MCHT_SET {MCHT__0, MCHT__1} (* 0003H *);

  MCHT_CALENDARBK       = MCHT_CALENDAR;
  MCHT_CALENDARDATE     = MCHT_CALENDAR + MCHT_SET {MCHT__0} (* 0001H *);
  MCHT_CALENDARDATENEXT = MCHT_CALENDARDATE + MCHT_NEXT;
  MCHT_CALENDARDATEPREV = MCHT_CALENDARDATE + MCHT_PREV;
  MCHT_CALENDARDAY      = MCHT_CALENDAR + MCHT_SET {MCHT__1} (* 0002H *);
  MCHT_CALENDARWEEKNUM  = MCHT_CALENDAR + MCHT_SET {MCHT__0, MCHT__1} (* 0003H *);

TYPE
  MCHITTESTINFO = RECORD
    cbSize: UINT;
    pt    : POINT;
    uHit  : MCHT_SET;           (*  out param *)
    st    : SYSTEMTIME;
  END;
  PMCHITTESTINFO = POINTER TO MCHITTESTINFO;

(*  determine what pinfo->pt is over *)
CONST
  MCM_HITTEST = MCM_FIRST+14;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_HitTest ( hwndMC: HWND; VAR MCHitTest: MCHITTESTINFO ): DWORD;

CONST
(*  set first day of week to iDay: *)
(*  0 for Monday, 1 for Tuesday, ..., 6 for Sunday *)
(*  -1 for means use locale info *)
  MCM_SETFIRSTDAYOFWEEK = MCM_FIRST+15;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_SetFirstDayOfWeek ( hwndMC: HWND; iDay: INTEGER ): DWORD;

(*  DWORD result...  low word has the day.  high word is bool if this is app set *)
(*  or not (FALSE == using locale info) *)
CONST
  MCM_GETFIRSTDAYOFWEEK = MCM_FIRST+16;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_GetFirstDayOfWeek ( hwndMC: HWND ): DWORD;

TYPE
  GDTR_ENUM = (
    GDTR__MIN,          (* 0 *)
    GDTR__MAX           (* 1 *)
  );
  GDTR_SET = SET OF GDTR_ENUM;

CONST
  GDTR_MIN = GDTR_SET {GDTR__MIN}; (* 1H *)
  GDTR_MAX = GDTR_SET {GDTR__MAX}; (* 2H *)

(*  DWORD MonthCal_GetRange(HWND hmc, PSYSTEMTIME rgst) *)
(*    modifies rgst[0] to be the minimum ALLOWABLE systemtime (or 0 if no minimum) *)
(*    modifies rgst[1] to be the maximum ALLOWABLE systemtime (or 0 if no maximum) *)
(*    returns GDTR_MIN|GDTR_MAX if there is a minimum|maximum limit *)
CONST
  MCM_GETRANGE = MCM_FIRST+17;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_GetRange ( hwndMC: HWND; VAR rgSysTimeArray: ARRAY OF SYSTEMTIME ): GDTR_SET;

(*  BOOL MonthCal_SetRange(HWND hmc, DWORD gdtr, PSYSTEMTIME rgst) *)
(*    if GDTR_MIN, sets the minimum ALLOWABLE systemtime to rgst[0], otherwise removes minimum *)
(*    if GDTR_MAX, sets the maximum ALLOWABLE systemtime to rgst[1], otherwise removes maximum *)
(*    returns TRUE on success, FALSE on error (such as invalid parameters) *)
CONST
  MCM_SETRANGE = MCM_FIRST+18;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_SetRange ( hwndMC: HWND; fWhichLimit: GDTR_SET;
                              rgSysTimeArray: ARRAY OF SYSTEMTIME (*!*) ): BOOL;

(*  int MonthCal_GetMonthDelta(HWND hmc) *)
(*    returns the number of months one click on a next/prev button moves by *)
CONST
  MCM_GETMONTHDELTA = MCM_FIRST+19;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_GetMonthDelta ( hwndMC: HWND ): INTEGER;

(*  int MonthCal_SetMonthDelta(HWND hmc, int n) *)
(*    sets the month delta to n. n==0 reverts to moving by a page of months *)
(*    returns the previous value of n. *)
CONST
  MCM_SETMONTHDELTA = MCM_FIRST+20;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_SetMonthDelta ( hwndMC: HWND; iDelta: INTEGER ): INTEGER;

(*  DWORD MonthCal_GetMaxTodayWidth(HWND hmc, PSIZE psz) *)
(*    sets *psz to the maximum width/height of the "Today" string displayed *)
(*    at the bottom of the calendar (as long as MCS_NOTODAY is not specified) *)
CONST
  MCM_GETMAXTODAYWIDTH = MCM_FIRST+21;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_GetMaxTodayWidth ( hwndMC: HWND ): DWORD;

(* IF _WIN32_IE >= 0x0400 THEN *)
CONST
  MCM_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_SetUnicodeFormat ( hwndMC: HWND; fUnicode: BOOL ): BOOL;

CONST
  MCM_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT;

(* This procedure corresponds to a macro. *)
PROCEDURE MonthCal_GetUnicodeFormat ( hwndMC: HWND ): BOOL;
(* END *)

(*  MCN_SELCHANGE is sent whenever the currently displayed date changes *)
(*  via month change, year change, keyboard navigation, prev/next button *)
TYPE
  NMSELCHANGE = RECORD
    nmhdr     : NMHDR;       (*  this must be first, so we don't break WM_NOTIFY *)
    stSelStart: SYSTEMTIME;
    stSelEnd  : SYSTEMTIME;
  END;
  PNMSELCHANGE = POINTER TO NMSELCHANGE;

CONST
  MCN_SELCHANGE = MCN_FIRST+1;

(*  MCN_GETDAYSTATE is sent for MCS_DAYSTATE controls whenever new daystate *)
(*  information is needed (month or year scroll) to draw bolding information. *)
(*  The app must fill in cDayState months worth of information starting from *)
(*  stStart date. The app may fill in the array at prgDayState or change *)
(*  prgDayState to point to a different array out of which the information *)
(*  will be copied. (similar to tooltips) *)
TYPE
  NMDAYSTATE = RECORD
    nmhdr      : NMHDR;            (*  this must be first, so we don't break WM_NOTIFY *)
    stStart    : SYSTEMTIME;
    cDayState  : INTEGER;
    prgDayState: PMONTHDAYSTATE;  (*  points to cDayState MONTHDAYSTATEs *)
  END;
  PNMDAYSTATE = POINTER TO NMDAYSTATE;

CONST
  MCN_GETDAYSTATE = MCN_FIRST+3;

(*  MCN_SELECT is sent whenever a selection has occured (via mouse or keyboard) *)
TYPE
  NMSELECT  = NMSELCHANGE;
  PNMSELECT = PNMSELCHANGE;

CONST
  MCN_SELECT = MCN_FIRST+4;

  MCS_DAYSTATE      = WS_SET {WS__0}; (* 0001H *)
  MCS_MULTISELECT   = WS_SET {WS__1}; (* 0002H *)
  MCS_WEEKNUMBERS   = WS_SET {WS__2}; (* 0004H *)
  MCS_NOTODAYCIRCLE = WS_SET {WS__3}; (* 0008H *)
(* IF _WIN32_IE >= 0x0400 THEN *)
  MCS_NOTODAY       = WS_SET {WS__4}; (* 0010H *)
(* END *)

(* ====== DATETIMEPICK CONTROL ================================================== *)
CONST
  DATETIMEPICK_CLASSW = ARRAY OF WCHAR {ORD('S'),ORD('y'),ORD('s'),ORD('D'),ORD('a'),ORD('t'),ORD('e'),
                                        ORD('T'),ORD('i'),ORD('m'),ORD('e'),ORD('P'),ORD('i'),ORD('c'),
                                        ORD('k'),ORD('3'),ORD('2'),0};
  DATETIMEPICK_CLASSA = 'SysDateTimePick32';
<* IF DEFINED (UNICODE) THEN *>
  DATETIMEPICK_CLASS = DATETIMEPICK_CLASSW;
<* ELSE *>
  DATETIMEPICK_CLASS = DATETIMEPICK_CLASSA;
<* END *>

  DTM_FIRST = 1000H;

(*  DWORD DateTimePick_GetSystemtime(HWND hdp, PSYSTEMTIME pst) *)
(*    returns GDT_NONE if "none" is selected (DTS_SHOWNONE only) *)
(*    returns GDT_VALID and modifies *pst to be the currently selected value *)
CONST
  DTM_GETSYSTEMTIME = DTM_FIRST+1;

(* This procedure corresponds to a macro. *)
PROCEDURE DateTime_GetSystemtime ( hwndDP: HWND; VAR SysTime: SYSTEMTIME ): DWORD;

(*  BOOL DateTime_SetSystemtime(HWND hdp, DWORD gd, PSYSTEMTIME pst) *)
(*    if gd==GDT_NONE, sets datetimepick to None (DTS_SHOWNONE only) *)
(*    if gd==GDT_VALID, sets datetimepick to *pst *)
(*    returns TRUE on success, FALSE on error (such as bad params) *)
CONST
  DTM_SETSYSTEMTIME = DTM_FIRST+2;

(* This procedure corresponds to a macro. *)
<* IF BACKEND # "C" THEN *>
PROCEDURE DateTime_SetSystemtime ( hwndDP: HWND; flag: DWORD;
                                   SysTime: SYSTEMTIME (*!*) ): BOOL;
<* ELSE *>
PROCEDURE DateTime_SetSystemtime ( hwndDP: HWND; flag: DWORD;
                                   SysTime: PSYSTEMTIME (*!*) ): BOOL;
<* END *>

(*  DWORD DateTime_GetRange(HWND hdp, PSYSTEMTIME rgst) *)
(*    modifies rgst[0] to be the minimum ALLOWABLE systemtime (or 0 if no minimum) *)
(*    modifies rgst[1] to be the maximum ALLOWABLE systemtime (or 0 if no maximum) *)
(*    returns GDTR_MIN|GDTR_MAX if there is a minimum|maximum limit *)
CONST
  DTM_GETRANGE = DTM_FIRST+3;

(* This procedure corresponds to a macro. *)
PROCEDURE DateTime_GetRange ( hwndDP: HWND; VAR SysTimeArray: ARRAY OF SYSTEMTIME ): GDTR_SET;

(*  BOOL DateTime_SetRange(HWND hdp, DWORD gdtr, PSYSTEMTIME rgst) *)
(*    if GDTR_MIN, sets the minimum ALLOWABLE systemtime to rgst[0], otherwise removes minimum *)
(*    if GDTR_MAX, sets the maximum ALLOWABLE systemtime to rgst[1], otherwise removes maximum *)
(*    returns TRUE on success, FALSE on error (such as invalid parameters) *)
CONST
  DTM_SETRANGE = DTM_FIRST+4;

(* This procedure corresponds to a macro. *)
PROCEDURE DateTime_SetRange ( hwndDP: HWND; flags: GDTR_SET;
                              SysTimeArray: ARRAY OF SYSTEMTIME (*!*) ): BOOL;

(*  BOOL DateTime_SetFormat(HWND hdp, PCTSTR sz) *)
(*    sets the display formatting string to sz (see GetDateFormat and GetTimeFormat for valid formatting chars) *)
(*    NOTE: 'X' is a valid formatting character which indicates that the application *)
(*    will determine how to display information. Such apps must support DTN_WMKEYDOWN, *)
(*    DTN_FORMAT, and DTN_FORMATQUERY. *)
CONST
  DTM_SETFORMATA = DTM_FIRST+5;
  DTM_SETFORMATW = DTM_FIRST+50;
<* IF DEFINED (UNICODE) THEN *>
  DTM_SETFORMAT = DTM_SETFORMATW;
<* ELSE *>
  DTM_SETFORMAT = DTM_SETFORMATA;
<* END *>

(* These procedures correspond to a macro. *)
PROCEDURE DateTime_SetFormatA ( hwndDP: HWND; szFormat: PCSTR (* NIL *) ): BOOL;
PROCEDURE DateTime_SetFormatW ( hwndDP: HWND; szFormat: PCWSTR (* NIL *) ): BOOL;

CONST
<* IF DEFINED (UNICODE) THEN *>
  DateTime_SetFormat = DateTime_SetFormatW;
<* ELSE *>
  DateTime_SetFormat = DateTime_SetFormatA;
<* END *>

CONST
  DTM_SETMCCOLOR = DTM_FIRST+6;

(* This procedure corresponds to a macro. *)
PROCEDURE DateTime_SetMonthCalColor ( hwndDP: HWND; iColor: MCSC_ENUM;
                                      clr: COLORREF ): COLORREF;

CONST
  DTM_GETMCCOLOR = DTM_FIRST+7;

(* This procedure corresponds to a macro. *)
PROCEDURE DateTime_GetMonthCalColor ( hwndDP: HWND; iColor: MCSC_ENUM ): COLORREF;

(*  HWND DateTime_GetMonthCal(HWND hdp) *)
(*    returns the HWND of the MonthCal popup window. Only valid *)
(*  between DTN_DROPDOWN and DTN_CLOSEUP notifications. *)
CONST
  DTM_GETMONTHCAL = DTM_FIRST+8;

(* This procedure corresponds to a macro. *)
PROCEDURE DateTime_GetMonthCal ( hwndDP: HWND ): HWND;

(* IF _WIN32_IE >= 0x0400 THEN *)
CONST
  DTM_SETMCFONT = DTM_FIRST+9;

(* This procedure corresponds to a macro. *)
PROCEDURE DateTime_SetMonthCalFont ( hwndDP: HWND; hFont: HFONT; fRedraw: BOOL );

CONST
  DTM_GETMCFONT = DTM_FIRST+10;

(* This procedure corresponds to a macro. *)
PROCEDURE DateTime_GetMonthCalFont ( hwndDP: HWND ): HFONT;
(* END *)

CONST
  DTS_UPDOWN          = WS_SET {WS__0}; (* 0001H *)   (*  use UPDOWN instead of MONTHCAL *)
  DTS_SHOWNONE        = WS_SET {WS__1}; (* 0002H *)   (*  allow a NONE selection *)
  DTS_SHORTDATEFORMAT = WS_SET {};      (* 0000H *)   (*  use the short date format (app must forward WM_WININICHANGE messages) *)
  DTS_LONGDATEFORMAT  = WS_SET {WS__2}; (* 0004H *)   (*  use the long date format (app must forward WM_WININICHANGE messages) *)
  DTS_TIMEFORMAT      = WS_SET {WS__0,
                                WS__3}; (* 0009H *)   (*  use the time format (app must forward WM_WININICHANGE messages) *)
  DTS_APPCANPARSE     = WS_SET {WS__4}; (* 0010H *)   (*  allow user entered strings (app MUST respond to DTN_USERSTRING) *)
  DTS_RIGHTALIGN      = WS_SET {WS__5}; (* 0020H *)   (*  right-align popup instead of left-align it *)

  DTN_DATETIMECHANGE = DTN_FIRST+1;   (*  the systemtime has changed *)

  GDT_ERROR = -1;
  GDT_VALID = 0;
  GDT_NONE  = 1;

TYPE
  NMDATETIMECHANGE = RECORD
    nmhdr  : NMHDR;
    dwFlags: DWORD;               (*  GDT_VALID or GDT_NONE *)
    st     : SYSTEMTIME;          (*  valid iff dwFlags==GDT_VALID *)
  END;
  PNMDATETIMECHANGE = POINTER TO NMDATETIMECHANGE;

CONST
  DTN_USERSTRINGA = DTN_FIRST+2;   (*  the user has entered a string *)
  DTN_USERSTRINGW = DTN_FIRST+15;
<* IF DEFINED (UNICODE) THEN *>
  DTN_USERSTRING = DTN_USERSTRINGW;
<* ELSE *>
  DTN_USERSTRING = DTN_USERSTRINGA;
<* END *>

TYPE
  NMDATETIMESTRINGA = RECORD
    nmhdr        : NMHDR;
    pszUserString: PCSTR;          (*  string user entered *)
    st           : SYSTEMTIME;     (*  app fills this in *)
    dwFlags      : DWORD;          (*  GDT_VALID or GDT_NONE *)
  END;
  PNMDATETIMESTRINGA = POINTER TO NMDATETIMESTRINGA;

  NMDATETIMESTRINGW = RECORD
    nmhdr        : NMHDR;
    pszUserString: PCWSTR;         (*  string user entered *)
    st           : SYSTEMTIME;     (*  app fills this in *)
    dwFlags      : DWORD;          (*  GDT_VALID or GDT_NONE *)
  END;
  PNMDATETIMESTRINGW = POINTER TO NMDATETIMESTRINGW;

<* IF DEFINED (UNICODE) THEN *>
  NMDATETIMESTRING  = NMDATETIMESTRINGW;
  PNMDATETIMESTRING = PNMDATETIMESTRINGW;
<* ELSE *>
  NMDATETIMESTRING  = NMDATETIMESTRINGA;
  PNMDATETIMESTRING = PNMDATETIMESTRINGA;
<* END *>

CONST
  DTN_WMKEYDOWNA = DTN_FIRST+3;   (*  modify keydown on app format field (X) *)
  DTN_WMKEYDOWNW = DTN_FIRST+16;
<* IF DEFINED (UNICODE) THEN *>
  DTN_WMKEYDOWN = DTN_WMKEYDOWNW;
<* ELSE *>
  DTN_WMKEYDOWN = DTN_WMKEYDOWNA;
<* END *>

TYPE
  NMDATETIMEWMKEYDOWNA = RECORD
    nmhdr    : NMHDR;
    nVirtKey : INTEGER;            (*  virtual key code of WM_KEYDOWN which MODIFIES an X field *)
    pszFormat: PCSTR;                 (*  format substring *)
    st       : SYSTEMTIME;            (*  current systemtime, app should modify based on key *)
  END;
  PNMDATETIMEWMKEYDOWNA = POINTER TO NMDATETIMEWMKEYDOWNA;

  NMDATETIMEWMKEYDOWNW = RECORD
    nmhdr    : NMHDR;
    nVirtKey : INTEGER;            (*  virtual key code of WM_KEYDOWN which MODIFIES an X field *)
    pszFormat: PCWSTR;                (*  format substring *)
    st       : SYSTEMTIME;            (*  current systemtime, app should modify based on key *)
  END;
  PNMDATETIMEWMKEYDOWNW = POINTER TO NMDATETIMEWMKEYDOWNW;

<* IF DEFINED (UNICODE) THEN *>
  NMDATETIMEWMKEYDOWN  = NMDATETIMEWMKEYDOWNW;
  PNMDATETIMEWMKEYDOWN = PNMDATETIMEWMKEYDOWNW;
<* ELSE *>
  NMDATETIMEWMKEYDOWN  = NMDATETIMEWMKEYDOWNA;
  PNMDATETIMEWMKEYDOWN = PNMDATETIMEWMKEYDOWNA;
<* END *>

CONST
  DTN_FORMATA = DTN_FIRST+4;   (*  query display for app format field (X) *)
  DTN_FORMATW = DTN_FIRST+17;
<* IF DEFINED (UNICODE) THEN *>
  DTN_FORMAT = DTN_FORMATW;
<* ELSE *>
  DTN_FORMAT = DTN_FORMATA;
<* END *>

TYPE
  NMDATETIMEFORMATA = RECORD
    nmhdr     : NMHDR;
    pszFormat : PCSTR;                             (*  format substring *)
    st        : SYSTEMTIME;                        (*  current systemtime *)
    pszDisplay: PCSTR;                             (*  string to display *)
    szDisplay : ARRAY [0..64-1] OF CHAR;           (*  buffer pszDisplay originally points at *)
  END;
  PNMDATETIMEFORMATA = POINTER TO NMDATETIMEFORMATA;

  NMDATETIMEFORMATW = RECORD
    nmhdr     : NMHDR;
    pszFormat : PCWSTR;                    (*  format substring *)
    st        : SYSTEMTIME;                (*  current systemtime *)
    pszDisplay: PCWSTR;                    (*  string to display *)
    szDisplay : ARRAY [0..64-1] OF WCHAR;  (*  buffer pszDisplay originally points at *)
  END;
  PNMDATETIMEFORMATW = POINTER TO NMDATETIMEFORMATW;

<* IF DEFINED (UNICODE) THEN *>
  NMDATETIMEFORMAT  = NMDATETIMEFORMATW;
  PNMDATETIMEFORMAT = PNMDATETIMEFORMATW;
<* ELSE *>
  NMDATETIMEFORMAT  = NMDATETIMEFORMATA;
  PNMDATETIMEFORMAT = PNMDATETIMEFORMATA;
<* END *>

CONST
  DTN_FORMATQUERYA = DTN_FIRST+5;   (*  query formatting info for app format field (X) *)
  DTN_FORMATQUERYW = DTN_FIRST+18;
<* IF DEFINED (UNICODE) THEN *>
  DTN_FORMATQUERY = DTN_FORMATQUERYW;
<* ELSE *>
  DTN_FORMATQUERY = DTN_FORMATQUERYA;
<* END *>

TYPE
  NMDATETIMEFORMATQUERYA = RECORD
    nmhdr    : NMHDR;
    pszFormat: PCSTR;                  (*  format substring *)
    szMax    : SIZEL;                  (*  max bounding rectangle app will use for this format string *)
  END;
  PNMDATETIMEFORMATQUERYA = POINTER TO NMDATETIMEFORMATQUERYA;

  NMDATETIMEFORMATQUERYW = RECORD
    nmhdr    : NMHDR;
    pszFormat: PCWSTR;                 (*  format substring *)
    szMax    : SIZEL;                  (*  max bounding rectangle app will use for this format string *)
  END;
  PNMDATETIMEFORMATQUERYW = POINTER TO NMDATETIMEFORMATQUERYW;

<* IF DEFINED (UNICODE) THEN *>
  NMDATETIMEFORMATQUERY  = NMDATETIMEFORMATQUERYW;
  PNMDATETIMEFORMATQUERY = PNMDATETIMEFORMATQUERYW;
<* ELSE *>
  NMDATETIMEFORMATQUERY  = NMDATETIMEFORMATQUERYA;
  PNMDATETIMEFORMATQUERY = PNMDATETIMEFORMATQUERYA;
<* END *>

CONST
  DTN_DROPDOWN = DTN_FIRST+6;   (*  MonthCal has dropped down *)
  DTN_CLOSEUP  = DTN_FIRST+7;   (*  MonthCal is popping up *)

(* IF _WIN32_IE >= 0x0400 THEN *)
(* ///////////////////////////////////////////// *)
(* /    IP Address edit control *)
(*  Messages sent to IPAddress controls *)
CONST
  IPM_CLEARADDRESS = WM_USER+100;   (*  no parameters *)
  IPM_SETADDRESS   = WM_USER+101;   (*  lparam = TCP/IP address *)
  IPM_GETADDRESS   = WM_USER+102;   (*  lresult = # of non black fields.  lparam = PDWORD for TCP/IP address *)
  IPM_SETRANGE     = WM_USER+103;   (*  wparam = field, lparam = range *)
  IPM_SETFOCUS     = WM_USER+104;   (*  wparam = field *)
  IPM_ISBLANK      = WM_USER+105;   (*  no parameters *)

  WC_IPADDRESSW = ARRAY OF WCHAR {ORD('S'),ORD('y'),ORD('s'),ORD('I'),ORD('P'),ORD('A'),ORD('d'),ORD('d'),
                                  ORD('r'),ORD('e'),ORD('s'),ORD('s'),ORD('3'),ORD('2'),0};
  WC_IPADDRESSA = 'SysIPAddress32';
<* IF DEFINED (UNICODE) THEN *>
  WC_IPADDRESS = WC_IPADDRESSW;
<* ELSE *>
  WC_IPADDRESS = WC_IPADDRESSA;
<* END *>

  IPN_FIELDCHANGED = IPN_FIRST-0;

TYPE
  NMIPADDRESS = RECORD
    hdr   : NMHDR;
    iPos  : INTEGER;
    iDelta: INTEGER;
  END;
  PNMIPADDRESS = POINTER TO NMIPADDRESS;

(*  The following is a useful macro for passing the range values in the *)
(*  IPM_SETRANGE message. *)

(* This procedure corresponds to a macro. *)
PROCEDURE MAKEIPRANGE ( low, high: BYTE ): LPARAM;

(*  And this is a useful macro for making the IP Address to be passed *)
(*  as a LPARAM. *)

(* This procedure corresponds to a macro. *)
PROCEDURE MAKEIPADDRESS ( b1, b2, b3, b4: BYTE ): LPARAM;

(*  Get individual number *)

(* This procedure corresponds to a macro. *)
PROCEDURE FIRST_IPADDRESS ( lParam: LPARAM ): BYTE;

(* This procedure corresponds to a macro. *)
PROCEDURE SECOND_IPADDRESS ( lParam: LPARAM ): BYTE;

(* This procedure corresponds to a macro. *)
PROCEDURE THIRD_IPADDRESS ( lParam: LPARAM ): BYTE;

(* This procedure corresponds to a macro. *)
PROCEDURE FOURTH_IPADDRESS ( lParam: LPARAM ): BYTE;

(* --------------------------------------------------------------------------------------- *)
(* --------------------------------------------------------------------------------------- *)
(* /  ====================== Pager Control ============================= *)
(* --------------------------------------------------------------------------------------- *)
(* --------------------------------------------------------------------------------------- *)
(* Pager Class Name *)
CONST
  WC_PAGESCROLLERW = ARRAY OF WCHAR {ORD('S'),ORD('y'),ORD('s'),ORD('P'),ORD('a'),ORD('g'),ORD('e'),ORD('r'),0};
  WC_PAGESCROLLERA = 'SysPager';
<* IF DEFINED (UNICODE) THEN *>
  WC_PAGESCROLLER = WC_PAGESCROLLERW;
<* ELSE *>
  WC_PAGESCROLLER = WC_PAGESCROLLERA;
<* END *>

(* --------------------------------------------------------------------------------------- *)
(*  Pager Control Styles *)
(* --------------------------------------------------------------------------------------- *)
  PGS_VERT       = WS_SET {};      (* 0000H *)
  PGS_HORZ       = WS_SET {WS__0}; (* 0001H *)
  PGS_AUTOSCROLL = WS_SET {WS__1}; (* 0002H *)
  PGS_DRAGNDROP  = WS_SET {WS__2}; (* 0004H *)

(* --------------------------------------------------------------------------------------- *)
(*  Pager Button State *)
(* --------------------------------------------------------------------------------------- *)
(* The scroll can be in one of the following control State  *)
  PGF_INVISIBLE = 0;   (*  Scroll button is not visible *)
  PGF_NORMAL    = 1;   (*  Scroll button is in normal state *)
  PGF_GRAYED    = 2;   (*  Scroll button is in grayed state *)
  PGF_DEPRESSED = 4;   (*  Scroll button is in depressed state *)
  PGF_HOT       = 8;   (*  Scroll button is in hot state *)

(*  The following identifiers specifies the button control  *)
TYPE
  PGB_ENUM = (
    PGB_TOPORLEFT,      (* 0 *)
    PGB_BOTTOMORRIGHT   (* 1 *)
  );

(* --------------------------------------------------------------------------------------- *)
(*  Pager Control  Messages *)
(* --------------------------------------------------------------------------------------- *)
CONST
  PGM_SETCHILD = PGM_FIRST+1;   (*  lParam == hwnd *)

(* This procedure corresponds to a macro. *)
PROCEDURE Pager_SetChild ( hwndPager: HWND; hwndChild: HWND );

CONST
  PGM_RECALCSIZE = PGM_FIRST+2;

(* This procedure corresponds to a macro. *)
PROCEDURE Pager_RecalcSize ( hwndPager: HWND );

CONST
  PGM_FORWARDMOUSE = PGM_FIRST+3;

(* This procedure corresponds to a macro. *)
PROCEDURE Pager_ForwardMouse ( hwndPager: HWND; bForward: BOOL );

CONST
  PGM_SETBKCOLOR = PGM_FIRST+4;

(* This procedure corresponds to a macro. *)
PROCEDURE Pager_SetBkColor ( hwndPager: HWND; clrBk: COLORREF ): COLORREF;

CONST
  PGM_GETBKCOLOR = PGM_FIRST+5;

(* This procedure corresponds to a macro. *)
PROCEDURE Pager_GetBkColor ( hwndPager: HWND ): COLORREF;

CONST
  PGM_SETBORDER = PGM_FIRST+6;

(* This procedure corresponds to a macro. *)
PROCEDURE Pager_SetBorder ( hwndPager: HWND; iBorder: INTEGER ): INTEGER;

CONST
  PGM_GETBORDER = PGM_FIRST+7;

(* This procedure corresponds to a macro. *)
PROCEDURE Pager_GetBorder ( hwndPager: HWND ): INTEGER;

CONST
  PGM_SETPOS = PGM_FIRST+8;

(* This procedure corresponds to a macro. *)
PROCEDURE Pager_SetPos ( hwndPager: HWND; iPos: INTEGER ): INTEGER;

CONST
  PGM_GETPOS = PGM_FIRST+9;

(* This procedure corresponds to a macro. *)
PROCEDURE Pager_GetPos ( hwndPager: HWND ): INTEGER;

CONST
  PGM_SETBUTTONSIZE = PGM_FIRST+10;

(* This procedure corresponds to a macro. *)
PROCEDURE Pager_SetButtonSize ( hwndPager: HWND; iButtonSize: INTEGER ): INTEGER;

CONST
  PGM_GETBUTTONSIZE = PGM_FIRST+11;

(* This procedure corresponds to a macro. *)
PROCEDURE Pager_GetButtonSize ( hwndPager: HWND ): INTEGER;

CONST
  PGM_GETBUTTONSTATE = PGM_FIRST+12;

(* This procedure corresponds to a macro. *)
PROCEDURE Pager_GetButtonState ( hwndPager: HWND; iButton: PGB_ENUM ): DWORD;

CONST
  PGM_GETDROPTARGET = CCM_GETDROPTARGET;

(* This procedure corresponds to a macro. *)
PROCEDURE Pager_GetDropTarget ( hwndPager: HWND; VAR DropTarget: SYSTEM.ADDRESS );

(* --------------------------------------------------------------------------------------- *)
(* Pager Control Notification Messages *)
(* --------------------------------------------------------------------------------------- *)
(*  PGN_SCROLL Notification Message *)
CONST
  PGN_SCROLL = PGN_FIRST-1;

  PGF_SCROLLUP    = 1;
  PGF_SCROLLDOWN  = 2;
  PGF_SCROLLLEFT  = 4;
  PGF_SCROLLRIGHT = 8;

<* PUSH *> <* SETSIZE = "2" *>

TYPE
  PGK_ENUM = (
    PGK__SHIFT,         (* 0 *)
    PGK__CONTROL,       (* 1 *)
    PGK__MENU           (* 2 *)
  );
  PGK_SET = SET OF PGK_ENUM;

<* POP *>

CONST
(* Keys down *)
  PGK_NONE    = PGK_SET {};             (* 0000H *)
  PGK_SHIFT   = PGK_SET {PGK__SHIFT};   (* 0001H *)
  PGK_CONTROL = PGK_SET {PGK__CONTROL}; (* 0002H *)
  PGK_MENU    = PGK_SET {PGK__MENU};    (* 0004H *)

(*  This structure is sent along with PGN_SCROLL notifications *)
TYPE
  NMPGSCROLL = RECORD
    hdr     : NMHDR;
    fwKeys  : PGK_SET;     (*  Specifies which keys are down when this notification is send *)
    rcParent: RECT;        (*  Contains Parent Window Rect *)
    iDir    : DWORD;    (*  Scrolling Direction *)
    iXpos   : INTEGER;  (*  Horizontal scroll position *)
    iYpos   : INTEGER;  (*  Vertical scroll position *)
    iScroll : INTEGER;  (*  [in/out] Amount to scroll *)
  END;
  PNMPGSCROLL = POINTER TO NMPGSCROLL;

(*  PGN_CALCSIZE Notification Message *)
CONST
  PGN_CALCSIZE = PGN_FIRST-2;

  PGF_CALCWIDTH  = 1;
  PGF_CALCHEIGHT = 2;

TYPE
  NMPGCALCSIZE = RECORD
    hdr    : NMHDR;
    dwFlag : DWORD;
    iWidth : INTEGER;
    iHeight: INTEGER;
  END;
  PNMPGCALCSIZE = POINTER TO NMPGCALCSIZE;

(* //======================  End Pager Control ========================================== *)

(*  === Native Font Control === *)
(* NativeFont Class Name *)
CONST
  WC_NATIVEFONTCTLW = ARRAY OF WCHAR {ORD('N'),ORD('a'),ORD('t'),ORD('i'),ORD('v'),ORD('e'),ORD('F'),ORD('o'),
                                      ORD('n'),ORD('t'),ORD('C'),ORD('t'),ORD('l'),0};
  WC_NATIVEFONTCTLA = 'NativeFontCtl';
<* IF DEFINED (UNICODE) THEN *>
  WC_NATIVEFONTCTL = WC_NATIVEFONTCTLW;
<* ELSE *>
  WC_NATIVEFONTCTL = WC_NATIVEFONTCTLA;
<* END *>

(*  style definition *)
  NFS_EDIT      = WS_SET {WS__0}; (* 0001H *)
  NFS_STATIC    = WS_SET {WS__1}; (* 0002H *)
  NFS_LISTCOMBO = WS_SET {WS__2}; (* 0004H *)
  NFS_BUTTON    = WS_SET {WS__3}; (* 0008H *)
  NFS_ALL       = WS_SET {WS__4}; (* 0010H *)

(*  === End Native Font Control === *)

(* ====== TrackMouseEvent  ===================================================== *)

(*  Declare _TrackMouseEvent.  This API tries to use the window manager's *)
(*  implementation of TrackMouseEvent if it is present, otherwise it emulates. *)

PROCEDURE _TrackMouseEvent ( VAR EventTrack: TRACKMOUSEEVENT ): BOOL;

(* ====== Flat Scrollbar APIs========================================= *)
TYPE
  WSB_PROP_ENUM = (
    WSB_PROP__CYVSCROLL,        (*  0 *)
    WSB_PROP__CXHSCROLL,        (*  1 *)
    WSB_PROP__CYHSCROLL,        (*  2 *)
    WSB_PROP__CXVSCROLL,        (*  3 *)
    WSB_PROP__CXHTHUMB,         (*  4 *)
    WSB_PROP__CYVTHUMB,         (*  5 *)
    WSB_PROP__VBKGCOLOR,        (*  6 *)
    WSB_PROP__HBKGCOLOR,        (*  7 *)
    WSB_PROP__VSTYLE,           (*  8 *)
    WSB_PROP__HSTYLE,           (*  9 *)
    WSB_PROP__WINSTYLE,         (* 10 *)
    WSB_PROP__PALETTE           (* 11 *)
  );
  WSB_PROP_SET = SET OF WSB_PROP_ENUM;

CONST
  WSB_PROP_CYVSCROLL = WSB_PROP_SET {WSB_PROP__CYVSCROLL}; (* 0001H *)
  WSB_PROP_CXHSCROLL = WSB_PROP_SET {WSB_PROP__CXHSCROLL}; (* 0002H *)
  WSB_PROP_CYHSCROLL = WSB_PROP_SET {WSB_PROP__CYHSCROLL}; (* 0004H *)
  WSB_PROP_CXVSCROLL = WSB_PROP_SET {WSB_PROP__CXVSCROLL}; (* 0008H *)
  WSB_PROP_CXHTHUMB  = WSB_PROP_SET {WSB_PROP__CXHTHUMB};  (* 0010H *)
  WSB_PROP_CYVTHUMB  = WSB_PROP_SET {WSB_PROP__CYVTHUMB};  (* 0020H *)
  WSB_PROP_VBKGCOLOR = WSB_PROP_SET {WSB_PROP__VBKGCOLOR}; (* 0040H *)
  WSB_PROP_HBKGCOLOR = WSB_PROP_SET {WSB_PROP__HBKGCOLOR}; (* 0080H *)
  WSB_PROP_VSTYLE    = WSB_PROP_SET {WSB_PROP__VSTYLE};    (* 0100H *)
  WSB_PROP_HSTYLE    = WSB_PROP_SET {WSB_PROP__HSTYLE};    (* 0200H *)
  WSB_PROP_WINSTYLE  = WSB_PROP_SET {WSB_PROP__WINSTYLE};  (* 0400H *)
  WSB_PROP_PALETTE   = WSB_PROP_SET {WSB_PROP__PALETTE};   (* 0800H *)
  WSB_PROP_MASK      = WSB_PROP_SET {WSB_PROP__CYVSCROLL..
                                     WSB_PROP__PALETTE};   (* 0FFFH *)

  FSB_FLAT_MODE    = 2;
  FSB_ENCARTA_MODE = 1;
  FSB_REGULAR_MODE = 0;

PROCEDURE FlatSB_EnableScrollBar ( hwnd: HWND; code: SB_TYPE; wArrows: ESB_SET ): BOOL;
PROCEDURE FlatSB_ShowScrollBar ( hwnd: HWND; code: SB_TYPE; fShow: BOOL ): BOOL;

PROCEDURE FlatSB_GetScrollRange ( hwnd: HWND; code: SB_TYPE; VAR min, max: INTEGER ): BOOL;
PROCEDURE FlatSB_GetScrollInfo ( hwnd: HWND; code: SB_TYPE; VAR si: SCROLLINFO ): BOOL;
PROCEDURE FlatSB_GetScrollPos ( hwnd: HWND; code: SB_TYPE ): INTEGER;
PROCEDURE FlatSB_GetScrollProp ( hwnd: HWND; propIndex: WSB_PROP_SET; VAR value: INTEGER ): BOOL;

PROCEDURE FlatSB_SetScrollPos ( hwnd: HWND; code: SB_TYPE; pos: INTEGER; fRedraw: BOOL ): INTEGER;
<* IF BACKEND # "C" THEN *>
PROCEDURE FlatSB_SetScrollInfo ( hwnd: HWND; code: SB_TYPE; si: SCROLLINFO (*!*);
                                 fRedraw: BOOL ): INTEGER;
<* ELSE *>
PROCEDURE FlatSB_SetScrollInfo ( hwnd: HWND; code: SB_TYPE; si: PSCROLLINFO (*!*);
                                 fRedraw: BOOL ): INTEGER;
<* END *>
PROCEDURE FlatSB_SetScrollRange ( hwnd: HWND; code: SB_TYPE; min, max: INTEGER;
                                  fRedraw: BOOL ): INTEGER;
PROCEDURE FlatSB_SetScrollProp ( hwnd: HWND; index: WSB_PROP_SET; newValue: INTEGER;
                                 fRedraw: BOOL ): BOOL;

PROCEDURE InitializeFlatSB ( hwnd: HWND ): BOOL;
PROCEDURE UninitializeFlatSB ( hwnd: HWND ): HRESULT;

(* END *)

(* END *)

<* POP *>

END CommCtrl.
