<* +M2EXTENSIONS  *>
<* ALIGNMENT="8" *>
<* ENUMSIZE="4" *>
<* SETSIZE="4" *>

DEFINITION MODULE ["StdCall"] WinGDI;

(**************************************************************************
*                                                                         *
* WinGDI -- GDI procedure declarations and constant definitions           *
*                                                                         *
**************************************************************************)

IMPORT SYSTEM;

FROM WinDef IMPORT BOOL, WCHAR, WORD, DWORD, BYTE, LONG, ULONG, UINT, FLOAT, BOOL8, INT8,
                   SHORT, PSTR, PWSTR, PCSTR, PCWSTR,
                   PINT, RECT, PBYTE, PCBYTE, PDWORD, PCDWORD, PVOID,
                   POINT, POINTL, SIZEL, RECTL, PRECT, INTARRAY, POINTS, PPOINT,
                   PCSIZE,
                   HMODULE, HWND, HDC, HFONT, LPARAM, COLORREF, HANDLE, HBITMAP, HPEN,
                   HBRUSH, HGDIOBJ, HRGN, HPALETTE, HMETAFILE, HGLOBAL, HGLRC,
                   HENHMETAFILE, MAX_PATH, HCOLORSPACE;

<* IF NOT DEFINED (NORASTEROPS) THEN *>

(* Binary raster ops *)

TYPE ROP2 = (R2_ERROR,
             R2_BLACK,        (*  1 - 0    *)
             R2_NOTMERGEPEN,  (*  2 - DPon *)
             R2_MASKNOTPEN,   (*  3 - DPna *)
             R2_NOTCOPYPEN,   (*  4 - PN   *)
             R2_MASKPENNOT,   (*  5 - PDna *)
             R2_NOT,          (*  6 - Dn   *)
             R2_XORPEN,       (*  7 - DPx  *)
             R2_NOTMASKPEN,   (*  8 - DPan *)
             R2_MASKPEN,      (*  9 - DPa  *)
             R2_NOTXORPEN,    (* 10 - DPxn *)
             R2_NOP,          (* 11 - D    *)
             R2_MERGENOTPEN,  (* 12 - DPno *)
             R2_COPYPEN,      (* 13 - P    *)
             R2_MERGEPENNOT,  (* 14 - PDno *)
             R2_MERGEPEN,     (* 15 - DPo  *)
             R2_WHITE);       (* 16 - 1    *)

CONST R2_LAST = R2_WHITE;

(* Ternary raster operations *)

TYPE ROP = DWORD;

CONST SRCCOPY      = ROP (00CC0020h); (* dest = source                   *)
      SRCPAINT     = ROP (00EE0086h); (* dest = source OR dest           *)
      SRCAND       = ROP (008800C6h); (* dest = source AND dest          *)
      SRCINVERT    = ROP (00660046h); (* dest = source XOR dest          *)
      SRCERASE     = ROP (00440328h); (* dest = source AND (NOT dest )   *)
      NOTSRCCOPY   = ROP (00330008h); (* dest = (NOT source)             *)
      NOTSRCERASE  = ROP (001100A6h); (* dest = (NOT src) AND (NOT dest) *)
      MERGECOPY    = ROP (00C000CAh); (* dest = (source AND pattern)     *)
      MERGEPAINT   = ROP (00BB0226h); (* dest = (NOT source) OR dest     *)
      PATCOPY      = ROP (00F00021h); (* dest = pattern                  *)
      PATPAINT     = ROP (00FB0A09h); (* dest = DPSnoo                   *)
      PATINVERT    = ROP (005A0049h); (* dest = pattern XOR dest         *)
      DSTINVERT    = ROP (00550009h); (* dest = (NOT dest)               *)
      BLACKNESS    = ROP (00000042h); (* dest = BLACK                    *)
      WHITENESS    = ROP (00FF0062h); (* dest = WHITE                    *)

(* Quaternary raster codes *)
TYPE ROP4 = DWORD;

PROCEDURE MAKEROP4 (fore, back : ROP) : ROP4; (* in RTL; was macro *)

<* END *> (* NOT DEFINED (NORASTEROPS) *)

CONST GDI_ERROR = 0FFFFFFFFh;
      HGDI_ERROR = SYSTEM.CAST (HANDLE, VAL (ULONG, 0FFFFFFFFh));

(* Region Flags *)

TYPE RGN_CODE = (RGN_ERROR, NULLREGION, SIMPLEREGION, COMPLEXREGION);

(* CombineRgn() Styles *)
TYPE RGN_COMBINE_ENUM = (RGN_COMBINE_0,
                         RGN_AND,        (* 1 *)
                         RGN_OR,         (* 2 *)
                         RGN_XOR,        (* 3 *)
                         RGN_DIFF,       (* 4 *)
                         RGN_COPY);      (* 5 *)

CONST RGN_MIN = RGN_AND;
      RGN_MAX = RGN_COPY;

(* StretchBlt () Modes *)
TYPE STRETCH_ENUM = (STRETCH_0,
                     BLACKONWHITE,   (* 1 *)
                     WHITEONBLACK,   (* 2 *)
                     COLORONCOLOR,   (* 3 *)
                     HALFTONE);      (* 4 *)

CONST MAXSTRETCHBLTMODE   = HALFTONE;
      STRETCH_ANDSCANS    = BLACKONWHITE;
      STRETCH_ORSCANS     = WHITEONBLACK;
      STRETCH_DELETESCANS = COLORONCOLOR;
      STRETCH_HALFTONE    = HALFTONE;

(* PolyFill(), CreatePolygonRgn() Modes *)

TYPE POLYFILL_ENUM = (POLYFILL_0, ALTERNATE, WINDING);
CONST POLYFILL_LAST = WINDING;

(* Text Alignment Options *)

TYPE TA_ENUM = (TA__0, TA__1, TA__2, TA__3,
                TA__4, TA__5, TA__6, TA__7,
                TA__8);
     TA_SET = SET OF TA_ENUM;

CONST TA_NOUPDATECP = TA_SET {};              (*   0 *)
      TA_UPDATECP   = TA_SET {TA__0};         (*   1 *)

      TA_LEFT       = TA_SET {};              (*   0 *)
      TA_RIGHT      = TA_SET {TA__1};         (*   2 *)
      TA_CENTER     = TA_SET {TA__2, TA__1};  (*   6 *)

      TA_TOP        = TA_SET {};              (*   0 *)
      TA_BOTTOM     = TA_SET {TA__3};         (*   8 *)
      TA_BASELINE   = TA_SET {TA__4, TA__3};  (*  24 *)

      TA_RTLREADING = TA_SET {TA__8};         (* 256 *)
      TA_MASK       = TA_BASELINE + TA_CENTER + TA_UPDATECP + TA_RTLREADING;

CONST VTA_BASELINE = TA_BASELINE;
      VTA_LEFT     = TA_BOTTOM;
      VTA_RIGHT    = TA_TOP;
      VTA_CENTER   = TA_CENTER;
      VTA_BOTTOM   = TA_RIGHT;
      VTA_TOP      = TA_LEFT;

TYPE ETO_ENUM = (ETO__0,
                 ETO__OPAQUE,      (* 1 *)
                 ETO__CLIPPED,     (* 2 *)
                 ETO__3,
                 ETO__GLYPH_INDEX, (* 4 *)
                 ETO__5, ETO__6,
                 ETO__RTLREADING,  (* 7 *)
                 ETO__8,  ETO__9,
                 ETO__10, ETO__11,
                 ETO__IGNORELANGUAGE);
     ETO_SET = SET OF ETO_ENUM;

CONST ETO_OPAQUE         = ETO_SET {ETO__OPAQUE};      (* 0x0002 *)
      ETO_CLIPPED        = ETO_SET {ETO__CLIPPED};     (* 0x0004 *)
      ETO_GLYPH_INDEX    = ETO_SET {ETO__GLYPH_INDEX}; (* 0x0010 *)
      ETO_RTLREADING     = ETO_SET {ETO__RTLREADING};  (* 0x0080 *)
      ETO_IGNORELANGUAGE = ETO_SET {ETO__IGNORELANGUAGE}; (* 0x1000 *)

CONST ASPECT_FILTERING = 1;

(* Bounds Accumulation APIs *)

TYPE DCB_ENUM = (DCB__RESET,       (* 0 *)
                 DCB__ACCUMULATE,  (* 1 *)
                 DCB__ENABLE,      (* 2 *)
                 DCB__DISABLE);    (* 3 *)

     DCB__SET = SET OF DCB_ENUM;

CONST DCB__DIRTY = DCB__ACCUMULATE;

      DCB_RESET       = DCB__SET {DCB__RESET};        (* 0x0001 *)
      DCB_ACCUMULATE  = DCB__SET {DCB__ACCUMULATE};   (* 0x0002 *)
      DCB_DIRTY       = DCB__SET {DCB__DIRTY};        (* 0x0002 *)
      DCB_ENABLE      = DCB__SET {DCB__ENABLE};       (* 0x0004 *)
      DCB_DISABLE     = DCB__SET {DCB__DISABLE};      (* 0x0008 *)
      DCB_SET         = DCB_RESET + DCB_ACCUMULATE;

<* IF NOT DEFINED (NOMETAFILE) THEN *>

(* Metafile Functions *)

CONST META_SETBKCOLOR           =  0201h;
      META_SETBKMODE            =  0102h;
      META_SETMAPMODE           =  0103h;
      META_SETROP2              =  0104h;
      META_SETRELABS            =  0105h;
      META_SETPOLYFILLMODE      =  0106h;
      META_SETSTRETCHBLTMODE    =  0107h;
      META_SETTEXTCHAREXTRA     =  0108h;
      META_SETTEXTCOLOR         =  0209h;
      META_SETTEXTJUSTIFICATION =  020Ah;
      META_SETWINDOWORG         =  020Bh;
      META_SETWINDOWEXT         =  020Ch;
      META_SETVIEWPORTORG       =  020Dh;
      META_SETVIEWPORTEXT       =  020Eh;
      META_OFFSETWINDOWORG      =  020Fh;
      META_SCALEWINDOWEXT       =  0410h;
      META_OFFSETVIEWPORTORG    =  0211h;
      META_SCALEVIEWPORTEXT     =  0412h;
      META_LINETO               =  0213h;
      META_MOVETO               =  0214h;
      META_EXCLUDECLIPRECT      =  0415h;
      META_INTERSECTCLIPRECT    =  0416h;
      META_ARC                  =  0817h;
      META_ELLIPSE              =  0418h;
      META_FLOODFILL            =  0419h;
      META_PIE                  =  081Ah;
      META_RECTANGLE            =  041Bh;
      META_ROUNDRECT            =  061Ch;
      META_PATBLT               =  061Dh;
      META_SAVEDC               =  001Eh;
      META_SETPIXEL             =  041Fh;
      META_OFFSETCLIPRGN        =  0220h;
      META_TEXTOUT              =  0521h;
      META_BITBLT               =  0922h;
      META_STRETCHBLT           =  0B23h;
      META_POLYGON              =  0324h;
      META_POLYLINE             =  0325h;
      META_ESCAPE               =  0626h;
      META_RESTOREDC            =  0127h;
      META_FILLREGION           =  0228h;
      META_FRAMEREGION          =  0429h;
      META_INVERTREGION         =  012Ah;
      META_PAINTREGION          =  012Bh;
      META_SELECTCLIPREGION     =  012Ch;
      META_SELECTOBJECT         =  012Dh;
      META_SETTEXTALIGN         =  012Eh;
      META_CHORD                =  0830h;
      META_SETMAPPERFLAGS       =  0231h;
      META_EXTTEXTOUT           =  0a32h;
      META_SETDIBTODEV          =  0d33h;
      META_SELECTPALETTE        =  0234h;
      META_REALIZEPALETTE       =  0035h;
      META_ANIMATEPALETTE       =  0436h;
      META_SETPALENTRIES        =  0037h;
      META_POLYPOLYGON          =  0538h;
      META_RESIZEPALETTE        =  0139h;
      META_DIBBITBLT            =  0940h;
      META_DIBSTRETCHBLT        =  0b41h;
      META_DIBCREATEPATTERNBRUSH=  0142h;
      META_STRETCHDIB           =  0f43h;
      META_EXTFLOODFILL         =  0548h;
      META_DELETEOBJECT         =  01f0h;
      META_CREATEPALETTE        =  00f7h;
      META_CREATEPATTERNBRUSH   =  01F9h;
      META_CREATEPENINDIRECT    =  02FAh;
      META_CREATEFONTINDIRECT   =  02FBh;
      META_CREATEBRUSHINDIRECT  =  02FCh;
      META_CREATEREGION         =  06FFh;

<* END *> (* NOT DEFINED (NOMETAFILE) *)

(* GDI Escapes *)

CONST NEWFRAME                   = 1;
      ABORTDOC                   = 2;
      NEXTBAND                   = 3;
      SETCOLORTABLE              = 4;
      GETCOLORTABLE              = 5;
      FLUSHOUTPUT                = 6;
      DRAFTMODE                  = 7;
      QUERYESCSUPPORT            = 8;
      SETABORTPROC               = 9;
      STARTDOC                   = 10;
      ENDDOC                     = 11;
      GETPHYSPAGESIZE            = 12;
      GETPRINTINGOFFSET          = 13;
      GETSCALINGFACTOR           = 14;
      MFCOMMENT                  = 15;
      GETPENWIDTH                = 16;
      SETCOPYCOUNT               = 17;
      SELECTPAPERSOURCE          = 18;
      DEVICEDATA                 = 19;
      PASSTHROUGH                = 19;
      GETTECHNOLGY               = 20;
      GETTECHNOLOGY              = 20;
      SETLINECAP                 = 21;
      SETLINEJOIN                = 22;
      SETMITERLIMIT              = 23;
      BANDINFO                   = 24;
      DRAWPATTERNRECT            = 25;
      GETVECTORPENSIZE           = 26;
      GETVECTORBRUSHSIZE         = 27;
      ENABLEDUPLEX               = 28;
      GETSETPAPERBINS            = 29;
      GETSETPRINTORIENT          = 30;
      ENUMPAPERBINS              = 31;
      SETDIBSCALING              = 32;
      EPSPRINTING                = 33;
      ENUMPAPERMETRICS           = 34;
      GETSETPAPERMETRICS         = 35;
      POSTSCRIPT_DATA            = 37;
      POSTSCRIPT_IGNORE          = 38;
      MOUSETRAILS                = 39;
      GETDEVICEUNITS             = 42;

      GETEXTENDEDTEXTMETRICS     = 256;
      GETEXTENTTABLE             = 257;
      GETPAIRKERNTABLE           = 258;
      GETTRACKKERNTABLE          = 259;
      EXTTEXTOUT                 = 512;
      GETFACENAME                = 513;
      DOWNLOADFACE               = 514;
      ENABLERELATIVEWIDTHS       = 768;
      ENABLEPAIRKERNING          = 769;
      SETKERNTRACK               = 770;
      SETALLJUSTVALUES           = 771;
      SETCHARSET                 = 772;

      STRETCHBLT                 = 2048;
      GETSETSCREENPARAMS         = 3072;
      QUERYDIBSUPPORT            = 3073;
      BEGIN_PATH                 = 4096;
      CLIP_TO_PATH               = 4097;
      END_PATH                   = 4098;
      EXT_DEVICE_CAPS            = 4099;
      RESTORE_CTM                = 4100;
      SAVE_CTM                   = 4101;
      SET_ARC_DIRECTION          = 4102;
      SET_BACKGROUND_COLOR       = 4103;
      SET_POLY_MODE              = 4104;
      SET_SCREEN_ANGLE           = 4105;
      SET_SPREAD                 = 4106;
      TRANSFORM_CTM              = 4107;
      SET_CLIP_BOX               = 4108;
      SET_BOUNDS                 = 4109;
      SET_MIRROR_MODE            = 4110;
      OPENCHANNEL                = 4110;
      DOWNLOADHEADER             = 4111;
      CLOSECHANNEL               = 4112;
      POSTSCRIPT_PASSTHROUGH     = 4115;
      ENCAPSULATED_POSTSCRIPT    = 4116;

(* Flag returned from QUERYDIBSUPPORT *)

TYPE QDI_ENUM = (QDI__SETDIBITS,   (* 0 *)
                 QDI__GETDIBITS,   (* 1 *)
                 QDI__DIBTOSCREEN, (* 2 *)
                 QDI__STRETCHDIB); (* 3 *)
     QDI_SET = SET OF QDI_ENUM;

CONST QDI_SETDIBITS   = QDI_SET {QDI__SETDIBITS};   (* 1 *)
      QDI_GETDIBITS   = QDI_SET {QDI__GETDIBITS};   (* 2 *)
      QDI_DIBTOSCREEN = QDI_SET {QDI__DIBTOSCREEN}; (* 4 *)
      QDI_STRETCHDIB  = QDI_SET {QDI__STRETCHDIB};  (* 8 *)

(* Spooler Error Codes *)

CONST SP_NOTREPORTED  = 4000h;
      SP_ERROR        = -1;
      SP_APPABORT     = -2;
      SP_USERABORT    = -3;
      SP_OUTOFDISK    = -4;
      SP_OUTOFMEMORY  = -5;

CONST PR_JOBSTATUS = 0;

(* Object Definitions for EnumObjects() *)

TYPE OBJ_ENUM = (OBJ_ERROR,        (*  0 *)
                 OBJ_PEN,          (*  1 *)
                 OBJ_BRUSH,        (*  2 *)
                 OBJ_DC,           (*  3 *)
                 OBJ_METADC,       (*  4 *)
                 OBJ_PAL,          (*  5 *)
                 OBJ_FONT,         (*  6 *)
                 OBJ_BITMAP,       (*  7 *)
                 OBJ_REGION,       (*  8 *)
                 OBJ_METAFILE,     (*  9 *)
                 OBJ_MEMDC,        (* 10 *)
                 OBJ_EXTPEN,       (* 11 *)
                 OBJ_ENHMETADC,    (* 12 *)
                 OBJ_ENHMETAFILE); (* 13 *)

(* xform stuff *)

TYPE MWT_ENUM = (MWT_0,
                 MWT_IDENTITY,       (* 1 *)
                 MWT_LEFTMULTIPLY,   (* 2 *)
                 MWT_RIGHTMULTIPLY); (* 3 *)

CONST  MWT_MIN = MWT_IDENTITY;
       MWT_MAX = MWT_RIGHTMULTIPLY;

TYPE XFORM = RECORD
                 eM11 : FLOAT;
                 eM12 : FLOAT;
                 eM21 : FLOAT;
                 eM22 : FLOAT;
                 eDx  : FLOAT;
                 eDy  : FLOAT;
             END;
     PXFORM = POINTER TO XFORM;

(* Bitmap Header Definition *)

TYPE BITMAP = RECORD
                     bmType       : LONG;  (* must be 0 *)
                     bmWidth      : LONG;
                     bmHeight     : LONG;
                     bmWidthBytes : LONG;
                     bmPlanes     : WORD;
                     bmBitsPixel  : WORD;
                     bmBits       : PBYTE;
              END;
     PBITMAP = POINTER TO BITMAP;

<* PUSH *> <* ALIGNMENT = "1" *>

TYPE RGBTRIPLE = RECORD
                        rgbtBlue  : BYTE;
                        rgbtGreen : BYTE;
                        rgbtRed   : BYTE;
                 END;

<* POP *>

TYPE RGBQUAD = RECORD
                      rgbBlue     : BYTE;
                      rgbGreen    : BYTE;
                      rgbRed      : BYTE;
                      rgbReserved : BYTE;
               END;
    PRGBQUAD = POINTER TO RGBQUAD;

(* Image Color Matching color definitions *)

TYPE LCSCSTYPE = (LCS_CALIBRATED_RGB, (* 0x00000000L *)
                  LCS_DEVICE_RGB,     (* 0x00000001L *)
                  LCS_DEVICE_CMYK);   (* 0x00000002L *)

TYPE LCS_ENUM = (LCS__GM_BUSINESS,     (* 0 *)
                 LCS__GM_GRAPHICS,     (* 1 *)
                 LCS__GM_IMAGES);      (* 2 *)

TYPE LCSGAMUTMATCH = SET OF LCS_ENUM;

CONST LCS_GM_BUSINESS = LCSGAMUTMATCH {LCS__GM_BUSINESS}; (* 0x00000001L *)
      LCS_GM_GRAPHICS = LCSGAMUTMATCH {LCS__GM_GRAPHICS}; (* 0x00000002L *)
      LCS_GM_IMAGES   = LCSGAMUTMATCH {LCS__GM_IMAGES};   (* 0x00000004L *)

(* ICM Defines for results from CheckColorInGamut() *)

TYPE GAMUT_RESULT = BYTE;

CONST CM_OUT_OF_GAMUT = GAMUT_RESULT (255);
      CM_IN_GAMUT     = GAMUT_RESULT (0);

(* Macros to retrieve CMYK values from a COLORREF *)

PROCEDURE GetCValue (cmyk : COLORREF) : BYTE;
PROCEDURE GetMValue (cmyk : COLORREF) : BYTE;
PROCEDURE GetYValue (cmyk : COLORREF) : BYTE;
PROCEDURE GetKValue (cmyk : COLORREF) : BYTE;
PROCEDURE CMYK (c,m,y,k : BYTE) : COLORREF;

TYPE  FXPT16DOT16 = LONG;
     PFXPT16DOT16 = POINTER TO FXPT16DOT16;

      FXPT2DOT30  = LONG;
     PFXPT2DOT30  = POINTER TO FXPT2DOT30;

(* ICM Color Definitions
   The following two structures are used for defining RGB's in terms of
   CIEXYZ. The values are fixed point 16.16.
*)

TYPE CIEXYZ = RECORD
                     ciexyzX : FXPT2DOT30;
                     ciexyzY : FXPT2DOT30;
                     ciexyzZ : FXPT2DOT30;
              END;
    PCIEXYZ = POINTER TO CIEXYZ;

TYPE CIEXYZTRIPLE = RECORD
                           cciexyzRed  : CIEXYZ;
                           ciexyzGreen : CIEXYZ;
                           ciexyzBlue  : CIEXYZ;
                    END;
    PCIEXYZTRIPLE = POINTER TO CIEXYZTRIPLE;

(* The next structures the logical color space. Unlike pens and brushes,
   but like palettes, there is only one way to create a LogColorSpace.
   A pointer to it must be passed, its elements can't be pushed as
   arguments.
*)

TYPE LOGCOLORSPACEA = RECORD
                             lcsSignature  : DWORD;
                             lcsVersion    : DWORD;
                             lcsSize       : DWORD;
                             lcsCSType     : LCSCSTYPE;
                             lcsIntent     : LCSGAMUTMATCH;
                             lcsEndpoints  : CIEXYZTRIPLE;
                             lcsGammaRed   : DWORD;
                             lcsGammaGreen : DWORD;
                             lcsGammaBlue  : DWORD;
                             lcsFilename   : ARRAY [0..MAX_PATH-1] OF CHAR;
                      END;
    PLOGCOLORSPACEA = POINTER TO LOGCOLORSPACEA;

     LOGCOLORSPACEW = RECORD
                             lcsSignature  : DWORD;
                             lcsVersion    : DWORD;
                             lcsSize       : DWORD;
                             lcsCSType     : LCSCSTYPE;
                             lcsIntent     : LCSGAMUTMATCH;
                             lcsEndpoints  : CIEXYZTRIPLE;
                             lcsGammaRed   : DWORD;
                             lcsGammaGreen : DWORD;
                             lcsGammaBlue  : DWORD;
                             lcsFilename   : ARRAY [0..MAX_PATH-1] OF WCHAR;
                      END;
    PLOGCOLORSPACEW = POINTER TO LOGCOLORSPACEW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE LOGCOLORSPACE = LOGCOLORSPACEW;
           PLOGCOLORSPACE = PLOGCOLORSPACEW;
<* ELSE *>
      TYPE LOGCOLORSPACE = LOGCOLORSPACEA;
           PLOGCOLORSPACE = PLOGCOLORSPACEA;
<* END *>

(* structures for defining DIBs *)

TYPE BITMAPCOREHEADER = RECORD
                               bcSize     : DWORD; (* used to get to color table *)
                               bcWidth    : WORD;
                               bcHeight   : WORD;
                               bcPlanes   : WORD;
                               bcBitCount : WORD;
                        END;

(* constants for the biCompression field *)

TYPE BI_ENUM = (BI_RGB,         (* 0L *)
                BI_RLE8,        (* 1L *)
                BI_RLE4,        (* 2L *)
                BI_BITFIELDS);  (* 3L *)

TYPE BITMAPINFOHEADER = RECORD
                               biSize          : DWORD;
                               biWidth         : LONG;
                               biHeight        : LONG;
                               biPlanes        : WORD;
                               biBitCount      : WORD;
                               biCompression   : BI_ENUM;
                               biSizeImage     : DWORD;
                               biXPelsPerMeter : LONG;
                               biYPelsPerMeter : LONG;
                               biClrUsed       : DWORD;
                               biClrImportant  : DWORD;
                        END;
     PBITMAPINFOHEADER = POINTER TO BITMAPINFOHEADER;

TYPE BITMAPV4HEADER = RECORD
                              bV4Size          : DWORD;
                              bV4Width         : LONG;
                              bV4Height        : LONG;
                              bV4Planes        : WORD;
                              bV4BitCount      : WORD;
                              bV4V4Compression : DWORD;
                              bV4SizeImage     : DWORD;
                              bV4XPelsPerMeter : LONG;
                              bV4YPelsPerMeter : LONG;
                              bV4ClrUsed       : DWORD;
                              bV4ClrImportant  : DWORD;
                              bV4RedMask       : DWORD;
                              bV4GreenMask     : DWORD;
                              bV4BlueMask      : DWORD;
                              bV4AlphaMask     : DWORD;
                              bV4CSType        : DWORD;
                              bV4Endpoints     : CIEXYZTRIPLE;
                              bV4GammaRed      : DWORD;
                              bV4GammaGreen    : DWORD;
                              bV4GammaBlue     : DWORD;
                      END;

TYPE BITMAPINFO = RECORD
                         bmpHeader : BITMAPINFOHEADER;
                         bmiColors : ARRAY [0..0] OF RGBQUAD;
                  END;
     PBITMAPINFO = POINTER TO BITMAPINFO;

TYPE BITMAPINFOPARAM = BITMAPINFOHEADER; (* All functions that had BITMAPINFO
                                            params in wingdi.h now have
                                            BITMAPINFOPARAM parameter in
                                            WInGDI.def.
                                            The header field of a structure is
                                            to be passed
                                         *)
     PBITMAPINFOPARAM = POINTER TO BITMAPINFOPARAM;

TYPE BITMAPCOREINFO = RECORD
                             bmciHeader : BITMAPCOREHEADER;
                             bmciColors : ARRAY [0..0] OF RGBTRIPLE;
                      END;

<* PUSH *> <* ALIGNMENT = "2" *>

TYPE BITMAPFILEHEADER = RECORD
                               bfType      : WORD;
                               bfSize      : DWORD;
                               bfReserved1 : WORD;
                               bfReserved2 : WORD;
                               bfOffBits   : DWORD;
                        END;

<* POP *>

PROCEDURE MAKEPOINTS (l : DWORD) : POINTS;

<* IF NOT DEFINED (NOFONTSIG) THEN *>

TYPE FONTSIGNATURE = RECORD
                            fsUsb : ARRAY [0..3] OF DWORD;
                            fsCsb : ARRAY [0..1] OF DWORD;
                     END;
    PFONTSIGNATURE = POINTER TO FONTSIGNATURE;

TYPE CHARSETINFO = RECORD
                          ciCharset : UINT;
                          ciACP     : UINT;
                          fs        : FONTSIGNATURE;
                   END;
    PCHARSETINFO = POINTER TO CHARSETINFO;

TYPE LOCALESIGNATURE = RECORD
                              lsUsb          : ARRAY [0..3] OF DWORD;
                              lsCsbDefault   : ARRAY [0..1] OF DWORD;
                              lsCsbSupported : ARRAY [0..1] OF DWORD;
                       END;

(* Constants for TranslateCharsetInfo *)

TYPE TCI_ENUM = (TCI_0,
                 TCI_SRCCHARSET,   (* 1 *)
                 TCI_SRCCODEPAGE,  (* 2 *)
                 TCI_SRCFONTSIG);  (* 3 *)

<* END *> (* NOT DEFINED (NOFONTSIG) *)

<* IF NOT DEFINED (NOMETAFILE) THEN *>

(* Clipboard Metafile Picture Structure *)

TYPE HANDLETABLE = RECORD
                          objectHandle : ARRAY [0..0] OF HGDIOBJ;
                   END;
    PHANDLETABLE = POINTER TO HANDLETABLE;

TYPE METARECORD = RECORD
                         rdSize     : DWORD;
                         rdFunction : WORD;
                         rdParm     : ARRAY [0..0] OF WORD;
                  END;
    PMETARECORD = POINTER TO METARECORD;

TYPE METAFILEPICT = RECORD
                           mm   : LONG;  (* actually, MM_ENUM *)
                           xExt : LONG;
                           yExt : LONG;
                           hMF  : HMETAFILE;
                    END;
    PMETAFILEPICT = POINTER TO METAFILEPICT;

<* PUSH *> <* ALIGNMENT = "2" *>

TYPE METAHEADER = RECORD
                          mtType         : WORD;
                          mtHeaderSize   : WORD;
                          mtVersion      : WORD;
                          mtSize         : DWORD;
                          mtNoObjects    : WORD;
                          mtMaxRecord    : DWORD;
                          mtNoParameters : WORD;
                  END;
    PMETAHEADER = POINTER TO METAHEADER;   (* UNALIGNED in wingdi.h *)

<* POP *>

(* Enhanced Metafile structures *)

TYPE ENHMETARECORD = RECORD
                            iType : DWORD;                (* Record type EMR_XXX  *)
                            nSize : DWORD;                (* Record size in bytes *)
                            dParm : ARRAY [0..0] OF DWORD; (* Parameters           *)
                     END;
    PENHMETARECORD  = POINTER TO ENHMETARECORD;

TYPE ENHMETAHEADER = RECORD
      iType          : DWORD;   (* Record type EMR_HEADER *)
      nSize          : DWORD;   (* Record size in bytes.  This may be greater *)
                                (* than the sizeof(ENHMETAHEADER). *)
      rclBounds      : RECTL;   (* Inclusive-inclusive bounds in device units *)
      rclFrame       : RECTL;   (* Inclusive-inclusive Picture Frame of metafile in .01 mm units *)
      dSignature     : DWORD;   (* Signature.  Must be ENHMETA_SIGNATURE. *)
      nVersion       : DWORD;   (* Version number *)
      nBytes         : DWORD;   (* Size of the metafile in bytes *)
      nRecords       : DWORD;   (* Number of records in the metafile *)
      nHandles       : WORD;    (* Number of handles in the handle table *)
                                (* Handle index zero is reserved. *)
      sReserved      : WORD;    (* Reserved.  Must be zero. *)
      nDescription   : DWORD;   (* Number of chars in the unicode description string *)
                                (* This is 0 if there is no description string *)
      offDescription : DWORD;   (* Offset to the metafile description record. *)
                                (* This is 0 if there is no description string *)
      nPalEntries    : DWORD;   (* Number of entries in the metafile palette. *)
      szlDevice      : SIZEL;   (* Size of the reference device in pels *)
      szlMillimeters : SIZEL;   (* Size of the reference device in millimeters *)
      cbPixelFormat  : DWORD;   (* Size of PIXELFORMATDESCRIPTOR information *)
                                (* This is 0 if no pixel format is set *)
      offPixelFormat : DWORD;   (* Offset to PIXELFORMATDESCRIPTOR *)
                                (* This is 0 if no pixel format is set *)
      bOpenGL        : DWORD;   (* TRUE if OpenGL commands are present in *)
                                (* the metafile, otherwise FALSE *)

     END;
  PENHMETAHEADER = POINTER TO ENHMETAHEADER;

<* END *> (* NOT DEFINED (NOMETAFILE) *)

(* Values of type PITCH_AND_FAMILY_SET are used in TEXTMETRIC and LOGFONT structures;
   the value is 1 byte long; lower four bits contain pitch information (in different
   formats in mentioned two structures); higher four bits contain font family information
*)

TYPE PITCH_AND_FAMILY_ENUM = (PF__0, PF__1, PF__2, PF__3, PF__4, PF__5, PF__6, PF__7);

<* PUSH *> <* SETSIZE = "1" *>

TYPE PITCH_AND_FAMILY_SET = SET OF PITCH_AND_FAMILY_ENUM;

<* POP *>

TYPE CHARSET_TYPE = BYTE;

<* IF NOT DEFINED (NOTEXTMETRIC) THEN *>

(* tmPitchAndFamily flags *)

CONST TMPF__FIXED_PITCH = PF__0;
      TMPF__VECTOR      = PF__1;
      TMPF__DEVICE      = PF__3;
      TMPF__TRUETYPE    = PF__2;

      TMPF_FIXED_PITCH = PITCH_AND_FAMILY_SET {TMPF__FIXED_PITCH};  (* 1 *)
      TMPF_VECTOR      = PITCH_AND_FAMILY_SET {TMPF__VECTOR};       (* 2 *)
      TMPF_DEVICE      = PITCH_AND_FAMILY_SET {TMPF__DEVICE};       (* 8 *)
      TMPF_TRUETYPE    = PITCH_AND_FAMILY_SET {TMPF__TRUETYPE};     (* 4 *)

(*
** BCHAR definition for APPs
*)

<* IF DEFINED (UNICODE) THEN *>
      TYPE BCHAR = WCHAR;
<* ELSE *>
      TYPE BCHAR = BYTE;
<* END *>

TYPE TEXTMETRICA = RECORD
                          tmHeight           : LONG;
                          tmAscent           : LONG;
                          tmDescent          : LONG;
                          tmInternalLeading  : LONG;
                          tmExternalLeading  : LONG;
                          tmAveCharWidth     : LONG;
                          tmMaxCharWidth     : LONG;
                          tmWeight           : LONG;
                          tmOverhang         : LONG;
                          tmDigitizedAspectX : LONG;
                          tmDigitizedAspectY : LONG;
                          tmFirstChar        : BYTE;
                          tmLastChar         : BYTE;
                          tmDefaultChar      : BYTE;
                          tmBreakChar        : BYTE;
                          tmItalic           : BOOL8;
                          tmUnderlined       : BOOL8;
                          tmStruckOut        : BOOL8;
                          tmPitchAndFamily   : PITCH_AND_FAMILY_SET;
                          tmCharSet          : CHARSET_TYPE;
                   END;
    PTEXTMETRICA = POINTER TO TEXTMETRICA;

TYPE TEXTMETRICW = RECORD
                          tmHeight           : LONG;
                          tmAscent           : LONG;
                          tmDescent          : LONG;
                          tmInternalLeading  : LONG;
                          tmExternalLeading  : LONG;
                          tmAveCharWidth     : LONG;
                          tmMaxCharWidth     : LONG;
                          tmWeight           : LONG;
                          tmOverhang         : LONG;
                          tmDigitizedAspectX : LONG;
                          tmDigitizedAspectY : LONG;
                          tmFirstChar        : WCHAR;
                          tmLastChar         : WCHAR;
                          tmDefaultChar      : WCHAR;
                          tmBreakChar        : WCHAR;
                          tmItalic           : BOOL8;
                          tmUnderlined       : BOOL8;
                          tmStruckOut        : BOOL8;
                          tmPitchAndFamily   : PITCH_AND_FAMILY_SET;
                          tmCharSet          : CHARSET_TYPE;
                     END;
   PTEXTMETRICW = POINTER TO TEXTMETRICW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE TEXTMETRIC  = TEXTMETRICW;
           PTEXTMETRIC = PTEXTMETRICW;
<* ELSE *>
      TYPE TEXTMETRIC  = TEXTMETRICA;
           PTEXTMETRIC = PTEXTMETRICA;
<* END *>

(* ntmFlags field flags *)

TYPE NTM_ENUM = (NTM__ITALIC,     (* 0 *)
                 NTM__UNDERSCORE, (* 1 *)
                 NTM__NEGATIVE,   (* 2 *)
                 NTM__OUTLINE,    (* 3 *)
                 NTM__STRIKEOUT,  (* 4 *)
                 NTM__BOLD,       (* 5 *)
                 NTM__REGULAR);   (* 6 *)
     NTM_SET = SET OF NTM_ENUM;

CONST NTM_ITALIC     = NTM_SET {NTM__ITALIC};     (* 0x01 *)
      NTM_UNDERSCORE = NTM_SET {NTM__UNDERSCORE}; (* 0x02 *)
      NTM_NEGATIVE   = NTM_SET {NTM__NEGATIVE};   (* 0x04 *)
      NTM_OUTLINE    = NTM_SET {NTM__OUTLINE};    (* 0x08 *)
      NTM_STRIKEOUT  = NTM_SET {NTM__STRIKEOUT};  (* 0x10 *)
      NTM_BOLD       = NTM_SET {NTM__BOLD};       (* 0x20 *)
      NTM_REGULAR    = NTM_SET {NTM__REGULAR};    (* 0x40 *)

<* PUSH *> <* ALIGNMENT = "4" *>

TYPE NEWTEXTMETRICA = RECORD
                             tmHeight           : LONG;
                             tmAscent           : LONG;
                             tmDescent          : LONG;
                             tmInternalLeading  : LONG;
                             tmExternalLeading  : LONG;
                             tmAveCharWidth     : LONG;
                             tmMaxCharWidth     : LONG;
                             tmWeight           : LONG;
                             tmOverhang         : LONG;
                             tmDigitizedAspectX : LONG;
                             tmDigitizedAspectY : LONG;
                             tmFirstChar        : BYTE;
                             tmLastChar         : BYTE;
                             tmDefaultChar      : BYTE;
                             tmBreakChar        : BYTE;
                             tmItalic           : BOOL8;
                             tmUnderlined       : BOOL8;
                             tmStruckOut        : BOOL8;
                             tmPitchAndFamily   : PITCH_AND_FAMILY_SET;
                             tmCharSet          : BYTE;
                             ntmFlags           : NTM_SET;
                             ntmSizeEM          : UINT;
                             ntmCellHeight      : UINT;
                             ntmAvgWidth        : UINT;
                      END;
     PNEWTEXTMETRICA = POINTER TO NEWTEXTMETRICA;

TYPE NEWTEXTMETRICW = RECORD
                             tmHeight           : LONG;
                             tmAscent           : LONG;
                             tmDescent          : LONG;
                             tmInternalLeading  : LONG;
                             tmExternalLeading  : LONG;
                             tmAveCharWidth     : LONG;
                             tmMaxCharWidth     : LONG;
                             tmWeight           : LONG;
                             tmOverhang         : LONG;
                             tmDigitizedAspectX : LONG;
                             tmDigitizedAspectY : LONG;
                             tmFirstChar        : WCHAR;
                             tmLastChar         : WCHAR;
                             tmDefaultChar      : WCHAR;
                             tmBreakChar        : WCHAR;
                             tmItalic           : BOOL8;
                             tmUnderlined       : BOOL8;
                             tmStruckOut        : BOOL8;
                             tmPitchAndFamily   : PITCH_AND_FAMILY_SET;
                             tmCharSet          : BYTE;
                             ntmFlags           : NTM_SET;
                             ntmSizeEM          : UINT;
                             ntmCellHeight      : UINT;
                             ntmAvgWidth        : UINT;
                      END;
     PNEWTEXTMETRICW = POINTER TO NEWTEXTMETRICW;

<* POP *>

<* IF DEFINED (UNICODE) THEN *>
      TYPE NEWTEXTMETRIC = NEWTEXTMETRICW;
           PNEWTEXTMETRIC = PNEWTEXTMETRICW;
<* ELSE *>
      TYPE NEWTEXTMETRIC = NEWTEXTMETRICA;
           PNEWTEXTMETRIC = PNEWTEXTMETRICA;
<* END *>

TYPE NEWTEXTMETRICEXA = RECORD
                               ntmTm      : NEWTEXTMETRICA;
                               ntmFontSig : FONTSIGNATURE;
                        END;
     NEWTEXTMETRICEXW = RECORD
                               ntmTm      : NEWTEXTMETRICW;
                               ntmFontSig : FONTSIGNATURE;
                        END;

TYPE PNEWTEXTMETRICEXA = POINTER TO NEWTEXTMETRICEXA;
     PNEWTEXTMETRICEXW = POINTER TO NEWTEXTMETRICEXW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE NEWTEXTMETRICEX = NEWTEXTMETRICEXW;
           PNEWTEXTMETRICEX = PNEWTEXTMETRICEXW;
<* ELSE *>
      TYPE NEWTEXTMETRICEX = NEWTEXTMETRICEXA;
           PNEWTEXTMETRICEX = PNEWTEXTMETRICEXA;
<* END *>

<* END *> (* NOT DEFINED (NOTEXTMETRIC) *)

(* GDI Logical Objects: *)

(* Pel Array *)

TYPE PELARRAY = RECORD
                       paXCount : LONG;
                       paYCount : LONG;
                       paXExt   : LONG;
                       paYExt   : LONG;
                       paRGBs   : BYTE;
                END;

    PPELARRAY = POINTER TO PELARRAY;

(* Brush Styles *)

TYPE BS_ENUM = (BS_SOLID,          (* 0 *)
                BS_NULL,           (* 1 *)
                BS_HATCHED,        (* 2 *)
                BS_PATTERN,        (* 3 *)
                BS_INDEXED,        (* 4 *)
                BS_DIBPATTERN,     (* 5 *)
                BS_DIBPATTERNPT,   (* 6 *)
                BS_PATTERN8X8,     (* 7 *)
                BS_DIBPATTERN8X8,  (* 8 *)
                BS_MONOPATTERN);   (* 0 *)

CONST BS_HOLLOW = BS_NULL;

(* hatch styles *)

TYPE HS_ENUM = (HS_HORIZONTAL,      (*  0 *)      (* ----- *)
                HS_VERTICAL,        (*  1 *)      (* ||||| *)
                HS_FDIAGONAL,       (*  2 *)      (* \\\\\ *)
                HS_BDIAGONAL,       (*  3 *)      (* ///// *)
                HS_CROSS,           (*  4 *)      (* +++++ *)
                HS_DIAGCROSS,       (*  5 *)      (* xxxxx *)
(* only above values are allowed as lpHatch of LOGBRUSH and elpHatch of LOGPEN *)
                HS_FDIAGONAL1,      (*  6 *)
                HS_BDIAGONAL1,      (*  7 *)
                HS_SOLID,           (*  8 *)
                HS_DENSE1,          (*  9 *)
                HS_DENSE2,          (* 10 *)
                HS_DENSE3,          (* 11 *)
                HS_DENSE4,          (* 12 *)
                HS_DENSE5,          (* 13 *)
                HS_DENSE6,          (* 14 *)
                HS_DENSE7,          (* 15 *)
                HS_DENSE8,          (* 16 *)
                HS_NOSHADE,         (* 17 *)
                HS_HALFTONE,        (* 18 *)
                HS_SOLIDCLR,        (* 19 *)
                HS_DITHEREDCLR,     (* 20 *)
                HS_SOLIDTEXTCLR,    (* 21 *)
                HS_DITHEREDTEXTCLR, (* 22 *)
                HS_SOLIDBKCLR,      (* 23 *)
                HS_DITHEREDBKCLR,   (* 24 *)
                HS_API_MAX);        (* 25 *)

(* Logical Brush (or Pattern) *)

TYPE LOGBRUSH = RECORD
                       lbStyle : BS_ENUM;
                       lbColor : COLORREF;
                       lbHatch : LONG;
                END;
     PLOGBRUSH  = POINTER TO LOGBRUSH;
     PATTERN    = LOGBRUSH;
     PPATTERN   = POINTER TO PATTERN;

(* lpHatch is polymorphic; it can get:
   - HBITMAP (handle of loaded bitmap;  lbStyle = BS_PATTERN)
   - HGLOBAL (handle of DIB memory;     lbStyle = BS_DIBPATTERN)
   - PBYTE   (pointer to packed DIB;    lbStyle = BS_DIBPATTERNPT)
   - HS_ENUM (orientation of hatch;     lbStyle = BS_HATCHED)
   (it is ignored otherwise)
*)

(* Pen Styles *)

TYPE PS_ENUM = (PS__0,PS__1,PS__2,PS__3,PS__4,PS__5,PS__6,PS__7,
                PS__8,PS__9,PS__10,PS__11,PS__12,PS__13,PS__14,
                PS__15,PS__16,PS__17,PS__18,PS__19);
     PS_SET = SET OF PS_ENUM;

CONST PS_SOLID        = SYSTEM.CAST (PS_SET, VAL (UINT, 0));
      PS_DASH         = SYSTEM.CAST (PS_SET, VAL (UINT, 1)); (* ------- *)
      PS_DOT          = SYSTEM.CAST (PS_SET, VAL (UINT, 2)); (* ....... *)
      PS_DASHDOT      = SYSTEM.CAST (PS_SET, VAL (UINT, 3)); (* _._._._ *)
      PS_DASHDOTDOT   = SYSTEM.CAST (PS_SET, VAL (UINT, 4)); (* _.._.._ *)
      PS_NULL         = SYSTEM.CAST (PS_SET, VAL (UINT, 5));
      PS_INSIDEFRAME  = SYSTEM.CAST (PS_SET, VAL (UINT, 6));
      PS_USERSTYLE    = SYSTEM.CAST (PS_SET, VAL (UINT, 7));
      PS_ALTERNATE    = SYSTEM.CAST (PS_SET, VAL (UINT, 8));

      PS_STYLE_MASK   = PS_SET {PS__0..PS__3};  (* 0x0000000F *)

(* Extended pen styles *)

CONST PS_ENDCAP_ROUND  = PS_SET {};                (* 0x00000000 *)
      PS_ENDCAP_SQUARE = PS_SET {PS__8};           (* 0x00000100 *)
      PS_ENDCAP_FLAT   = PS_SET {PS__9};           (* 0x00000200 *)
      PS_ENDCAP_MASK   = PS_SET {PS__8..PS__11};   (* 0x00000F00 *)

CONST PS_JOIN_ROUND    = PS_SET {};                (* 0x00000000 *)
      PS_JOIN_BEVEL    = PS_SET {PS__12};          (* 0x00001000 *)
      PS_JOIN_MITER    = PS_SET {PS__13};          (* 0x00002000 *)
      PS_JOIN_MASK     = PS_SET {PS__12..PS__15};  (* 0x0000F000 *)

CONST PS_COSMETIC      = PS_SET {};                (* 0x00000000 *)
      PS_GEOMETRIC     = PS_SET {PS__16};          (* 0x00010000 *)
      PS_TYPE_MASK     = PS_SET {PS__16..PS__19};  (* 0x000F0000 *)

TYPE LOGPEN = RECORD
                     lopnStyle : PS_SET;
                     lopnWidth : POINT;
                     lopnColor : COLORREF
              END;
     PLOGPEN = POINTER TO LOGPEN;

TYPE EXTLOGPEN = RECORD
                        elpPenStyle   : PS_SET;
                        elpWidth      : DWORD;
                        elpBrushStyle : BS_ENUM;
                        elpColor      : COLORREF;
                        elpHatch      : LONG;
                        elpNumEntries : DWORD;
                        elpStyleEntry : ARRAY [0..0] OF DWORD;
                 END;

(* elpHatch is polymorphic; it can get:
   - HBITMAP (handle of loaded bitmap;  elpBrushStyle = BS_PATTERN)
   - HGLOBAL (handle of DIB memory;     elpBrushStyle = BS_DIBPATTERN)
   - PBYTE   (pointer to packed DIB;    elpBrushStyle = BS_DIBPATTERNPT)
   - HS_ENUM (orientation of hatch;     wlpBrushStyle = BS_HATCHED)
   (it is ignored otherwise)
*)

(* palette entry flags *)

TYPE PC_ENUM = (PC__RESERVED,    (* 0 - palette index used for animation *)
                PC__EXPLICIT,    (* 1 - palette index is explicit to device *)
                PC__NOCOLLAPSE); (* 2 - do not match color to system palette *)

<* PUSH *> <* SETSIZE = "1" *>

TYPE PC_SET = SET OF PC_ENUM;

<* POP *>

CONST PC_RESERVED   = PC_SET {PC__RESERVED};   (* 1 *)
      PC_EXPLICIT   = PC_SET {PC__EXPLICIT};   (* 2 *)
      PC_NOCOLLAPSE = PC_SET {PC__NOCOLLAPSE}; (* 4 *)

(* Logical Palette *)

TYPE PALETTEENTRY = RECORD
                           peRed   : BYTE;
                           peGreen : BYTE;
                           peBlue  : BYTE;
                           peFlags : PC_SET;
                    END;
     PPALETTEENTRY = POINTER TO PALETTEENTRY;

TYPE LOGPALETTE = RECORD
                         palVersion    : WORD;
                         palNumEntries : WORD;
                         palPalEntry   : ARRAY [0..0] OF PALETTEENTRY;
                  END;
     PLOGPALETTE = POINTER TO LOGPALETTE;

(* Logical Font *)

CONST LF_FACESIZE     = 32;
      LF_FULLFACESIZE = 64;

CONST DEFAULT_PITCH  = PITCH_AND_FAMILY_SET {PF__0}; (* 1 *)
      FIXED_PITCH    = PITCH_AND_FAMILY_SET {PF__1}; (* 2 *)
      VARIABLE_PITCH = PITCH_AND_FAMILY_SET {PF__2}; (* 4 *)
      MONO_FONT      = PITCH_AND_FAMILY_SET {PF__3}; (* 8 *)

      FF_DONTCARE    = SYSTEM.CAST (PITCH_AND_FAMILY_SET, 0);    (* Don't care or don't know.             *)
      FF_ROMAN       = SYSTEM.CAST (PITCH_AND_FAMILY_SET, 010h); (* Variable stroke width, serifed.       *)
                                                                 (* Times Roman, Century Schoolbook, etc. *)
      FF_SWISS       = SYSTEM.CAST (PITCH_AND_FAMILY_SET, 020h); (* Variable stroke width, sans-serifed.  *)
                                                                 (* Helvetica, Swiss, etc.                *)
      FF_MODERN      = SYSTEM.CAST (PITCH_AND_FAMILY_SET, 030h); (* Constant stroke width, serifed or sans-serifed. *)
                                                                 (* Pica, Elite, Courier, etc. *)
      FF_SCRIPT      = SYSTEM.CAST (PITCH_AND_FAMILY_SET, 040h); (* Cursive, etc.              *)
      FF_DECORATIVE  = SYSTEM.CAST (PITCH_AND_FAMILY_SET, 050h); (* Old English, etc.          *)

(* masks to retrieve pitch or family bits from PITCH_AND_FAMILY_SET *)

CONST PITCH_MASK  = PITCH_AND_FAMILY_SET {PF__0..PF__3};
      FAMILY_MASK = PITCH_AND_FAMILY_SET {PF__4..PF__7};

(* Font Weights *)

TYPE FW_TYPE = LONG;

CONST FW_DONTCARE    = 0;
      FW_THIN        = 100;
      FW_EXTRALIGHT  = 200;
      FW_LIGHT       = 300;
      FW_NORMAL      = 400;
      FW_MEDIUM      = 500;
      FW_SEMIBOLD    = 600;
      FW_BOLD        = 700;
      FW_EXTRABOLD   = 800;
      FW_HEAVY       = 900;

      FW_ULTRALIGHT  = FW_EXTRALIGHT;
      FW_REGULAR     = FW_NORMAL;
      FW_DEMIBOLD    = FW_SEMIBOLD;
      FW_ULTRABOLD   = FW_EXTRABOLD;
      FW_BLACK       = FW_HEAVY;

(* Character set specification *)

CONST ANSI_CHARSET        = VAL (CHARSET_TYPE, 0);
      DEFAULT_CHARSET     = VAL (CHARSET_TYPE, 1);
      SYMBOL_CHARSET      = VAL (CHARSET_TYPE, 2);
      SHIFTJIS_CHARSET    = VAL (CHARSET_TYPE, 128);
      HANGEUL_CHARSET     = VAL (CHARSET_TYPE, 129);
      GB2312_CHARSET      = VAL (CHARSET_TYPE, 134);
      CHINESEBIG5_CHARSET = VAL (CHARSET_TYPE, 136);
      OEM_CHARSET         = VAL (CHARSET_TYPE, 255);

      JOHAB_CHARSET       = VAL (CHARSET_TYPE, 130);
      HEBREW_CHARSET      = VAL (CHARSET_TYPE, 177);
      ARABIC_CHARSET      = VAL (CHARSET_TYPE, 178);
      GREEK_CHARSET       = VAL (CHARSET_TYPE, 161);
      TURKISH_CHARSET     = VAL (CHARSET_TYPE, 162);
      VIETNAMESE_CHARSET  = VAL (CHARSET_TYPE, 163);
      THAI_CHARSET        = VAL (CHARSET_TYPE, 222);
      EASTEUROPE_CHARSET  = VAL (CHARSET_TYPE, 238);
      RUSSIAN_CHARSET     = VAL (CHARSET_TYPE, 204);

      MAC_CHARSET         = VAL (CHARSET_TYPE, 77);
      BALTIC_CHARSET      = VAL (CHARSET_TYPE, 186);

(* Output precision specification *)

<* PUSH *> <* ENUMSIZE = "1" *>

TYPE OUT_PRECIS_ENUM = (OUT_DEFAULT_PRECIS,         (* 0 *)
                        OUT_STRING_PRECIS,          (* 1 *)
                        OUT_CHARACTER_PRECIS,       (* 2 *)
                        OUT_STROKE_PRECIS,          (* 3 *)
                        OUT_TT_PRECIS,              (* 4 *)
                        OUT_DEVICE_PRECIS,          (* 5 *)
                        OUT_RASTER_PRECIS,          (* 6 *)
                        OUT_TT_ONLY_PRECIS,         (* 7 *)
                        OUT_OUTLINE_PRECIS,         (* 8 *)
                        OUT_SCREEN_OUTLINE_PRECIS); (* 9 *)

<* POP *>

(* Clip precision specidication *)

TYPE CLIP_PRECIS_ENUM = (CLIP__0, CLIP__1, CLIP__2, CLIP__3,
                         CLIP__4, CLIP__5, CLIP__6, CLIP__7);

<* PUSH *> <* SETSIZE = "1" *>

TYPE CLIP_PRECIS_SET = SET OF CLIP_PRECIS_ENUM;

 <* POP *>

CONST CLIP_DEFAULT_PRECIS   = SYSTEM.CAST (CLIP_PRECIS_SET, 0);
      CLIP_CHARACTER_PRECIS = SYSTEM.CAST (CLIP_PRECIS_SET, 1);
      CLIP_STROKE_PRECIS    = SYSTEM.CAST (CLIP_PRECIS_SET, 2);

      CLIP_MASK             = CLIP_PRECIS_SET {CLIP__0..CLIP__3};

      CLIP__LH_ANGLES       = CLIP__4;
      CLIP__TT_ALWAYS       = CLIP__5;
      CLIP__EMBEDDED        = CLIP__7;

      CLIP_LH_ANGLES        = CLIP_PRECIS_SET {CLIP__LH_ANGLES}; (* 10h *)
      CLIP_TT_ALWAYS        = CLIP_PRECIS_SET {CLIP__TT_ALWAYS}; (* 20h *)
      CLIP_EMBEDDED         = CLIP_PRECIS_SET {CLIP__EMBEDDED};  (* 80h *)

(* Output quality specification *)

<* PUSH *> <* ENUMSIZE = "1" *>

TYPE QUALITY_ENUM = (DEFAULT_QUALITY,        (* 0 *)
                     DRAFT_QUALITY,          (* 1 *)
                     PROOF_QUALITY,          (* 2 *)
                     NONANTIALIASED_QUALITY, (* 3 *)
                     ANTIALIASED_QUALITY);   (* 4 *)

<* POP *>

TYPE LOGFONTA = RECORD
                       lfHeight          : LONG;
                       lfWidth           : LONG;
                       lfEscapement      : LONG;
                       lfOrientation     : LONG;
                       lfWeight          : FW_TYPE;
                       lfItalic          : BOOL8;
                       lfUnderline       : BOOL8;
                       lfStrikeOut       : BOOL8;
                       lfCharSet         : CHARSET_TYPE;
                       lfOutPrecision    : OUT_PRECIS_ENUM;
                       lfClipPrecision   : CLIP_PRECIS_SET;
                       lfQuality         : QUALITY_ENUM;
                       lfPitchAndFamily  : PITCH_AND_FAMILY_SET;
                       lfFaceName        : ARRAY [0..LF_FACESIZE-1] OF CHAR;
                END;
     PLOGFONTA = POINTER TO LOGFONTA;

     LOGFONTW = RECORD
                       lfHeight          : LONG;
                       lfWidth           : LONG;
                       lfEscapement      : LONG;
                       lfOrientation     : LONG;
                       lfWeight          : FW_TYPE;
                       lfItalic          : BOOL8;
                       lfUnderline       : BOOL8;
                       lfStrikeOut       : BOOL8;
                       lfCharSet         : CHARSET_TYPE;
                       lfOutputPrecision : OUT_PRECIS_ENUM;
                       lfClipPrecision   : CLIP_PRECIS_SET;
                       lfQuality         : QUALITY_ENUM;
                       lfPitchAndFamily  : PITCH_AND_FAMILY_SET;
                       lfFaceName        : ARRAY [0..LF_FACESIZE-1] OF WCHAR;
                END;
     PLOGFONTW = POINTER TO LOGFONTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE LOGFONT  = LOGFONTW;
          PLOGFONT = PLOGFONTW;
<* ELSE *>
      TYPE LOGFONT  = LOGFONTA;
          PLOGFONT = PLOGFONTA;
<* END *>

(* Structure passed to FONTFAMENUMPROC *)

TYPE ENUMLOGFONTA = RECORD
                           elfLogFont  : LOGFONTA;
                           elfFullName : ARRAY [0..LF_FULLFACESIZE-1] OF CHAR;
                           elfStyle    : ARRAY [0..LF_FACESIZE-1]     OF CHAR;
                    END;
     PENUMLOGFONTA = POINTER TO ENUMLOGFONTA;

     ENUMLOGFONTW = RECORD
                           elfLogFont  : LOGFONTW;
                           elfFullName : ARRAY [0..LF_FULLFACESIZE-1] OF WCHAR;
                           elfStyle    : ARRAY [0..LF_FACESIZE-1]     OF WCHAR;
                    END;
    PENUMLOGFONTW = POINTER TO ENUMLOGFONTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  ENUMLOGFONT = ENUMLOGFONTW;
           PENUMLOGFONT = PENUMLOGFONTW;
<* ELSE *>
      TYPE  ENUMLOGFONT = ENUMLOGFONTA;
           PENUMLOGFONT = PENUMLOGFONTA;
<* END *>

TYPE ENUMLOGFONTEXA = RECORD
                         elfLogFont  : LOGFONTA;
                         elfFullName : ARRAY [0..LF_FULLFACESIZE-1] OF BYTE;
                         elfStyle    : ARRAY [0..LF_FACESIZE-1]     OF BYTE;
                         elfScript   : ARRAY [0..LF_FACESIZE-1]     OF BYTE;
                      END;
    PENUMLOGFONTEXA = POINTER TO ENUMLOGFONTEXA;

TYPE ENUMLOGFONTEXW = RECORD
                         elfLogFont  : LOGFONTW;
                         elfFullName : ARRAY [0..LF_FULLFACESIZE-1] OF WCHAR;
                         elfStyle    : ARRAY [0..LF_FACESIZE-1]     OF WCHAR;
                         elfScript   : ARRAY [0..LF_FACESIZE-1]     OF WCHAR;
                      END;
    PENUMLOGFONTEXW = POINTER TO ENUMLOGFONTEXW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE ENUMLOGFONTEX = ENUMLOGFONTEXW;
           PENUMLOGFONTEX = PENUMLOGFONTEXW;
<* ELSE *>
      TYPE ENUMLOGFONTEX = ENUMLOGFONTEXA;
           PENUMLOGFONTEX = PENUMLOGFONTEXA;
<* END *>

TYPE FS_ENUM = (FS__LATIN1,      (* 0 *)
                FS__LATIN2,      (* 1 *)
                FS__CYRILLIC,    (* 2 *)
                FS__GREEK,       (* 3 *)
                FS__TURKISH,     (* 4 *)
                FS__HEBREW,      (* 5 *)
                FS__ARABIC,      (* 6 *)
                FS__BALTIC,      (* 7 *)
                FS__VIETNAMESE,  (* 8 *)
                FS__9,
                FS__10, FS__11,
                FS__12, FS__13,
                FS__14, FS__15,
                FS__THAI,        (* 16 *)
                FS__JISJAPAN,    (* 17 *)
                FS__CHINESESIMP, (* 18 *)
                FS__WANSUNG,     (* 19 *)
                FS__CHINESETRAD, (* 20 *)
                FS__JOHAB,       (* 21 *)
                FS__22, FS__23,
                FS__24, FS__25,
                FS__26, FS__27,
                FS__28, FS__29,
                FS__30,
                FS__SYMBOL);     (* 31 *)
      FS_SET = SET OF FS_ENUM;

CONST FS_LATIN1      = FS_SET {FS__LATIN1};      (* 0x00000001L *)
      FS_LATIN2      = FS_SET {FS__LATIN2};      (* 0x00000002L *)
      FS_CYRILLIC    = FS_SET {FS__CYRILLIC};    (* 0x00000004L *)
      FS_GREEK       = FS_SET {FS__GREEK};       (* 0x00000008L *)
      FS_TURKISH     = FS_SET {FS__TURKISH};     (* 0x00000010L *)
      FS_HEBREW      = FS_SET {FS__HEBREW};      (* 0x00000020L *)
      FS_ARABIC      = FS_SET {FS__ARABIC};      (* 0x00000040L *)
      FS_BALTIC      = FS_SET {FS__BALTIC};      (* 0x00000080L *)
      FS_VIETNAMESE  = FS_SET {FS__VIETNAMESE};  (* 0x00000100L *)
      FS_THAI        = FS_SET {FS__THAI};        (* 0x00010000L *)
      FS_JISJAPAN    = FS_SET {FS__JISJAPAN};    (* 0x00020000L *)
      FS_CHINESESIMP = FS_SET {FS__CHINESESIMP}; (* 0x00040000L *)
      FS_WANSUNG     = FS_SET {FS__WANSUNG};     (* 0x00080000L *)
      FS_CHINESETRAD = FS_SET {FS__CHINESETRAD}; (* 0x00100000L *)
      FS_JOHAB       = FS_SET {FS__JOHAB};       (* 0x00200000L *)
      FS_SYMBOL      = FS_SET {FS__SYMBOL};      (* 0x80000000L *)

(* indices in PANOSE structure *)

TYPE PANOSE_INDEX_ENUM = (PAN_FAMILYTYPE_INDEX,      (* 0 *)
                          PAN_SERIFSTYLE_INDEX,      (* 1 *)
                          PAN_WEIGHT_INDEX,          (* 2 *)
                          PAN_PROPORTION_INDEX,      (* 3 *)
                          PAN_CONTRAST_INDEX,        (* 4 *)
                          PAN_STROKEVARIATION_INDEX, (* 5 *)
                          PAN_ARMSTYLE_INDEX,        (* 6 *)
                          PAN_LETTERFORM_INDEX,      (* 7 *)
                          PAN_MIDLINE_INDEX,         (* 8 *)
                          PAN_XHEIGHT_INDEX);        (* 9 *)

CONST PANOSE_COUNT = 10; (* total number of fields *)

TYPE PAN_TYPE = BYTE;

TYPE PANOSE = RECORD
                     bFamilyType      : PAN_TYPE;
                     bSerifStyle      : PAN_TYPE;
                     bWeight          : PAN_TYPE;
                     bProportion      : PAN_TYPE;
                     bContrast        : PAN_TYPE;
                     bStrokeVariation : PAN_TYPE;
                     bArmStyle        : PAN_TYPE;
                     bLetterform      : PAN_TYPE;
                     bMidline         : PAN_TYPE;
                     bXHeight         : PAN_TYPE;
              END;

CONST

(* General constants *)

PAN_ANY                         = PAN_TYPE ( 0);         (* Any               *)
PAN_NO_FIT                      = PAN_TYPE ( 1);         (* No Fit            *)
PAN_CULTURE_LATIN               = PAN_TYPE ( 0);

(* bFamilyType values *)

PAN_FAMILY_TEXT_DISPLAY         = PAN_TYPE ( 2); (* Text and Display         *)
PAN_FAMILY_SCRIPT               = PAN_TYPE ( 3); (* Script                   *)
PAN_FAMILY_DECORATIVE           = PAN_TYPE ( 4); (* Decorative               *)
PAN_FAMILY_PICTORIAL            = PAN_TYPE ( 5); (* Pictorial                *)

(* bSerifStyle values *)

PAN_SERIF_COVE                  = PAN_TYPE ( 2); (* Cove                     *)
PAN_SERIF_OBTUSE_COVE           = PAN_TYPE ( 3); (* Obtuse Cove              *)
PAN_SERIF_SQUARE_COVE           = PAN_TYPE ( 4); (* Square Cove              *)
PAN_SERIF_OBTUSE_SQUARE_COVE    = PAN_TYPE ( 5); (* Obtuse Square Cove       *)
PAN_SERIF_SQUARE                = PAN_TYPE ( 6); (* Square                   *)
PAN_SERIF_THIN                  = PAN_TYPE ( 7); (* Thin                     *)
PAN_SERIF_BONE                  = PAN_TYPE ( 8); (* Bone                     *)
PAN_SERIF_EXAGGERATED           = PAN_TYPE ( 9); (* Exaggerated              *)
PAN_SERIF_TRIANGLE              = PAN_TYPE (10); (* Triangle                 *)
PAN_SERIF_NORMAL_SANS           = PAN_TYPE (11); (* Normal Sans              *)
PAN_SERIF_OBTUSE_SANS           = PAN_TYPE (12); (* Obtuse Sans              *)
PAN_SERIF_PERP_SANS             = PAN_TYPE (13); (* Prep Sans                *)
PAN_SERIF_FLARED                = PAN_TYPE (14); (* Flared                   *)
PAN_SERIF_ROUNDED               = PAN_TYPE (15); (* Rounded                  *)

(* bWeight values *)

PAN_WEIGHT_VERY_LIGHT           = PAN_TYPE ( 2); (* Very Light               *)
PAN_WEIGHT_LIGHT                = PAN_TYPE ( 3); (* Light                    *)
PAN_WEIGHT_THIN                 = PAN_TYPE ( 4); (* Thin                     *)
PAN_WEIGHT_BOOK                 = PAN_TYPE ( 5); (* Book                     *)
PAN_WEIGHT_MEDIUM               = PAN_TYPE ( 6); (* Medium                   *)
PAN_WEIGHT_DEMI                 = PAN_TYPE ( 7); (* Demi                     *)
PAN_WEIGHT_BOLD                 = PAN_TYPE ( 8); (* Bold                     *)
PAN_WEIGHT_HEAVY                = PAN_TYPE ( 9); (* Heavy                    *)
PAN_WEIGHT_BLACK                = PAN_TYPE (10); (* Black                    *)
PAN_WEIGHT_NORD                 = PAN_TYPE (11); (* Nord                     *)

(* bProportion values *)

PAN_PROP_OLD_STYLE              = PAN_TYPE ( 2); (* Old Style                *)
PAN_PROP_MODERN                 = PAN_TYPE ( 3); (* Modern                   *)
PAN_PROP_EVEN_WIDTH             = PAN_TYPE ( 4); (* Even Width               *)
PAN_PROP_EXPANDED               = PAN_TYPE ( 5); (* Expanded                 *)
PAN_PROP_CONDENSED              = PAN_TYPE ( 6); (* Condensed                *)
PAN_PROP_VERY_EXPANDED          = PAN_TYPE ( 7); (* Very Expanded            *)
PAN_PROP_VERY_CONDENSED         = PAN_TYPE ( 8); (* Very Condensed           *)
PAN_PROP_MONOSPACED             = PAN_TYPE ( 9); (* Monospaced               *)

(* bContrast values *)

PAN_CONTRAST_NONE               = PAN_TYPE ( 2); (* None                     *)
PAN_CONTRAST_VERY_LOW           = PAN_TYPE ( 3); (* Very Low                 *)
PAN_CONTRAST_LOW                = PAN_TYPE ( 4); (* Low                      *)
PAN_CONTRAST_MEDIUM_LOW         = PAN_TYPE ( 5); (* Medium Low               *)
PAN_CONTRAST_MEDIUM             = PAN_TYPE ( 6); (* Medium                   *)
PAN_CONTRAST_MEDIUM_HIGH        = PAN_TYPE ( 7); (* Mediim High              *)
PAN_CONTRAST_HIGH               = PAN_TYPE ( 8); (* High                     *)
PAN_CONTRAST_VERY_HIGH          = PAN_TYPE ( 9); (* Very High                *)

(* bStrokeVariation values *)

PAN_STROKE_GRADUAL_DIAG         = PAN_TYPE ( 2); (* Gradual/Diagonal         *)
PAN_STROKE_GRADUAL_TRAN         = PAN_TYPE ( 3); (* Gradual/Transitional     *)
PAN_STROKE_GRADUAL_VERT         = PAN_TYPE ( 4); (* Gradual/Vertical         *)
PAN_STROKE_GRADUAL_HORZ         = PAN_TYPE ( 5); (* Gradual/Horizontal       *)
PAN_STROKE_RAPID_VERT           = PAN_TYPE ( 6); (* Rapid/Vertical           *)
PAN_STROKE_RAPID_HORZ           = PAN_TYPE ( 7); (* Rapid/Horizontal         *)
PAN_STROKE_INSTANT_VERT         = PAN_TYPE ( 8); (* Instant/Vertical         *)

(* bArmStyle values *)

PAN_STRAIGHT_ARMS_HORZ          = PAN_TYPE ( 2); (* Straight Arms/Horizontal    *)
PAN_STRAIGHT_ARMS_WEDGE         = PAN_TYPE ( 3); (* Straight Arms/Wedge         *)
PAN_STRAIGHT_ARMS_VERT          = PAN_TYPE ( 4); (* Straight Arms/Vertical      *)
PAN_STRAIGHT_ARMS_SINGLE_SERIF  = PAN_TYPE ( 5); (* Straight Arms/Single-Serif  *)
PAN_STRAIGHT_ARMS_DOUBLE_SERIF  = PAN_TYPE ( 6); (* Straight Arms/Double-Serif  *)
PAN_BENT_ARMS_HORZ              = PAN_TYPE ( 7); (* Non-Straight Arms/Horizontal*)
PAN_BENT_ARMS_WEDGE             = PAN_TYPE ( 8); (* Non-Straight Arms/Wedge     *)
PAN_BENT_ARMS_VERT              = PAN_TYPE ( 9); (* Non-Straight Arms/Vertical  *)
PAN_BENT_ARMS_SINGLE_SERIF      = PAN_TYPE (10); (* Non-Straight Arms/Single-Serif*)
PAN_BENT_ARMS_DOUBLE_SERIF      = PAN_TYPE (11); (* Non-Straight Arms/Double-Serif*)

(* bLetterform values *)

PAN_LETT_NORMAL_CONTACT         = PAN_TYPE ( 2); (* Normal/Contact           *)
PAN_LETT_NORMAL_WEIGHTED        = PAN_TYPE ( 3); (* Normal/Weighted          *)
PAN_LETT_NORMAL_BOXED           = PAN_TYPE ( 4); (* Normal/Boxed             *)
PAN_LETT_NORMAL_FLATTENED       = PAN_TYPE ( 5); (* Normal/Flattened         *)
PAN_LETT_NORMAL_ROUNDED         = PAN_TYPE ( 6); (* Normal/Rounded           *)
PAN_LETT_NORMAL_OFF_CENTER      = PAN_TYPE ( 7); (* Normal/Off Center        *)
PAN_LETT_NORMAL_SQUARE          = PAN_TYPE ( 8); (* Normal/Square            *)
PAN_LETT_OBLIQUE_CONTACT        = PAN_TYPE ( 9); (* Oblique/Contact          *)
PAN_LETT_OBLIQUE_WEIGHTED       = PAN_TYPE (10); (* Oblique/Weighted         *)
PAN_LETT_OBLIQUE_BOXED          = PAN_TYPE (11); (* Oblique/Boxed            *)
PAN_LETT_OBLIQUE_FLATTENED      = PAN_TYPE (12); (* Oblique/Flattened        *)
PAN_LETT_OBLIQUE_ROUNDED        = PAN_TYPE (13); (* Oblique/Rounded          *)
PAN_LETT_OBLIQUE_OFF_CENTER     = PAN_TYPE (14); (* Oblique/Off Center       *)
PAN_LETT_OBLIQUE_SQUARE         = PAN_TYPE (15); (* Oblique/Square           *)

(* bMidline values *)

PAN_MIDLINE_STANDARD_TRIMMED    = PAN_TYPE ( 2); (* Standard/Trimmed         *)
PAN_MIDLINE_STANDARD_POINTED    = PAN_TYPE ( 3); (* Standard/Pointed         *)
PAN_MIDLINE_STANDARD_SERIFED    = PAN_TYPE ( 4); (* Standard/Serifed         *)
PAN_MIDLINE_HIGH_TRIMMED        = PAN_TYPE ( 5); (* High/Trimmed             *)
PAN_MIDLINE_HIGH_POINTED        = PAN_TYPE ( 6); (* High/Pointed             *)
PAN_MIDLINE_HIGH_SERIFED        = PAN_TYPE ( 7); (* High/Serifed             *)
PAN_MIDLINE_CONSTANT_TRIMMED    = PAN_TYPE ( 8); (* Constant/Trimmed         *)
PAN_MIDLINE_CONSTANT_POINTED    = PAN_TYPE ( 9); (* Constant/Pointed         *)
PAN_MIDLINE_CONSTANT_SERIFED    = PAN_TYPE (10); (* Constant/Serifed         *)
PAN_MIDLINE_LOW_TRIMMED         = PAN_TYPE (11); (* Low/Trimmed              *)
PAN_MIDLINE_LOW_POINTED         = PAN_TYPE (12); (* Low/Pointed              *)
PAN_MIDLINE_LOW_SERIFED         = PAN_TYPE (13); (* Low/Serifed              *)

(* bXHeight values *)

PAN_XHEIGHT_CONSTANT_SMALL      = PAN_TYPE ( 2); (* Constant/Small           *)
PAN_XHEIGHT_CONSTANT_STD        = PAN_TYPE ( 3); (* Constant/Standard        *)
PAN_XHEIGHT_CONSTANT_LARGE      = PAN_TYPE ( 4); (* Constant/Large           *)
PAN_XHEIGHT_DUCKING_SMALL       = PAN_TYPE ( 5); (* Ducking/Small            *)
PAN_XHEIGHT_DUCKING_STD         = PAN_TYPE ( 6); (* Ducking/Standard         *)
PAN_XHEIGHT_DUCKING_LARGE       = PAN_TYPE ( 7); (* Ducking/Large            *)

(* The extended logical font       *)
(* An extension of the ENUMLOGFONT *)

CONST ELF_VENDOR_SIZE   = 4;
      ELF_VERSION       = 0;
      ELF_CULTURE_LATIN = 0;

TYPE EXTLOGFONTA = RECORD
                           elfLogFont   : LOGFONTA;
                           elfFullName  : ARRAY [0..LF_FULLFACESIZE-1] OF CHAR;
                           elfStyle     : ARRAY [0..LF_FACESIZE-1]     OF CHAR;
                           elfVersion   : DWORD;     (* 0 for the first release of NT *)
                           elfStyleSize : DWORD;
                           elfMatch     : DWORD;
                           elfReserved  : DWORD;
                           elfVendorId  : ARRAY [0..ELF_VENDOR_SIZE-1] OF BYTE;
                           elfCulture   : DWORD;     (* 0 for Latin  *)
                           elfPanose    : PANOSE;
                   END;
     PEXTLOGFONTA = POINTER TO EXTLOGFONTA;

     EXTLOGFONTW = RECORD
                           elfLogFont   : LOGFONTW;
                           elfFullName  : ARRAY [0..LF_FULLFACESIZE-1] OF WCHAR;
                           elfStyle     : ARRAY [0..LF_FACESIZE-1]     OF WCHAR;
                           elfVersion   : DWORD;     (* 0 for the first release of NT *)
                           elfStyleSize : DWORD;
                           elfMatch     : DWORD;
                           elfReserved  : DWORD;
                           elfVendorId  : ARRAY [0..ELF_VENDOR_SIZE-1] OF BYTE;
                           elfCulture   : DWORD;     (* 0 for Latin  *)
                           elfPanose    : PANOSE;
                   END;
     PEXTLOGFONTW = POINTER TO EXTLOGFONTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE EXTLOGFONT  = EXTLOGFONTW;
           PEXTLOGFONT = POINTER TO EXTLOGFONTW;
<* ELSE *>
      TYPE EXTLOGFONT  = EXTLOGFONTA;
           PEXTLOGFONT = POINTER TO EXTLOGFONTA;
<* END *>

(* EnumFonts Masks *)

TYPE ENUMFONT_ENUM = (RASTER__FONTTYPE,      (*  0 *)
                      DEVICE__FONTTYPE,      (*  1 *)
                      TRUETYPE__FONTTYPE,    (*  2 *)
                      FT__3, FT__4, FT__5,
                      FT__6, FT__7,
                      BOLD__FONTTYPE,        (*  8 *)
                      ITALIC__FONTTYPE,      (*  9 *)
                      REGULAR__FONTTYPE,     (* 10 *)
                      FT__11, FT__12,
                      SCREEN__FONTTYPE,      (* 13 *)
                      PRINTER__FONTTYPE,     (* 14 *)
                      SIMULATED__FONTTYPE);  (* 15 *)

     ENUMFONT_SET = SET OF ENUMFONT_ENUM;

CONST RASTER_FONTTYPE    = ENUMFONT_SET {RASTER__FONTTYPE};    (* 0x0001 *)
      DEVICE_FONTTYPE    = ENUMFONT_SET {DEVICE__FONTTYPE};    (* 0x0002 *)
      TRUETYPE_FONTTYPE  = ENUMFONT_SET {TRUETYPE__FONTTYPE};  (* 0x0004 *)

(* Theese following only apply to Choose Font dialog box *)

CONST BOLD_FONTTYPE      = ENUMFONT_SET {BOLD__FONTTYPE};      (* 0x0100 *)
      ITALIC_FONTTYPE    = ENUMFONT_SET {ITALIC__FONTTYPE};    (* 0x0200 *)
      REGULAR_FONTTYPE   = ENUMFONT_SET {REGULAR__FONTTYPE};   (* 0x0400 *)
      SCREEN_FONTTYPE    = ENUMFONT_SET {SCREEN__FONTTYPE};    (* 0x2000 *)
      PRINTER_FONTTYPE   = ENUMFONT_SET {PRINTER__FONTTYPE};   (* 0x4000 *)
      SIMULATED_FONTTYPE = ENUMFONT_SET {SIMULATED__FONTTYPE}; (* 0x8000 *)

(* following six procedures are in run-time code *)

PROCEDURE RGB          (r,g,b : BYTE) : COLORREF;
PROCEDURE PALETTERGB   (r,g,b : BYTE) : COLORREF;
PROCEDURE PALETTEINDEX (i : BYTE)     : COLORREF;

PROCEDURE GetRValue (rgb : COLORREF) : BYTE;
PROCEDURE GetGValue (rgb : COLORREF) : BYTE;
PROCEDURE GetBValue (rgb : COLORREF) : BYTE;

(* Background Modes *)

TYPE BKMODE_ENUM = (BKMODE_ERROR,
                    TRANSPARENT,     (* 1 *)
                    OPAQUE);         (* 2 *)
CONST BKMODE_LAST = OPAQUE;

(* Graphics Modes *)

TYPE GM_ENUM = (GM_ERROR,
                GM_COMPATIBLE, (* 1 *)
                GM_ADVANCED);  (* 2 *)
CONST GM_LAST = GM_ADVANCED;

(* PolyDraw and GetPath point types *)

TYPE PT_ENUM = (PT__CLOSEFIGURE,
                PT_1, PT__2, PT__3);

<* PUSH *> <* SETSIZE = "1" *>

TYPE PT_SET = SET OF PT_ENUM;

<* POP *>

CONST PT_CLOSEFIGURE = PT_SET {PT__CLOSEFIGURE}; (* 1 *)
      PT_LINETO      = SYSTEM.CAST (PT_SET, 2);
      PT_BEZIERTO    = SYSTEM.CAST (PT_SET, 4);
      PT_MOVETO      = SYSTEM.CAST (PT_SET, 6);

(* Mapping Modes *)
TYPE MM_ENUM = (MM_ERROR,       (* 0 *)
                MM_TEXT,        (* 1 *)
                MM_LOMETRIC,    (* 2 *)
                MM_HIMETRIC,    (* 3 *)
                MM_LOENGLISH,   (* 4 *)
                MM_HIENGLISH,   (* 5 *)
                MM_TWIPS,       (* 6 *)
                MM_ISOTROPIC,   (* 7 *)
                MM_ANISOTROPIC);(* 8 *)

(* Min and Max Mapping Mode values *)
          CONST MM_MIN            = MM_TEXT;
                MM_MAX            = MM_ANISOTROPIC;
                MM_MAX_FIXEDSCALE = MM_TWIPS;


(* Coordinate Modes *)

TYPE COORDMODE_ENUM = (COORDMODE_ERROR,
                       ABSOLUTE,         (* 1 *)
                       RELATIVE);        (* 2 *)

(* Stock Logical Objects *)

TYPE STOCK_ENUM = (WHITE_BRUSH,         (* 0 *)
                   LTGRAY_BRUSH,        (* 1 *)
                   GRAY_BRUSH,          (* 2 *)
                   DKGRAY_BRUSH,        (* 3 *)
                   BLACK_BRUSH,         (* 4 *)
                   NULL_BRUSH,          (* 5 *)
                   WHITE_PEN,           (* 6 *)
                   BLACK_PEN,           (* 7 *)
                   NULL_PEN,            (* 8 *)
                   STOCK_9,
                   OEM_FIXED_FONT,      (* 10 *)
                   ANSI_FIXED_FONT,     (* 11 *)
                   ANSI_VAR_FONT,       (* 12 *)
                   SYSTEM_FONT,         (* 13 *)
                   DEVICE_DEFAULT_FONT, (* 14 *)
                   DEFAULT_PALETTE,     (* 15 *)
                   SYSTEM_FIXED_FONT,   (* 16 *)
                   DEFAULT_GUI_FONT);   (* 17 *)

CONST STOCK_LAST    = DEFAULT_GUI_FONT;
      HOLLOW_BRUSH  = NULL_BRUSH;

CONST CLR_INVALID = 0FFFFFFFFh;

TYPE AD_ENUM = (AD_ERROR,            (* 0 *)
                AD_COUNTERCLOCKWISE, (* 1 *)
                AD_CLOCKWISE);       (* 2 *)

(* Device Parameters for GetDeviceCaps() (to be casted to different types) *)

CONST DRIVERVERSION =  0;    (* Device driver version                    *)

CONST TECHNOLOGY    =  2;    (* Device classification *)
      HORZSIZE      =  4;    (* Horizontal size in millimeters           *)
      VERTSIZE      =  6;    (* Vertical size in millimeters             *)
      HORZRES       =  8;    (* Horizontal width in pixels               *)
      VERTRES       = 10;    (* Vertical width in pixels                 *)
      BITSPIXEL     = 12;    (* Number of bits per pixel                 *)
      PLANES        = 14;    (* Number of planes                         *)
      NUMBRUSHES    = 16;    (* Number of brushes the device has         *)
      NUMPENS       = 18;    (* Number of pens the device has            *)
      NUMMARKERS    = 20;    (* Number of markers the device has         *)
      NUMFONTS      = 22;    (* Number of fonts the device has           *)
      NUMCOLORS     = 24;    (* Number of colors the device supports     *)
      PDEVICESIZE   = 26;    (* Size required for device descriptor      *)
      CURVECAPS     = 28;    (* Curve capabilities *)
      LINECAPS      = 30;    (* Line capabilities *)
      POLYGONALCAPS = 32;    (* Polygonal capabilities *)
      TEXTCAPS      = 34;    (* Text capabilities *)
      CLIPCAPS      = 36;    (* Clipping capabilities *)
      RASTERCAPS    = 38;    (* Bitblt capabilities *)
      ASPECTX       = 40;    (* Length of the X leg                      *)
      ASPECTY       = 42;    (* Length of the Y leg                      *)
      ASPECTXY      = 44;    (* Length of the hypotenuse                 *)

      LOGPIXELSX    = 88;    (* Logical pixels/inch in X                 *)
      LOGPIXELSY    = 90;    (* Logical pixels/inch in Y                 *)

      SIZEPALETTE   = 104;   (* Number of entries in physical palette    *)
      NUMRESERVED   = 106;   (* Number of reserved entries in palette    *)
      COLORRES      = 108;   (* Actual color resolution                  *)

(* Printing related DeviceCaps. These replace the appropriate Escapes *)

      PHYSICALWIDTH   = 110; (* Physical Width in device units   *)
      PHYSICALHEIGHT  = 111; (* Physical Height in device units  *)
      PHYSICALOFFSETX = 112; (* Physical Printable Area x margin *)
      PHYSICALOFFSETY = 113; (* Physical Printable Area y margin *)
      SCALINGFACTORX  = 114; (* Scaling factor x                 *)
      SCALINGFACTORY  = 115; (* Scaling factor y                 *)

(* Display driver specific *)

CONST VREFRESH        = 116;  (* Current vertical refresh rate of the     *)
                              (* display device (for displays only) in Hz *)
      DESKTOPVERTRES  = 117;  (* Horizontal width of entire desktop in    *)
                              (* pixels                                   *)
      DESKTOPHORZRES  = 118;  (* Vertical height of entire desktop in     *)
                              (* pixels                                   *)
      BLTALIGNMENT    = 119;  (* Preferred blt alignment                  *)

<* IF NOT DEFINED (NOGDICAPMASKS) THEN *>

(* Device Technologies *)

TYPE DT_ENUM = (DT_PLOTTER,    (* 0 - Vector plotter                   *)
                DT_RASDISPLAY, (* 1 - Raster display                   *)
                DT_RASPRINTER, (* 2 - Raster printer                   *)
                DT_RASCAMERA,  (* 3 - Raster camera                    *)
                DT_CHARSTREAM, (* 4 - Character-stream, PLP            *)
                DT_METAFILE,   (* 5 - Metafile, VDM                    *)
                DT_DISPFILE);  (* 6 - Display-file                     *)

(* Curve Capabilities *)

TYPE CC_ENUM = (CC__CIRCLES,       (* 0; Can do circles           *)
                CC__PIE,           (* 1; Can do pie wedges        *)
                CC__CHORD,         (* 2; Can do chord arcs        *)
                CC__ELLIPSES,      (* 3; Can do ellipses          *)
                CC__WIDE,          (* 4; Can do wide lines        *)
                CC__STYLED,        (* 5; Can do styled lines      *)
                CC__WIDESTYLED,    (* 6; Can do wide styled lines *)
                CC__INTERIORS,     (* 7; Can do interiors         *)
                CC__ROUNDRECT);    (* 8; Can do round rectangles  *)

     CC_SET = SET OF CC_ENUM;

CONST CC_NONE       = CC_SET {};               (*   0; Curves not supported *)
      CC_CIRCLES    = CC_SET {CC__CIRCLES};    (*   1 *)
      CC_PIE        = CC_SET {CC__PIE};        (*   2 *)
      CC_CHORD      = CC_SET {CC__CHORD};      (*   4 *)
      CC_ELLIPSES   = CC_SET {CC__ELLIPSES};   (*   8 *)
      CC_WIDE       = CC_SET {CC__WIDE};       (*  16 *)
      CC_STYLED     = CC_SET {CC__STYLED};     (*  32 *)
      CC_WIDESTYLED = CC_SET {CC__WIDESTYLED}; (*  64 *)
      CC_INTERIORS  = CC_SET {CC__INTERIORS};  (* 128 *)
      CC_ROUNDRECT  = CC_SET {CC__ROUNDRECT};  (* 256 *)

(* Line Capabilities *)

TYPE LC_ENUM = (LC__0,
                LC__POLYLINE,      (* 1 - Can do polylines         *)
                LC__MARKER,        (* 2 - Can do markers           *)
                LC__POLYMARKER,    (* 3 - Can do polymarkers       *)
                LC__WIDE,          (* 4 - Can do wide lines        *)
                LC__STYLED,        (* 5 - Can do styled lines      *)
                LC__WIDESTYLED,    (* 6 - Can do wide styled lines *)
                LC__INTERIORS);    (* 7 - Can do interiors         *)

     LC_SET = SET OF LC_ENUM;

CONST LC_NONE       = LC_SET {};                (* 0 - Lines not supported *)
      LC_POLYLINE   = LC_SET {LC__POLYLINE   }; (* 2   *)
      LC_MARKER     = LC_SET {LC__MARKER     }; (* 4   *)
      LC_POLYMARKER = LC_SET {LC__POLYMARKER }; (* 8   *)
      LC_WIDE       = LC_SET {LC__WIDE       }; (* 16  *)
      LC_STYLED     = LC_SET {LC__STYLED     }; (* 32  *)
      LC_WIDESTYLED = LC_SET {LC__WIDESTYLED }; (* 64  *)
      LC_INTERIORS  = LC_SET {LC__INTERIORS  }; (* 128 *)

(* Polygonal Capabilities *)

TYPE PC__ENUM = (PC__POLYGON,        (* 0 - Can do polygons            *)
                 PC__RECTANGLE,      (* 1 - Can do rectangles          *)
                 PC__WINDPOLYGON,    (* 2 - Can do winding polygons    *)
                 PC__SCANLINE,       (* 3 - Can do scanlines           *)
                 PC__WIDE,           (* 4 - Can do wide borders        *)
                 PC__STYLED,         (* 5 - Can do styled borders      *)
                 PC__WIDESTYLED,     (* 6 - Can do wide styled borders *)
                 PC__INTERIORS,      (* 7 - Can do interiors           *)
                 PC__POLYPOLYGON,    (* 8 - Can do polypolygons        *)
                 PC__PATHS);         (* 9 - Can do paths               *)

     PC__SET = SET OF PC__ENUM;

CONST PC__TRAPEZOID = PC__WINDPOLYGON; (* Can do trapezoids  *)

      PC_NONE         = PC__SET {};                (*   0 *)
      PC_POLYGON      = PC__SET {PC__POLYGON    }; (*   1 *)
      PC_RECTANGLE    = PC__SET {PC__RECTANGLE  }; (*   2 *)
      PC_WINDPOLYGON  = PC__SET {PC__WINDPOLYGON}; (*   4 *)
      PC_TRAPEZOID    = PC__SET {PC__TRAPEZOID  }; (*   4 *)
      PC_SCANLINE     = PC__SET {PC__SCANLINE   }; (*   8 *)
      PC_WIDE         = PC__SET {PC__WIDE       }; (*  16 *)
      PC_STYLED       = PC__SET {PC__STYLED     }; (*  32 *)
      PC_WIDESTYLED   = PC__SET {PC__WIDESTYLED }; (*  64 *)
      PC_INTERIORS    = PC__SET {PC__INTERIORS  }; (* 128 *)

(* Clipping Capabilities *)

TYPE CP_ENUM = (CP_NONE,      (* 0  - No clipping of output               *)
                CP_RECTANGLE, (* 1  - Output clipped to rects             *)
                CP_REGION);   (* 2  - Output clipped to region (obsolete) *)

(* Text Capabilities *)

TYPE TC_ENUM = (TC__OP_CHARACTER, (*  0 Can do OutputPrecision   CHARACTER      *)
                TC__OP_STROKE,    (*  1 Can do OutputPrecision   STROKE         *)
                TC__CP_STROKE,    (*  2 Can do ClipPrecision     STROKE         *)
                TC__CR_90,        (*  3 Can do CharRotAbility    90             *)
                TC__CR_ANY,       (*  4 Can do CharRotAbility    ANY            *)
                TC__SF_X_YINDEP,  (*  5 Can do ScaleFreedom      X_YINDEPENDENT *)
                TC__SA_DOUBLE,    (*  6 Can do ScaleAbility      DOUBLE         *)
                TC__SA_INTEGER,   (*  7 Can do ScaleAbility      INTEGER        *)
                TC__SA_CONTIN,    (*  8 Can do ScaleAbility      CONTINUOUS     *)
                TC__EA_DOUBLE,    (*  9 Can do EmboldenAbility   DOUBLE         *)
                TC__IA_ABLE,      (* 10 Can do ItalisizeAbility  ABLE           *)
                TC__UA_ABLE,      (* 11 Can do UnderlineAbility  ABLE           *)
                TC__SO_ABLE,      (* 12 Can do StrikeOutAbility  ABLE           *)
                TC__RA_ABLE,      (* 13 Can do RasterFontAble    ABLE           *)
                TC__VA_ABLE,      (* 14 Can do VectorFontAble    ABLE           *)
                TC__RESERVED,     (* 15 *)
                TC__SCROLLBLT);   (* 16 do text scroll with blt                 *)

           TC_SET = SET OF TC_ENUM;

CONST TC_OP_CHARACTER  = TC_SET {TC__OP_CHARACTER}; (* 0x00000001 *)
      TC_OP_STROKE     = TC_SET {TC__OP_STROKE   }; (* 0x00000002 *)
      TC_CP_STROKE     = TC_SET {TC__CP_STROKE   }; (* 0x00000004 *)
      TC_CR_90         = TC_SET {TC__CR_90       }; (* 0x00000008 *)
      TC_CR_ANY        = TC_SET {TC__CR_ANY      }; (* 0x00000010 *)
      TC_SF_X_YINDEP   = TC_SET {TC__SF_X_YINDEP }; (* 0x00000020 *)
      TC_SA_DOUBLE     = TC_SET {TC__SA_DOUBLE   }; (* 0x00000040 *)
      TC_SA_INTEGER    = TC_SET {TC__SA_INTEGER  }; (* 0x00000080 *)
      TC_SA_CONTIN     = TC_SET {TC__SA_CONTIN   }; (* 0x00000100 *)
      TC_EA_DOUBLE     = TC_SET {TC__EA_DOUBLE   }; (* 0x00000200 *)
      TC_IA_ABLE       = TC_SET {TC__IA_ABLE     }; (* 0x00000400 *)
      TC_UA_ABLE       = TC_SET {TC__UA_ABLE     }; (* 0x00000800 *)
      TC_SO_ABLE       = TC_SET {TC__SO_ABLE     }; (* 0x00001000 *)
      TC_RA_ABLE       = TC_SET {TC__RA_ABLE     }; (* 0x00002000 *)
      TC_VA_ABLE       = TC_SET {TC__VA_ABLE     }; (* 0x00004000 *)
      TC_RESERVED      = TC_SET {TC__RESERVED    }; (* 0x00008000 *)
      TC_SCROLLBLT     = TC_SET {TC__SCROLLBLT   }; (* 0x00010000 *)

<* END *> (* NOT DEFINED (NOGDICAPMASKS) *)

(* Raster Capabilities *)

TYPE RC_ENUM = (RC__BITBLT,         (*  0 - Can do standard BLT.             *)
                RC__BANDING,        (*  1 - Device requires banding support  *)
                RC__SCALING,        (*  2 - Device requires scaling support  *)
                RC__BITMAP64,       (*  3 - Device can support >64K bitmap   *)
                RC__GDI20_OUTPUT,   (*  4 - has 2.0 output calls             *)
                RC__GDI20_STATE,    (*  5 *)
                RC__SAVEBITMAP,     (*  6 *)
                RC__DI_BITMAP,      (*  7 - supports DIB to memory           *)
                RC__PALETTE,        (*  8 - supports a palette               *)
                RC__DIBTODEV,       (*  9 - supports DIBitsToDevice          *)
                RC__BIGFONT,        (* 10 - supports >64K fonts              *)
                RC__STRETCHBLT,     (* 11 - supports StretchBlt              *)
                RC__FLOODFILL,      (* 12 - supports FloodFill               *)
                RC__STRETCHDIB,     (* 13 - supports StretchDIBits           *)
                RC__OP_DX_OUTPUT,   (* 14 *)
                RC__DEVBITS);       (* 15 *)

           RC_SET = SET OF RC_ENUM;

      CONST RC_NONE         = RC_SET {};
            RC_BITBLT       = RC_SET {RC__BITBLT       }; (*      1 *)
            RC_BANDING      = RC_SET {RC__BANDING      }; (*      2 *)
            RC_SCALING      = RC_SET {RC__SCALING      }; (*      4 *)
            RC_BITMAP64     = RC_SET {RC__BITMAP64     }; (*      8 *)
            RC_GDI20_OUTPUT = RC_SET {RC__GDI20_OUTPUT }; (* 0x0010 *)
            RC_GDI20_STATE  = RC_SET {RC__GDI20_STATE  }; (* 0x0020 *)
            RC_SAVEBITMAP   = RC_SET {RC__SAVEBITMAP   }; (* 0x0040 *)
            RC_DI_BITMAP    = RC_SET {RC__DI_BITMAP    }; (* 0x0080 *)
            RC_PALETTE      = RC_SET {RC__PALETTE      }; (* 0x0100 *)
            RC_DIBTODEV     = RC_SET {RC__DIBTODEV     }; (* 0x0200 *)
            RC_BIGFONT      = RC_SET {RC__BIGFONT      }; (* 0x0400 *)
            RC_STRETCHBLT   = RC_SET {RC__STRETCHBLT   }; (* 0x0800 *)
            RC_FLOODFILL    = RC_SET {RC__FLOODFILL    }; (* 0x1000 *)
            RC_STRETCHDIB   = RC_SET {RC__STRETCHDIB   }; (* 0x2000 *)
            RC_OP_DX_OUTPUT = RC_SET {RC__OP_DX_OUTPUT }; (* 0x4000 *)
            RC_DEVBITS      = RC_SET {RC__DEVBITS      }; (* 0x8000 *)

(* DIB color table identifiers *)

TYPE DIB_COLOR_ENUM = (
         DIB_RGB_COLORS,       (* 0 - color table in RGBs                      *)
         DIB_PAL_COLORS,       (* 1 - color table in palette indices           *)
         DIB_PAL_PHYSINDICES,  (* 2 - No color table indices into surf palette *)
         DIB_PAL_LOGINDICES);  (* 3 - No color table indices into DC palette   *)

CONST    DIB_PAL_INDICES = DIB_PAL_PHYSINDICES;

(* constants for Get/SetSystemPaletteUse() *)

TYPE SYSPAL_ENUM = (SYSPAL_ERROR,     (* 0 *)
                    SYSPAL_STATIC,    (* 1 *)
                    SYSPAL_NOSTATIC); (* 2 *)

(* constants for CreateDIBitmap *)
TYPE CBM_ENUM = (CBM_0, CBM_1,
                CBM_CREATEDIB,  (* 0x02L  - create DIB bitmap *)
                CBM_3,
                CBM_INIT);      (* 0x04L  - initialize bitmap *)

(* ExtFloodFill style flags *)
TYPE FLOODFILL_ENUM = (FLOODFILLBORDER,   (* 0 *)
                       FLOODFILLSURFACE); (* 1 *)

(* DEVMODE structure stuff *)

(* current version of specification *)
CONST DM_SPECVERSION = 0401h;

(* field selection set (dmFields field) *)

TYPE DM_ENUM = (DM__ORIENTATION,      (* 0 *)
                DM__PAPERSIZE,        (* 1 *)
                DM__PAPERLENGTH,      (* 2 *)
                DM__PAPERWIDTH,       (* 3 *)
                DM__SCALE,            (* 4 *)
                DM__5, DM__6, DM__7,
                DM__COPIES,           (* 8 *)
                DM__DEFAULTSOURCE,    (* 9 *)
                DM__PRINTQUALITY,     (* 10 *)
                DM__COLOR,            (* 11 *)
                DM__DUPLEX,           (* 12 *)
                DM__YRESOLUTION,      (* 13 *)
                DM__TTOPTION,         (* 14 *)
                DM__COLLATE,          (* 15 *)
                DM__FORMNAME,         (* 16 *)
                DM__LOGPIXELS,        (* 17 *)
                DM__BITSPERPEL,       (* 18 *)
                DM__PELSWIDTH,        (* 19 *)
                DM__PELSHEIGHT,       (* 20 *)
                DM__DISPLAYFLAGS,     (* 21 *)
                DM__DISPLAYFREQUENCY, (* 22 *)
                DM__PANNINGWIDTH,     (* 23 *)
                DM__PANNINGHEIGHT,    (* 24 *)
                DM__ICMMETHOD,        (* 25 *)
                DM__ICMINTENT,        (* 26 *)
                DM__MEDIATYPE,        (* 27 *)
                DM__DITHERTYPE,       (* 28 *)
                DM__ICCMANUFACTURER,  (* 29 *)
                DM__ICCMODEL);        (* 30 *)

     DM_SET = SET OF DM_ENUM;

CONST DM_ORIENTATION      = DM_SET {DM__ORIENTATION     };  (* 0x00000001 *)
      DM_PAPERSIZE        = DM_SET {DM__PAPERSIZE       };  (* 0x00000002 *)
      DM_PAPERLENGTH      = DM_SET {DM__PAPERLENGTH     };  (* 0x00000004 *)
      DM_PAPERWIDTH       = DM_SET {DM__PAPERWIDTH      };  (* 0x00000008 *)
      DM_SCALE            = DM_SET {DM__SCALE           };  (* 0x00000010 *)
      DM_COPIES           = DM_SET {DM__COPIES          };  (* 0x00000100 *)
      DM_DEFAULTSOURCE    = DM_SET {DM__DEFAULTSOURCE   };  (* 0x00000200 *)
      DM_PRINTQUALITY     = DM_SET {DM__PRINTQUALITY    };  (* 0x00000400 *)
      DM_COLOR            = DM_SET {DM__COLOR           };  (* 0x00000800 *)
      DM_DUPLEX           = DM_SET {DM__DUPLEX          };  (* 0x00001000 *)
      DM_YRESOLUTION      = DM_SET {DM__YRESOLUTION     };  (* 0x00002000 *)
      DM_TTOPTION         = DM_SET {DM__TTOPTION        };  (* 0x00004000 *)
      DM_COLLATE          = DM_SET {DM__COLLATE         };  (* 0x00008000 *)
      DM_FORMNAME         = DM_SET {DM__FORMNAME        };  (* 0x00010000 *)
      DM_LOGPIXELS        = DM_SET {DM__LOGPIXELS       };  (* 0x00020000 *)
      DM_BITSPERPEL       = DM_SET {DM__BITSPERPEL      };  (* 0x00040000 *)
      DM_PELSWIDTH        = DM_SET {DM__PELSWIDTH       };  (* 0x00080000 *)
      DM_PELSHEIGHT       = DM_SET {DM__PELSHEIGHT      };  (* 0x00100000 *)
      DM_DISPLAYFLAGS     = DM_SET {DM__DISPLAYFLAGS    };  (* 0x00200000 *)
      DM_DISPLAYFREQUENCY = DM_SET {DM__DISPLAYFREQUENCY}; (* 0x00400000 *)
      DM_PANNINGWIDTH     = DM_SET {DM__PANNINGWIDTH    };  (* 0x00800000 *)
      DM_PANNINGHEIGHT    = DM_SET {DM__PANNINGHEIGHT   };  (* 0x01000000 *)
      DM_ICMMETHOD        = DM_SET {DM__ICMMETHOD       };  (* 0x02000000 *)
      DM_ICMINTENT        = DM_SET {DM__ICMINTENT       };  (* 0x04000000 *)
      DM_MEDIATYPE        = DM_SET {DM__MEDIATYPE       };  (* 0x08000000 *)
      DM_DITHERTYPE       = DM_SET {DM__DITHERTYPE      };  (* 0x10000000 *)
      DM_ICCMANUFACTURER  = DM_SET {DM__ICCMANUFACTURER };  (* 0x20000000 *)
      DM_ICCMODEL         = DM_SET {DM__ICCMODEL        };  (* 0x40000000 *)

(* orientation selections - values of dmOrientation *)

<* PUSH *> <* ENUMSIZE = "2" *>
TYPE DMORIENT_ENUM = (DMORIENT_0,
                      DMORIENT_PORTRAIT,   (* 1 *)
                      DMORIENT_LANDSCAPE); (* 2 *)
<* POP *>

(* paper selections - values for dmPaperSize *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE DMPAPER_ENUM = (
      DMPAPER_0,
      DMPAPER_LETTER,              (* 1  - Letter 8 1/2 x 11 in               *)
      DMPAPER_LETTERSMALL,         (* 2  - Letter Small 8 1/2 x 11 in         *)
      DMPAPER_TABLOID,             (* 3  - Tabloid 11 x 17 in                 *)
      DMPAPER_LEDGER,              (* 4  - Ledger 17 x 11 in                  *)
      DMPAPER_LEGAL,               (* 5  - Legal 8 1/2 x 14 in                *)
      DMPAPER_STATEMENT,           (* 6  - Statement 5 1/2 x 8 1/2 in         *)
      DMPAPER_EXECUTIVE,           (* 7  - Executive 7 1/4 x 10 1/2 in        *)
      DMPAPER_A3,                  (* 8  - A3 297 x 420 mm                    *)
      DMPAPER_A4,                  (* 9  - A4 210 x 297 mm                    *)
      DMPAPER_A4SMALL,             (* 10 - A4 Small 210 x 297 mm              *)
      DMPAPER_A5,                  (* 11 - A5 148 x 210 mm                    *)
      DMPAPER_B4,                  (* 12 - B4 250 x 354                       *)
      DMPAPER_B5,                  (* 13 - B5 182 x 257 mm                    *)
      DMPAPER_FOLIO,               (* 14 - Folio 8 1/2 x 13 in                *)
      DMPAPER_QUARTO,              (* 15 - Quarto 215 x 275 mm                *)
      DMPAPER_10X14,               (* 16 - 10x14 in                           *)
      DMPAPER_11X17,               (* 17 - 11x17 in                           *)
      DMPAPER_NOTE,                (* 18 - Note 8 1/2 x 11 in                 *)
      DMPAPER_ENV_9,               (* 19 - Envelope #9 3 7/8 x 8 7/8          *)
      DMPAPER_ENV_10,              (* 20 - Envelope #10 4 1/8 x 9 1/2         *)
      DMPAPER_ENV_11,              (* 21 - Envelope #11 4 1/2 x 10 3/8        *)
      DMPAPER_ENV_12,              (* 22 - Envelope #12 4 \276 x 11           *)
      DMPAPER_ENV_14,              (* 23 - Envelope #14 5 x 11 1/2            *)
      DMPAPER_CSHEET,              (* 24 - C size sheet                       *)
      DMPAPER_DSHEET,              (* 25 - D size sheet                       *)
      DMPAPER_ESHEET,              (* 26 - E size sheet                       *)
      DMPAPER_ENV_DL,              (* 27 - Envelope DL 110 x 220mm            *)
      DMPAPER_ENV_C5,              (* 28 - Envelope C5 162 x 229 mm           *)
      DMPAPER_ENV_C3,              (* 29 - Envelope C3  324 x 458 mm          *)
      DMPAPER_ENV_C4,              (* 30 - Envelope C4  229 x 324 mm          *)
      DMPAPER_ENV_C6,              (* 31 - Envelope C6  114 x 162 mm          *)
      DMPAPER_ENV_C65,             (* 32 - Envelope C65 114 x 229 mm          *)
      DMPAPER_ENV_B4,              (* 33 - Envelope B4  250 x 353 mm          *)
      DMPAPER_ENV_B5,              (* 34 - Envelope B5  176 x 250 mm          *)
      DMPAPER_ENV_B6,              (* 35 - Envelope B6  176 x 125 mm          *)
      DMPAPER_ENV_ITALY,           (* 36 - Envelope 110 x 230 mm              *)
      DMPAPER_ENV_MONARCH,         (* 37 - Envelope Monarch 3.875 x 7.5 in    *)
      DMPAPER_ENV_PERSONAL,        (* 38 - 6 3/4 Envelope 3 5/8 x 6 1/2 in    *)
      DMPAPER_FANFOLD_US,          (* 39 - US Std Fanfold 14 7/8 x 11 in      *)
      DMPAPER_FANFOLD_STD_GERMAN,  (* 40 - German Std Fanfold 8 1/2 x 12 in   *)
      DMPAPER_FANFOLD_LGL_GERMAN,  (* 41 - German Legal Fanfold 8 1/2 x 13 in *)

      DMPAPER_ISO_B4,              (* 42 - B4 (ISO) 250 x 353 mm              *)
      DMPAPER_JAPANESE_POSTCARD,   (* 43 - Japanese Postcard 100 x 148 mm     *)
      DMPAPER_9X11,                (* 44 - 9 x 11 in                          *)
      DMPAPER_10X11,               (* 45 - 10 x 11 in                         *)
      DMPAPER_15X11,               (* 46 - 15 x 11 in                         *)
      DMPAPER_ENV_INVITE,          (* 47 - Envelope Invite 220 x 220 mm       *)
      DMPAPER_RESERVED_48,         (* 48 - RESERVED--DO NOT USE               *)
      DMPAPER_RESERVED_49,         (* 49 - RESERVED--DO NOT USE               *)
      DMPAPER_LETTER_EXTRA,        (* 50 - Letter Extra 9 \275 x 12 in        *)
      DMPAPER_LEGAL_EXTRA,         (* 51 - Legal Extra 9 \275 x 15 in         *)
      DMPAPER_TABLOID_EXTRA,       (* 52 - Tabloid Extra 11.69 x 18 in        *)
      DMPAPER_A4_EXTRA,            (* 53 - A4 Extra 9.27 x 12.69 in           *)
      DMPAPER_LETTER_TRANSVERSE,   (* 54 - Letter Transverse 8 \275 x 11 in   *)
      DMPAPER_A4_TRANSVERSE,       (* 55 - A4 Transverse 210 x 297 mm         *)
      DMPAPER_LETTER_EXTRA_TRANSVERSE, (* 56 - Letter Extra Transverse 9\275 x 12 in *)
      DMPAPER_A_PLUS,              (* 57 - SuperA/SuperA/A4 227 x 356 mm      *)
      DMPAPER_B_PLUS,              (* 58 - SuperB/SuperB/A3 305 x 487 mm      *)
      DMPAPER_LETTER_PLUS,         (* 59 - Letter Plus 8.5 x 12.69 in         *)
      DMPAPER_A4_PLUS,             (* 60 - A4 Plus 210 x 330 mm               *)
      DMPAPER_A5_TRANSVERSE,       (* 61 - A5 Transverse 148 x 210 mm         *)
      DMPAPER_B5_TRANSVERSE,       (* 62 - B5 (JIS) Transverse 182 x 257 mm   *)
      DMPAPER_A3_EXTRA,            (* 63 - A3 Extra 322 x 445 mm              *)
      DMPAPER_A5_EXTRA,            (* 64 - A5 Extra 174 x 235 mm              *)
      DMPAPER_B5_EXTRA,            (* 65 - B5 (ISO) Extra 201 x 276 mm        *)
      DMPAPER_A2,                  (* 66 - A2 420 x 594 mm                    *)
      DMPAPER_A3_TRANSVERSE,       (* 67 - A3 Transverse 297 x 420 mm         *)
      DMPAPER_A3_EXTRA_TRANSVERSE, (* 68 - A3 Extra Transverse 322 x 445 mm   *)

      DMPAPER_DBL_JAPANESE_POSTCARD,(* 69 - Japanese Double Postcard 200 x 148 mm *)
      DMPAPER_A6,                  (* 70 - A6 105 x 148 mm                 *)
      DMPAPER_JENV_KAKU2,          (* 71 - Japanese Envelope Kaku #2       *)
      DMPAPER_JENV_KAKU3,          (* 72 - Japanese Envelope Kaku #3       *)
      DMPAPER_JENV_CHOU3,          (* 73 - Japanese Envelope Chou #3       *)
      DMPAPER_JENV_CHOU4,          (* 74 - Japanese Envelope Chou #4       *)
      DMPAPER_LETTER_ROTATED,      (* 75 - Letter Rotated 11 x 8 1/2 11 in *)
      DMPAPER_A3_ROTATED,          (* 76 - A3 Rotated 420 x 297 mm         *)
      DMPAPER_A4_ROTATED,          (* 77 - A4 Rotated 297 x 210 mm         *)
      DMPAPER_A5_ROTATED,          (* 78 - A5 Rotated 210 x 148 mm         *)
      DMPAPER_B4_JIS_ROTATED,      (* 79 - B4 (JIS) Rotated 364 x 257 mm   *)
      DMPAPER_B5_JIS_ROTATED,      (* 80 - B5 (JIS) Rotated 257 x 182 mm   *)
      DMPAPER_JAPANESE_POSTCARD_ROTATED,(* 81 - Japanese Postcard Rotated 148 x 100 mm *)
      DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED,(* 82 - Double Japanese Postcard Rotated 148 x 200 mm *)
      DMPAPER_A6_ROTATED,          (* 83 - A6 Rotated 148 x 105 mm         *)
      DMPAPER_JENV_KAKU2_ROTATED,  (* 84 - Japanese Envelope Kaku #2 Rotated *)
      DMPAPER_JENV_KAKU3_ROTATED,  (* 85 - Japanese Envelope Kaku #3 Rotated *)
      DMPAPER_JENV_CHOU3_ROTATED,  (* 86 - Japanese Envelope Chou #3 Rotated *)
      DMPAPER_JENV_CHOU4_ROTATED,  (* 87 - Japanese Envelope Chou #4 Rotated *)
      DMPAPER_B6_JIS,              (* 88 - B6 (JIS) 128 x 182 mm           *)
      DMPAPER_B6_JIS_ROTATED,      (* 89 - B6 (JIS) Rotated 182 x 128 mm   *)
      DMPAPER_12X11,               (* 90 - 12 x 11 in                      *)
      DMPAPER_JENV_YOU4,           (* 91 - Japanese Envelope You #4        *)
      DMPAPER_JENV_YOU4_ROTATED,   (* 92 - Japanese Envelope You #4 Rotated*)
      DMPAPER_P16K,                (* 93 - PRC 16K 146 x 215 mm            *)
      DMPAPER_P32K,                (* 94 - PRC 32K 97 x 151 mm             *)
      DMPAPER_P32KBIG,             (* 95 - PRC 32K(Big) 97 x 151 mm        *)
      DMPAPER_PENV_1,              (* 96 - PRC Envelope #1 102 x 165 mm    *)
      DMPAPER_PENV_2,              (* 97 - PRC Envelope #2 102 x 176 mm    *)
      DMPAPER_PENV_3,              (* 98 - PRC Envelope #3 125 x 176 mm    *)
      DMPAPER_PENV_4,              (* 99 - PRC Envelope #4 110 x 208 mm    *)
      DMPAPER_PENV_5,              (*100 - PRC Envelope #5 110 x 220 mm    *)
      DMPAPER_PENV_6,              (*101 - PRC Envelope #6 120 x 230 mm    *)
      DMPAPER_PENV_7,              (*102 - PRC Envelope #7 160 x 230 mm    *)
      DMPAPER_PENV_8,              (*103 - PRC Envelope #8 120 x 309 mm    *)
      DMPAPER_PENV_9,              (*104 - PRC Envelope #9 229 x 324 mm    *)
      DMPAPER_PENV_10,             (*105 - PRC Envelope #10 324 x 458 mm   *)
      DMPAPER_P16K_ROTATED,        (*106 - PRC 16K Rotated                 *)
      DMPAPER_P32K_ROTATED,        (*107 - PRC 32K Rotated                 *)
      DMPAPER_P32KBIG_ROTATED,     (*108 - PRC 32K(Big) Rotated            *)
      DMPAPER_PENV_1_ROTATED,      (*109 - PRC Envelope #1 Rotated 165 x 102 mm *)
      DMPAPER_PENV_2_ROTATED,      (*110 - PRC Envelope #2 Rotated 176 x 102 mm *)
      DMPAPER_PENV_3_ROTATED,      (*111 - PRC Envelope #3 Rotated 176 x 125 mm *)
      DMPAPER_PENV_4_ROTATED,      (*112 - PRC Envelope #4 Rotated 208 x 110 mm *)
      DMPAPER_PENV_5_ROTATED,      (*113 - PRC Envelope #5 Rotated 220 x 110 mm *)
      DMPAPER_PENV_6_ROTATED,      (*114 - PRC Envelope #6 Rotated 230 x 120 mm *)
      DMPAPER_PENV_7_ROTATED,      (*115 - PRC Envelope #7 Rotated 230 x 160 mm *)
      DMPAPER_PENV_8_ROTATED,      (*116 - PRC Envelope #8 Rotated 309 x 120 mm *)
      DMPAPER_PENV_9_ROTATED,      (*117 - PRC Envelope #9 Rotated 324 x 229 mm *)
      DMPAPER_PENV_10_ROTATED);    (*118 - PRC Envelope #10 Rotated 458 x 324 mm *)

CONST DMPAPER_FIRST = DMPAPER_LETTER;
      DMPAPER_LAST  = DMPAPER_PENV_10_ROTATED;

      DMPAPER_USER  = DM_ENUM (256);

<* POP *>

(* bin selections - dmDefaultSource values *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE DMBIN_ENUM = (DMBIN_0,
                   DMBIN_UPPER,         (*  1 *)
                   DMBIN_LOWER,         (*  2 *)
                   DMBIN_MIDDLE,        (*  3 *)
                   DMBIN_MANUAL,        (*  4 *)
                   DMBIN_ENVELOPE,      (*  5 *)
                   DMBIN_ENVMANUA,      (*  6 *)
                   DMBIN_AUTO,          (*  7 *)
                   DMBIN_TRACTOR,       (*  8 *)
                   DMBIN_SMALLFMT,      (*  9 *)
                   DMBIN_LARGEFMT,      (* 10 *)
                   DMBIN_LARGECAPACITY, (* 11 *)
                   DMBIN_CASSETTE,      (* 14 *)
                   DMBIN_FORMSOURCE);   (* 15 *)

<* POP *>

CONST DMBIN_ONLYONE       = DMBIN_UPPER; (* 1 *)
      DMBIN_FIRST = DMBIN_UPPER;
      DMBIN_LAST  = DMBIN_FORMSOURCE;
      DMBIN_USER  = DMBIN_ENUM (256);    (* device specific bins start here *)

(* print qualities - values of dmPrintQuality field *)
TYPE DMRES_ENUM = SHORT;

CONST DMRES_DRAFT   = DMRES_ENUM (-1);
      DMRES_LOW     = DMRES_ENUM (-2);
      DMRES_MEDIUM  = DMRES_ENUM (-3);
      DMRES_HIGH    = DMRES_ENUM (-4);

(* color enable/disable for color printers - dmColor values *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE DMCOLOR_ENUM = (DMCOLOR_0,
                     DMCOLOR_MONOCHROME, (* 1 *)
                     DMCOLOR_COLOR);     (* 2 *)

<* POP *>

(* duplex enable - dmDuplex values *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE DMDUP_ENUM = (DMDUPLEX_0,
                   DMDUP_SIMPLEX,     (* 1 *)
                   DMDUP_VERTICAL,    (* 2 *)
                   DMDUP_HORIZONTAL); (* 3 *)

<* POP *>

(* TrueType options - dmTTOption values *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE DMTT_ENUM = (DMTT_0,
                  DMTT_BITMAP,            (* 1 - print TT fonts as graphics *)
                  DMTT_DOWNLOAD,          (* 2 - download TT fonts as soft fonts *)
                  DMTT_SUBDEV,            (* 3 - substitute device fonts for TT fonts *)
                  DMTT_DOWNLOAD_OUTLINE); (* 4 - download TT fonts as outline soft fonts *)

<* POP *>

(* Collation selections *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE DMCOLLATE_ENUM = (DMCOLLATE_FALSE, (* 0 *)
                       DMCOLLATE_TRUE); (* 1 *)

<* POP *>

(* DEVMODE dmDisplayFlags flags *)

TYPE DMDISP_ENUM = (DM__GRAYSCALE,              (* 0 *)
                    DM__INTERLACED,             (* 1 *)
                    DMDISPLAYFLAGS__TEXTMODE);  (* 2 *)

     DMDISP_SET = SET OF DMDISP_ENUM;

CONST DM_GRAYSCALE  = DMDISP_SET {DM__GRAYSCALE};   (* 0x00000001 *)
      DM_INTERLACED = DMDISP_SET {DM__INTERLACED};  (* 0x00000002 *)
      DMDISPLAYFLAGS_TEXTMODE = DMDISP_SET {DMDISPLAYFLAGS__TEXTMODE}; (* 0x00000002 *)

(* ICM methods *)

TYPE  DMICMMETHOD_ENUM = (DMICMMETHOD_0,
                          DMICMMETHOD_NONE,    (* 1 - ICM disabled *)
                          DMICMMETHOD_SYSTEM,  (* 2 - ICM handled by system *)
                          DMICMMETHOD_DRIVER,  (* 3 - ICM handled by driver *)
                          DMICMMETHOD_DEVICE); (* 4 - ICM handled by device *)

CONST DMICMMETHOD_USER = DMICMMETHOD_ENUM (256);

(* ICM Intents *)

TYPE DMICM_ENUM = (DMICM_0,
                   DMICM_SATURATE,     (* 1 - Maximize color saturation *)
                   DMICM_CONTRAST,     (* 2 - Maximize color contrast   *)
                   DMICM_COLORMETRIC); (* 3 - Use specific color metric *)

CONST DMICM_USER = DMICM_ENUM (256);   (* Device-specific intents start here *)

(* Media types *)

TYPE  DMMEDIA_ENUM = (DMMEDIA_0,
                      DMMEDIA_STANDARD,     (* 1 - Standard paper *)
                      DMMEDIA_TRANSPARENCY, (* 2 - Transparency *)
                      DMMEDIA_GLOSSY);      (* 3 - Glossy paper *)

CONST DMMEDIA_USER = DMMEDIA_ENUM (256);   (* Device-specific media start here *)

(* Dither types *)

TYPE DMDITHER_ENUM = (DMDITHER_0,
                      DMDITHER_NONE,        (* 1 - No dithering *)
                      DMDITHER_COARSE,      (* 2 - Dither with a coarse brush *)
                      DMDITHER_FINE,        (* 3 - Dither with a fine brush *)
                      DMDITHER_LINEART,     (* 4 - LineArt dithering *)
                      DMDITHER_GRAYSCALE);  (* 5 - Device does grayscaling *)

CONST DMDITHER_USER = DMDITHER_ENUM (256);  (* Device-specific dithers start here *)

(* size of a device name string (dmDeviceName field) *)
CONST CCHDEVICENAME = 32;

(* size of a form name string (dmFormName field) *)
CONST CCHFORMNAME = 32;

TYPE DEVMODEA = RECORD
                    dmDeviceName     : ARRAY [0..CCHDEVICENAME-1] OF CHAR;
                    dmSpecVersion    : WORD;
                    dmDriverVersion  : WORD;
                    dmSize           : WORD;
                    dmDriverExtra    : WORD;
                    dmFields         : DM_SET;
                    dmOrientation    : DMORIENT_ENUM;
                    dmPaperSize      : DMPAPER_ENUM;
                    dmPaperLength    : SHORT;
                    dmPaperWidth     : SHORT;
                    dmScale          : SHORT;
                    dmCopies         : SHORT;
                    dmDefaultSource  : DMBIN_ENUM;
                    dmPrintQuality   : DMRES_ENUM;
                    dmColor          : DMCOLOR_ENUM;
                    dmDuplex         : DMDUP_ENUM;
                    dmYResolution    : SHORT;
                    dmTTOption       : DMTT_ENUM;
                    dmCollate        : DMCOLLATE_ENUM;
                    dmFormName       : ARRAY [0..CCHFORMNAME-1] OF CHAR;
                    dmLogPixels      : WORD;
                    dmBitsPerPel     : DWORD;
                    dmPelsWidth      : DWORD;
                    dmPelsHeight     : DWORD;
                    dmDisplayFlags   : DMDISP_SET;
                    dmDisplayFrequency : DWORD;
                    dmICMMethod        : DMICMMETHOD_ENUM;
                    dmICMIntent        : DMICM_ENUM;
                    dmMediaType        : DMMEDIA_ENUM;
                    dmDitherType       : DMDITHER_ENUM;
                    dmICCManufacturer  : DWORD;
                    dmICCModel         : DWORD;
                    dmPanningWidth     : DWORD;
                    dmPanningHeight    : DWORD;
                END;
     PDEVMODEA  = POINTER TO DEVMODEA;

TYPE DEVMODEW = RECORD
                    dmDeviceName     : ARRAY [0..CCHDEVICENAME-1] OF WCHAR;
                    dmSpecVersion    : WORD;
                    dmDriverVersion  : WORD;
                    dmSize           : WORD;
                    dmDriverExtra    : WORD;
                    dmFields         : DM_SET;
                    dmOrientation    : DMORIENT_ENUM;
                    dmPaperSize      : DMPAPER_ENUM;
                    dmPaperLength    : SHORT;
                    dmPaperWidth     : SHORT;
                    dmScale          : SHORT;
                    dmCopies         : SHORT;
                    dmDefaultSource  : DMBIN_ENUM;
                    dmPrintQuality   : DMRES_ENUM;
                    dmColor          : DMCOLOR_ENUM;
                    dmDuplex         : DMDUP_ENUM;
                    dmYResolution    : SHORT;
                    dmTTOption       : DMTT_ENUM;
                    dmCollate        : DMCOLLATE_ENUM;
                    dmFormName       : ARRAY [0..CCHFORMNAME-1] OF WCHAR;
                    dmLogPixels      : WORD;
                    dmBitsPerPel     : DWORD;
                    dmPelsWidth      : DWORD;
                    dmPelsHeight     : DWORD;
                    dmDisplayFlags   : DMDISP_SET;
                    dmDisplayFrequency : DWORD;
                    dmICMMethod        : DMICMMETHOD_ENUM;
                    dmICMIntent        : DMICM_ENUM;
                    dmMediaType        : DMMEDIA_ENUM;
                    dmDitherType       : DMDITHER_ENUM;
                    dmICCManufacturer  : DWORD;
                    dmICCModel         : DWORD;
                    dmPanningWidth     : DWORD;
                    dmPanningHeight    : DWORD;
                END;
     PDEVMODEW  = POINTER TO DEVMODEW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE DEVMODE   = DEVMODEW;
           PDEVMODE  = PDEVMODEW;
<* ELSE *>
      TYPE DEVMODE   = DEVMODEA;
           PDEVMODE  = PDEVMODEA;
<* END *>

(* GetRegionData/ExtCreateRegion *)

CONST RDH_RECTANGLES = 1; (* the only value for iType *)

TYPE RGNDATAHEADER = RECORD
                            dwSize   : DWORD;
                            iType    : DWORD;
                            nCount   : DWORD;
                            nRgnSize : DWORD;
                            rcBound  : RECT;
                     END;
     PRGNDATAHEADER = POINTER TO RGNDATAHEADER;

     RGNDATA = RECORD
                      rdh : RGNDATAHEADER;
                      Buffer : ARRAY [0..0] OF CHAR;
               END;
    PRGNDATA  = POINTER TO RGNDATA;

TYPE ABC = RECORD
                  abcA : INTEGER;
                  abcB : UINT;
                  abcC : INTEGER;
           END;
     PABC = POINTER TO ABC;

TYPE ABCFLOAT = RECORD
                       abcA : FLOAT;
                       abcB : FLOAT;
                       abcC : FLOAT;
                END;
     PABCFLOAT = POINTER TO ABCFLOAT;

<* IF NOT DEFINED (NOTEXTMETRIC) THEN *>

TYPE OUTLINETEXTMETRICA = RECORD
                                otmSize                : UINT;
                                otmTextMetrics         : TEXTMETRICA;
                                otmFiller              : BYTE;
                                otmPanoseNumber        : PANOSE;
                                otmfsSelection         : NTM_SET;
                                otmfsType              : UINT;
                                otmsCharSlopeRise      : INTEGER;
                                otmsCharSlopeRun       : INTEGER;
                                otmItalicAngle         : INTEGER;
                                otmEMSquare            : UINT;
                                otmAscent              : INTEGER;
                                otmDescent             : INTEGER;
                                otmLineGap             : UINT;
                                otmsCapEmHeight        : UINT;
                                otmsXHeight            : UINT;
                                otmrcFontBox           : RECT;
                                otmMacAscent           : INTEGER;
                                otmMacDescent          : INTEGER;
                                otmMacLineGap          : UINT;
                                otmusMinimumPPEM       : UINT;
                                otmptSubscriptSize     : POINT;
                                otmptSubscriptOffset   : POINT;
                                otmptSuperscriptSize   : POINT;
                                otmptSuperscriptOffset : POINT;
                                otmsStrikeoutSize      : UINT;
                                otmsStrikeoutPosition  : INTEGER;
                                otmsUnderscoreSize     : INTEGER;
                                otmsUnderscorePosition : INTEGER;
                                otmpFamilyName         : PSTR;
                                otmpFaceName           : PSTR;
                                otmpStyleName          : PSTR;
                                otmpFullName           : PSTR
                          END;

TYPE OUTLINETEXTMETRICW = RECORD
                                otmSize                : UINT;
                                otmTextMetrics         : TEXTMETRICW;
                                otmFiller              : BYTE;
                                otmPanoseNumber        : PANOSE;
                                otmfsSelection         : NTM_SET;
                                otmfsType              : UINT;
                                otmsCharSlopeRise      : INTEGER;
                                otmsCharSlopeRun       : INTEGER;
                                otmItalicAngle         : INTEGER;
                                otmEMSquare            : UINT;
                                otmAscent              : INTEGER;
                                otmDescent             : INTEGER;
                                otmLineGap             : UINT;
                                otmsCapEmHeight        : UINT;
                                otmsXHeight            : UINT;
                                otmrcFontBox           : RECT;
                                otmMacAscent           : INTEGER;
                                otmMacDescent          : INTEGER;
                                otmMacLineGap          : UINT;
                                otmusMinimumPPEM       : UINT;
                                otmptSubscriptSize     : POINT;
                                otmptSubscriptOffset   : POINT;
                                otmptSuperscriptSize   : POINT;
                                otmptSuperscriptOffset : POINT;
                                otmsStrikeoutSize      : UINT;
                                otmsStrikeoutPosition  : INTEGER;
                                otmsUnderscoreSize     : INTEGER;
                                otmsUnderscorePosition : INTEGER;
                                otmpFamilyName         : PWSTR;
                                otmpFaceName           : PWSTR;
                                otmpStyleName          : PWSTR;
                                otmpFullName           : PWSTR
                          END;
TYPE POUTLINETEXTMETRICA = POINTER TO OUTLINETEXTMETRICA;
     POUTLINETEXTMETRICW = POINTER TO OUTLINETEXTMETRICW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE OUTLINETEXTMETRIC = OUTLINETEXTMETRICW;
           POUTLINETEXTMETRIC = POUTLINETEXTMETRICW;
<* ELSE *>
      TYPE OUTLINETEXTMETRIC = OUTLINETEXTMETRICA;
           POUTLINETEXTMETRIC = POUTLINETEXTMETRICA;
<* END *>

<* END *> (* NOT DEFINED (NOTEXTMETRIC) *)

TYPE POLYTEXTA = RECORD
                        x       : INTEGER;
                        y       : INTEGER;
                        n       : UINT;
                        lpstr   : PSTR;
                        uiFlags : ETO_SET;
                        rcl     : RECT;
                        pdx     : INTARRAY;
                 END;
     PPOLYTEXTA = POINTER TO POLYTEXTA;

     POLYTEXTW = RECORD
                        x       : INTEGER;
                        y       : INTEGER;
                        n       : UINT;
                        lpstr   : PWSTR;
                        uiFlags : ETO_SET;
                        rcl     : RECT;
                        pdx     : INTARRAY;
                 END;
     PPOLYTEXTW = POINTER TO POLYTEXTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  POLYTEXT = POLYTEXTW;
            PPOLYTEXT = PPOLYTEXTW;
<* ELSE *>
      TYPE  POLYTEXT = POLYTEXTA;
            PPOLYTEXT = PPOLYTEXTA;
<* END *>

TYPE FIXED = RECORD
                    fract : WORD;
                    value : SHORT;
             END;

TYPE MAT2 = RECORD
                   eM11 : FIXED;
                   eM12 : FIXED;
                   eM21 : FIXED;
                   eM22 : FIXED;
            END;
     PMAT2 = POINTER TO MAT2;


TYPE GLYPHMETRICS = RECORD
                           gmBlackBoxX     : UINT;
                           gmBlackBoxY     : UINT;
                           gmptGlyphOrigin : POINT;
                           gmCellIncX      : SHORT;
                           gmCellIncY      : SHORT;
                    END;
    PGLYPHMETRICS = POINTER TO GLYPHMETRICS;

(* GetGlyphOutline constants *)

TYPE GGO_ENUM = (GGO_METRICS,       (* 0 *)
                 GGO_BITMAP,        (* 1 *)
                 GGO_NATIVE,        (* 2 *)
                 GGO_3,
                 GGO_GRAY2_BITMAP,  (* 4 *)
                 GGO_GRAY4_BITMAP,  (* 5 *)
                 GGO_GRAY8_BITMAP); (* 6 *)

CONST GGO_GLYPH_INDEX = 080H;

CONST TT_POLYGON_TYPE = 24;

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE TT_PRIM_ENUM = (TT_PRIM_0,
                     TT_PRIM_LINE,     (* 1 *)
                     TT_PRIM_QSPLINE); (* 2 *)

<* POP *>

TYPE POINTFX = RECORD
                      x : FIXED;
                      y : FIXED;
               END;
     PPOINTFX = POINTER  TO POINTFX;

TYPE TTPOLYCURVE = RECORD
                          wType : TT_PRIM_ENUM;
                          cpfx : WORD;
                          apfx : ARRAY [0..0] OF POINTFX;
                   END;

TYPE TTPOLYGONHEADER = RECORD
                              cb : DWORD;
                              dwType : DWORD;      (* must be TT_POLYGON_TYPE *)
                              pfxStart : POINTFX;
                       END;

TYPE GCP_ENUM = (GCP__DBCS,            (* 0 *)
                 GCP__REORDER,         (* 1 *)
                 GCO__2,
                 GCP__USEKERNING,      (* 3 *)
                 GCP__GLYPHSHAPE,      (* 4 *)
                 GCP__LIGATE,          (* 5 *)
                 GCP__6,
                 GCP__GLYPHINDEXING,   (* 7 *)
                 GCP__DIACRITIC,       (* 8 *)
                 GCP__9,
                 GCP__KASHIDA,         (* 10 *)
                 GCP__11, GCP__12,
                 GCP__13, GCP__14,
                 GCP__ERROR,           (* 15 *)

                 GCP__JUSTIFY,         (* 16 *)
                 GCP__NODIACRITICS,    (* 17 *)
                 FLI__GLYPHS,          (* 18 *)
                 GCP__CLASSIN,         (* 19 *)
                 GCP__MAXEXTENT,       (* 20 *)
                 GCP__JUSTIFYIN,       (* 21 *)
                 GCP__DISPLAYZWG,      (* 22 *)
                 GCP__SYMSWAPOFF,      (* 23 *)
                 GCP__NUMERICOVERRIDE, (* 24 *)
                 GCP__NEUTRALOVERRIDE, (* 25 *)
                 GCP__NUMERICSLATIN,   (* 26 *)
                 GCP__NUMERICSLOCAL);  (* 27 *)

     GCP_SET = SET OF GCP_ENUM;

CONST GCP_DBCS            = GCP_SET {GCP__DBCS};            (* 0x0001 *)
      GCP_REORDER         = GCP_SET {GCP__REORDER};         (* 0x0002 *)
      GCP_USEKERNING      = GCP_SET {GCP__USEKERNING};      (* 0x0008 *)
      GCP_GLYPHSHAPE      = GCP_SET {GCP__GLYPHSHAPE};      (* 0x0010 *)
      GCP_LIGATE          = GCP_SET {GCP__LIGATE};          (* 0x0020 *)
      GCP_GLYPHINDEXING   = GCP_SET {GCP__GLYPHINDEXING};   (* 0x0080 *)
      GCP_DIACRITIC       = GCP_SET {GCP__DIACRITIC};       (* 0x0100 *)
      GCP_KASHIDA         = GCP_SET {GCP__KASHIDA};         (* 0x0400 *)
      GCP_ERROR           = GCP_SET {GCP__ERROR};           (* 0x8000 *)

      FLI_MASK            = GCP_SET {GCP__12,
                                     GCP__LIGATE,
                                     GCP__GLYPHSHAPE,
                                     GCP__USEKERNING,
                                     GCP__REORDER,
                                     GCP__DBCS};            (* 0x103B *)

      GCP_JUSTIFY         = GCP_SET {GCP__JUSTIFY};         (* 0x00010000L *)
      GCP_NODIACRITICS    = GCP_SET {GCP__NODIACRITICS};    (* 0x00020000L *)
      FLI_GLYPHS          = GCP_SET {FLI__GLYPHS};          (* 0x00040000L *)
      GCP_CLASSIN         = GCP_SET {GCP__CLASSIN};         (* 0x00080000L *)
      GCP_MAXEXTENT       = GCP_SET {GCP__MAXEXTENT};       (* 0x00100000L *)
      GCP_JUSTIFYIN       = GCP_SET {GCP__JUSTIFYIN};       (* 0x00200000L *)
      GCP_DISPLAYZWG      = GCP_SET {GCP__DISPLAYZWG};      (* 0x00400000L *)
      GCP_SYMSWAPOFF      = GCP_SET {GCP__SYMSWAPOFF};      (* 0x00800000L *)
      GCP_NUMERICOVERRIDE = GCP_SET {GCP__NUMERICOVERRIDE}; (* 0x01000000L *)
      GCP_NEUTRALOVERRIDE = GCP_SET {GCP__NEUTRALOVERRIDE}; (* 0x02000000L *)
      GCP_NUMERICSLATIN   = GCP_SET {GCP__NUMERICSLATIN};   (* 0x04000000L *)
      GCP_NUMERICSLOCAL   = GCP_SET {GCP__NUMERICSLOCAL};   (* 0x08000000L *)


CONST GCPCLASS_LATIN                  =  1;
      GCPCLASS_HEBREW                 =  2;
      GCPCLASS_ARABIC                 =  2;
      GCPCLASS_NEUTRAL                =  3;
      GCPCLASS_LOCALNUMBER            =  4;
      GCPCLASS_LATINNUMBER            =  5;
      GCPCLASS_LATINNUMERICTERMINATOR =  6;
      GCPCLASS_LATINNUMERICSEPARATOR  =  7;
      GCPCLASS_NUMERICSEPARATOR       =  8;
      GCPCLASS_PREBOUNDLTR            = 80h;
      GCPCLASS_PREBOUNDRTL            = 40h;
      GCPCLASS_POSTBOUNDLTR           = 20h;
      GCPCLASS_POSTBOUNDRTL           = 10h;

CONST GCPGLYPH_LINKBEFORE = 8000h;
      GCPGLYPH_LINKAFTER  = 4000h;

TYPE GCP_RESULTSA = RECORD
                           lStructSize      : DWORD;
                           lpOutString      : PSTR;
                           lpOrder          : UINT;
                           lpDx             : INTARRAY;
                           lpCaretPos       : INTARRAY;
                           lpClass          : PSTR;
                           lpGlyphs         : PWSTR;
                           nGlyphs          : UINT;
                           nMaxFit          : INTEGER;
                    END;
    PGCP_RESULTSA = POINTER TO GCP_RESULTSA;

     GCP_RESULTSW = RECORD
                           lStructSize      : DWORD;
                           lpOutString      : PWSTR;
                           lpOrder          : UINT;
                           lpDx             : INTARRAY;
                           lpCaretPos       : INTARRAY;
                           lpClass          : PSTR;
                           lpGlyphs         : PWSTR;
                           nGlyphs          : UINT;
                           nMaxFit          : INTEGER;
                    END;
    PGCP_RESULTSW = POINTER TO GCP_RESULTSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE GCP_RESULTS = GCP_RESULTSW;
           PGCP_RESULTS = PGCP_RESULTSW;
<* ELSE *>
      TYPE GCP_RESULTS  = GCP_RESULTSA;
           PGCP_RESULTS = PGCP_RESULTSA;
<* END *>

(* bits defined in wFlags of RASTERIZER_STATUS *)

<* PUSH *> <* SETSIZE = "2" *>

TYPE TT_RASTERIZER_ENUM = (TT__AVAILABLE, (* 0 *)
                           TT__ENABLED);  (* 1 *)

     TT_RASTERIZER_SET = SET OF TT_RASTERIZER_ENUM;

<* POP *>

CONST TT_AVAILABLE = TT_RASTERIZER_SET {TT__AVAILABLE};  (* 0x0001 *)
      TT_ENABLED   = TT_RASTERIZER_SET {TT__ENABLED};    (* 0x0002 *)

TYPE RASTERIZER_STATUS = RECORD
                                nSize       : SHORT;
                                wFlags      : TT_RASTERIZER_SET;
                                nLanguageID : SHORT;
                         END;

(* Pixel format descriptor *)

(* PIXELFORMATDESCRIPTOR flags *)

TYPE PFD_ENUM = (PFD__DOUBLEBUFFER,          (*  0 *)
                 PFD__STEREO,                (*  1 *)
                 PFD__DRAW_TO_WINDOW,        (*  2 *)
                 PFD__DRAW_TO_BITMAP,        (*  3 *)
                 PFD__SUPPORT_GDI,           (*  4 *)
                 PFD__SUPPORT_OPENGL,        (*  5 *)
                 PFD__GENERIC_FORMAT,        (*  6 *)
                 PFD__NEED_PALETTE,          (*  7 *)
                 PFD__NEED_SYSTEM_PALETTE,   (*  8 *)
                 PFD__SWAP_EXCHANGE,         (*  9 *)
                 PFD__SWAP_COPY,             (* 10 *)
                 PFD__SWAP_LAYER_BUFFERS,    (* 11 *)
                 PFD__GENERIC_ACCELERATED,   (* 12 *)
                 PFD__13,PFD__14,PFD__15,
                 PFD__16,PFD__17,PFD__18,
                 PFD__19,PFD__20,PFD__21,
                 PFD__22,PFD__23,PFD__24,
                 PFD__25,PFD__26,PFD__27,
                 PFD__28,
                 PFD__DEPTH_DONTCARE,        (* 29 *)
                 PFD__DOUBLEBUFFER_DONTCARE, (* 30 *)
                 PFD__STEREO_DONTCARE);      (* 31 *)
     PFD_SET = SET OF PFD_ENUM;

CONST PFD_DOUBLEBUFFER        = PFD_SET {PFD__DOUBLEBUFFER       }; (* 0x00000001 *)
      PFD_STEREO              = PFD_SET {PFD__STEREO             }; (* 0x00000002 *)
      PFD_DRAW_TO_WINDOW      = PFD_SET {PFD__DRAW_TO_WINDOW     }; (* 0x00000004 *)
      PFD_DRAW_TO_BITMAP      = PFD_SET {PFD__DRAW_TO_BITMAP     }; (* 0x00000008 *)
      PFD_SUPPORT_GDI         = PFD_SET {PFD__SUPPORT_GDI        }; (* 0x00000010 *)
      PFD_SUPPORT_OPENGL      = PFD_SET {PFD__SUPPORT_OPENGL     }; (* 0x00000020 *)
      PFD_GENERIC_FORMAT      = PFD_SET {PFD__GENERIC_FORMAT     }; (* 0x00000040 *)
      PFD_NEED_PALETTE        = PFD_SET {PFD__NEED_PALETTE       }; (* 0x00000080 *)
      PFD_NEED_SYSTEM_PALETTE = PFD_SET {PFD__NEED_SYSTEM_PALETTE}; (* 0x00000100 *)
      PFD_SWAP_EXCHANGE       = PFD_SET {PFD__SWAP_EXCHANGE      }; (* 0x00000200 *)
      PFD_SWAP_COPY           = PFD_SET {PFD__SWAP_COPY          }; (* 0x00000400 *)
      PFD_SWAP_LAYER_BUFFERS  = PFD_SET {PFD__SWAP_LAYER_BUFFERS }; (* 0x00000800 *)
      PFD_GENERIC_ACCELERATED = PFD_SET {PFD__GENERIC_ACCELERATED}; (* 0x00001000 *)

(* PIXELFORMATDESCRIPTOR flags for use in ChoosePixelFormat only *)

      PFD_DEPTH_DONTCARE        = PFD_SET {PFD__DEPTH_DONTCARE       }; (* 0x20000000 *)
      PFD_DOUBLEBUFFER_DONTCARE = PFD_SET {PFD__DOUBLEBUFFER_DONTCARE}; (* 0x40000000 *)
      PFD_STEREO_DONTCARE       = PFD_SET {PFD__STEREO_DONTCARE      }; (* 0x80000000 *)

(* pixel types *)

<* PUSH *> <* ENUMSIZE = "1" *>

TYPE PFD_TYPE_ENUM = (PFD_TYPE_RGBA,        (* 0 *)
                      PFD_TYPE_COLORINDEX); (* 1 *)

<* POP *>

(* layer types *)

TYPE PFD_LAYER_TYPE = INT8;

CONST PFD_MAIN_PLANE       = PFD_LAYER_TYPE ( 0);
      PFD_OVERLAY_PLANE    = PFD_LAYER_TYPE ( 1);
      PFD_UNDERLAY_PLANE   = PFD_LAYER_TYPE (-1);

TYPE PIXELFORMATDESCRIPTOR = RECORD
         nSize           :     WORD;
         nVersion        :     WORD;
         dwFlags         :     PFD_SET;
         iPixelType      :     PFD_TYPE_ENUM;
         cColorBits      :     BYTE;
         cRedBits        :     BYTE;
         cRedShift       :     BYTE;
         cGreenBits      :     BYTE;
         cGreenShift     :     BYTE;
         cBlueBits       :     BYTE;
         cBlueShift      :     BYTE;
         cAlphaBits      :     BYTE;
         cAlphaShift     :     BYTE;
         cAccumBits      :     BYTE;
         cAccumRedBits   :     BYTE;
         cAccumGreenBits :     BYTE;
         cAccumBlueBits  :     BYTE;
         cAccumAlphaBits :     BYTE;
         cDepthBits      :     BYTE;
         cStencilBits    :     BYTE;
         cAuxBuffers     :     BYTE;
         iLayerType      :     PFD_LAYER_TYPE;
         bReserved       :     BYTE;
         dwLayerMask     :     DWORD;
         dwVisibleMask   :     DWORD;
         dwDamageMask    :     DWORD;
     END;

   PPIXELFORMATDESCRIPTOR = POINTER TO PIXELFORMATDESCRIPTOR;

TYPE OLDFONTENUMPROCA = PROCEDURE ((* IN *) PLOGFONTA, (* IN *) PTEXTMETRICA,
                                  ENUMFONT_SET, LPARAM) : INTEGER;

TYPE OLDFONTENUMPROCW = PROCEDURE ((* IN *) PLOGFONTW, (* IN *) PTEXTMETRICW,
                                  ENUMFONT_SET, LPARAM) : INTEGER;

TYPE FONTENUMPROCA = OLDFONTENUMPROCA;
TYPE FONTENUMPROCW = OLDFONTENUMPROCW;

TYPE ENUMFONTFAMEXPROCA = PROCEDURE (PENUMLOGFONTEXA, PNEWTEXTMETRICEXA,
                                     DWORD, LPARAM) : INTEGER;

TYPE ENUMFONTFAMEXPROCW = PROCEDURE (PENUMLOGFONTEXW, PNEWTEXTMETRICEXW,
                                     DWORD, LPARAM) : INTEGER;


<* IF DEFINED (UNICODE) THEN *>
       TYPE OLDFONTENUMPROC = OLDFONTENUMPROCW;
            FONTENUMPROC    = FONTENUMPROCW;
<* ELSE *>
       TYPE OLDFONTENUMPROC = OLDFONTENUMPROCA;
            FONTENUMPROC    = FONTENUMPROCA;
<* END *>

TYPE GOBJENUMPROC = PROCEDURE (PVOID, LPARAM) : INTEGER;

TYPE LINEDDAPROC  = PROCEDURE (INTEGER, INTEGER, LPARAM);

PROCEDURE AddFontResourceA (FileName : ARRAY OF CHAR)  : INTEGER;
PROCEDURE AddFontResourceW (FileName : ARRAY OF WCHAR) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST AddFontResource = AddFontResourceW;
<* ELSE *>
      CONST AddFontResource = AddFontResourceA;
<* END *>

PROCEDURE AnimatePalette (hpal : HPALETTE;
                          StartIndex, Entries : UINT;
                          pc : ARRAY OF PALETTEENTRY) : BOOL;

PROCEDURE Arc (hdc : HDC; left, top, right, bottom : INTEGER;
               XStart, YStart, XEnd, YEnd : INTEGER) : BOOL;

PROCEDURE BitBlt (hdcDest : HDC; XDest, YDest, Width, Height : INTEGER;
                  hdcSrc  : HDC; XSrc, YSrc : INTEGER;
                  operation : ROP) : BOOL;

PROCEDURE CancelDC (hdc : HDC) : BOOL;
PROCEDURE Chord (hdc : HDC; left, top, right, bottom : INTEGER;
                 XRadial1, YRadial1, XRadial2, YRadial2 : INTEGER) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE ChoosePixelFormat (hdc : HDC; pf : PIXELFORMATDESCRIPTOR) : INTEGER;
<* ELSE *>
PROCEDURE ChoosePixelFormat (hdc : HDC; pf : PPIXELFORMATDESCRIPTOR) : INTEGER;
<* END *> (*!*)
PROCEDURE CloseMetaFile (hdc : HDC) : HMETAFILE;
PROCEDURE CombineRgn (hRgnDest : HRGN; hRgnSrc1 : HRGN;
                      hRgnSrc2 : HRGN; CombineMode : RGN_COMBINE_ENUM) : RGN_CODE;

PROCEDURE CopyMetaFileA (hmf : HMETAFILE; fname : PCSTR) : HMETAFILE;
PROCEDURE CopyMetaFileW (hmf : HMETAFILE; fname : PCWSTR) : HMETAFILE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CopyMetaFile   = CopyMetaFileW;
<* ELSE *>
      CONST CopyMetaFile   = CopyMetaFileA;
<* END *>

PROCEDURE CreateBitmap (Width, Height : INTEGER;
                        Planes, BitsPerPel : UINT;
                        Bits : ARRAY OF SYSTEM.BYTE) : HBITMAP;
<* IF BACKEND # "C" THEN *>
PROCEDURE CreateBitmapIndirect    (Bitmap : BITMAP) : HBITMAP;
<* ELSE *>
PROCEDURE CreateBitmapIndirect    (Bitmap : PBITMAP) : HBITMAP;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE CreateBrushIndirect     (Brush : LOGBRUSH) : HBRUSH;
<* ELSE *>
PROCEDURE CreateBrushIndirect     (Brush : PLOGBRUSH) : HBRUSH;
<* END *> (*!*)
PROCEDURE CreateCompatibleBitmap  (hdc : HDC; Width, Height : INTEGER) : HBITMAP;
PROCEDURE CreateDiscardableBitmap (hdc : HDC; Width, Height : INTEGER) : HBITMAP;
PROCEDURE CreateCompatibleDC      (hdc : HDC) : HDC;

PROCEDURE CreateDCA (Driver : PCSTR;
                     Device : PCSTR;
                     Output : PCSTR;
                     InitData : PDEVMODEA) : HDC;  (* InitData can be NIL *)

PROCEDURE CreateDCW (Driver : PCWSTR;
                     Device : PCWSTR;
                     Output : PCWSTR;
                     InitData : PDEVMODEW) : HDC;  (* InitData can be NIL *)

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateDC = CreateDCW;
<* ELSE *>
      CONST CreateDC = CreateDCA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateDIBitmap (hdc      : HDC;
                          bmih     : BITMAPINFOHEADER;
                          dwInit   : CBM_ENUM;
                          Init     : ARRAY OF SYSTEM.BYTE;
                          bmi      : BITMAPINFOPARAM;
                          ColorUse : DIB_COLOR_ENUM) : HBITMAP;
<* ELSE *>
PROCEDURE CreateDIBitmap (hdc      : HDC;
                          bmih     : PBITMAPINFOHEADER;
                          dwInit   : CBM_ENUM;
                          Init     : ARRAY OF SYSTEM.BYTE;
                          bmi      : PBITMAPINFOPARAM;
                          ColorUse : DIB_COLOR_ENUM) : HBITMAP;
<* END *> (*!*)

PROCEDURE CreateDIBPatternBrush (hglbPackedDIB : HGLOBAL;
                                 ColorSpec : DIB_COLOR_ENUM) : HBRUSH;
PROCEDURE CreateDIBPatternBrushPt (PackedDIB : ARRAY OF SYSTEM.BYTE;
                                   ColorUse : DIB_COLOR_ENUM) : HBRUSH;
PROCEDURE CreateEllipticRgn (LeftRect, TopRect,
                             RightRect, BottomRect : INTEGER) : HRGN;
<* IF BACKEND # "C" THEN *>
PROCEDURE CreateEllipticRgnIndirect (rc : RECT) : HRGN;
<* ELSE *>
PROCEDURE CreateEllipticRgnIndirect (rc : PRECT) : HRGN;
<* END *> (*!*)

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateFontIndirectA (logfont : LOGFONTA) : HFONT;
<* ELSE *>
PROCEDURE CreateFontIndirectA (logfont : PLOGFONTA) : HFONT;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE CreateFontIndirectW (logfont : LOGFONTW) : HFONT;
<* ELSE *>
PROCEDURE CreateFontIndirectW (logfont : PLOGFONTW) : HFONT;
<* END *> (*!*)

PROCEDURE CreateFontA (Height, Width   : INTEGER;
                       Escapement      : INTEGER;
                       Orientation     : INTEGER;
                       Weight          : FW_TYPE;
                       Italic          : BOOL;
                       Underline       : BOOL;
                       StrikeOut       : BOOL;
                       CharSet         : CHARSET_TYPE;
                       OutputPrecision : OUT_PRECIS_ENUM;
                       ClipPrecision   : CLIP_PRECIS_SET;
                       Quality         : QUALITY_ENUM;
                       PitchAndFamily  : PITCH_AND_FAMILY_SET;
                       FaceName        : PCSTR) : HFONT;

PROCEDURE CreateFontW (Height, Width   : INTEGER;
                       Escapement      : INTEGER;
                       Orientation     : INTEGER;
                       Weight          : FW_TYPE;
                       Italic          : BOOL;
                       Underline       : BOOL;
                       StrikeOut       : BOOL;
                       CharSet         : CHARSET_TYPE;
                       OutputPrecision : OUT_PRECIS_ENUM;
                       ClipPrecision   : CLIP_PRECIS_SET;
                       Quality         : QUALITY_ENUM;
                       PitchAndFamily  : PITCH_AND_FAMILY_SET;
                       FaceName        : PCWSTR) : HFONT;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateFontIndirect = CreateFontIndirectW;
            CreateFont = CreateFontW;
<* ELSE *>
      CONST CreateFontIndirect = CreateFontIndirectA;
            CreateFont = CreateFontA;
<* END *>

PROCEDURE CreateHatchBrush   (Style : HS_ENUM; Color : COLORREF) : HBRUSH;

PROCEDURE CreateICA (Driver : PCSTR;
                     Device : ARRAY OF CHAR;
                     Output : PCSTR;
         (* IN NIL*) InitData : PDEVMODEA) : HDC;

PROCEDURE CreateICW (Driver : PCSTR;
                     Device : ARRAY OF WCHAR;
                     Output : PCSTR;
        (* IN NIL *) InitData : PDEVMODEW) : HDC;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateIC = CreateICW;
<* ELSE *>
      CONST CreateIC = CreateICA;
<* END *>

PROCEDURE CreateMetaFileA (fname : PCSTR) : HDC;  (* fname can be NIL *)
PROCEDURE CreateMetaFileW (fname : PCWSTR) : HDC; (* fname can be NIL *)

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateMetaFile = CreateMetaFileW;
<* ELSE *>
      CONST CreateMetaFile = CreateMetaFileA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE CreatePalette (palette : LOGPALETTE) : HPALETTE;
<* ELSE *>
PROCEDURE CreatePalette (palette : PLOGPALETTE) : HPALETTE;
<* END *> (*!*)
PROCEDURE CreatePen (PenStyle : PS_SET;
                     Width : INTEGER;
                     Color : COLORREF) : HPEN;
<* IF BACKEND # "C" THEN *>
PROCEDURE CreatePenIndirect (lgpn : LOGPEN) : HPEN;
<* ELSE *>
PROCEDURE CreatePenIndirect (lgpn : PLOGPEN) : HPEN;
<* END *> (*!*)
PROCEDURE CreatePolyPolygonRgn (pt : ARRAY OF POINT;
                                PolyCounts : ARRAY OF INTEGER;
                                nCount : INTEGER;
                                PolyFillMode : POLYFILL_ENUM) : HRGN;

PROCEDURE CreatePatternBrush (bitmap : HBITMAP) : HBRUSH;
PROCEDURE CreateRectRgn (LeftRect, TopRect,
                         RightRect, BottomRect : INTEGER) : HRGN;
<* IF BACKEND # "C" THEN *>
PROCEDURE CreateRectRgnIndirect (rc : RECT) : HRGN;
<* ELSE *>
PROCEDURE CreateRectRgnIndirect (rc : PRECT) : HRGN;
<* END *> (*!*)
PROCEDURE CreateRoundRectRgn (LeftRect, TopRect,
                              RightRect, BottomRect,
                              WidthEllipse, HeightEllipse : INTEGER) : HRGN;

PROCEDURE CreateScalableFontResourceA (Hidden      : BOOL;
                                       FontRes     : ARRAY OF CHAR;
                                       FontFile    : ARRAY OF CHAR;
                             (* NIL *) CurrentPath : PSTR) : BOOL;
PROCEDURE CreateScalableFontResourceW (Hidden      : BOOL;
                                       FontRes     : ARRAY OF CHAR;
                                       FontFile    : ARRAY OF WCHAR;
                             (* NIL *) CurrentPath : PCWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateScalableFontResource = CreateScalableFontResourceW;
<* ELSE *>
      CONST CreateScalableFontResource = CreateScalableFontResourceA;
<* END *>

PROCEDURE CreateSolidBrush   (Color : COLORREF) : HBRUSH;

PROCEDURE DeleteDC (hdc : HDC) : BOOL;
PROCEDURE DeleteMetaFile (mf : HMETAFILE) : BOOL;
PROCEDURE DeleteObject (hGdiObj : HGDIOBJ) : BOOL;
PROCEDURE DescribePixelFormat (hdc : HDC;
                               pixelformat : INTEGER;
                               size : UINT;
                               VAR [NIL] buffer : PIXELFORMATDESCRIPTOR) : INTEGER;

(* define types of pointers to ExtDeviceMode() and DeviceCapabilities()
 * functions for Win 3.1 compatibility
 *)

TYPE PFNDEVMODE = PROCEDURE (HWND, HMODULE, PDEVMODE, PSTR, PSTR, PDEVMODE, PSTR, UINT) : UINT;

TYPE PFNDEVCAPS = PROCEDURE (PSTR, PSTR, UINT, PSTR, PDEVMODE) : DWORD;

(* mode selections for the device mode function *)

TYPE _DM_ENUM = (DM__UPDATE,   (* 1 *)
                 DM__COPY,     (* 2 *)
                 DM__PROMPT,   (* 4 *)
                 DM__MODIFY);  (* 8 *)
     _DM_SET = SET OF _DM_ENUM;

CONST DM_UPDATE = _DM_SET {DM__UPDATE}; (* 1 *)
      DM_COPY   = _DM_SET {DM__COPY};   (* 2 *)
      DM_PROMPT = _DM_SET {DM__PROMPT}; (* 4 *)
      DM_MODIFY = _DM_SET {DM__MODIFY}; (* 8 *)

      DM_IN_BUFFER   = DM_MODIFY;
      DM_IN_PROMPT   = DM_PROMPT;
      DM_OUT_BUFFER  = DM_COPY;
      DM_OUT_DEFAULT = DM_UPDATE;

(* device capabilities indices *)

TYPE DC_TYPE = (DC_0,
                DC_FIELDS,            (*  1 *)
                DC_PAPERS,            (*  2 *)
                DC_PAPERSIZE,         (*  3 *)
                DC_MINEXTENT,         (*  4 *)
                DC_MAXEXTENT,         (*  5 *)
                DC_BINS,              (*  6 *)
                DC_DUPLEX,            (*  7 *)
                DC_SIZE,              (*  8 *)
                DC_EXTRA,             (*  9 *)
                DC_VERSION,           (* 10 *)
                DC_DRIVER,            (* 11 *)
                DC_BINNAMES,          (* 12 *)
                DC_ENUMRESOLUTIONS,   (* 13 *)
                DC_FILEDEPENDENCIES,  (* 14 *)
                DC_TRUETYPE,          (* 15 *)
                DC_PAPERNAMES,        (* 16 *)
                DC_ORIENTATION,       (* 17 *)
                DC_COPIES,            (* 18 *)
                DC_BINADJUST,         (* 19 *)
                DC_EMF_COMPLIANT,     (* 20 *)
                DC_DATATYPE_PRODUCED, (* 21 *)
                DC_COLLATE,           (* 22 *)
                DC_MANUFACTURER,      (* 23 *)
                DC_MODEL);            (* 24 *)

(* bit fields of the return value (DWORD) for DC_TRUETYPE *)

TYPE DCTT_ENUM = (DCTT__BITMAP,             (* 0 *)
                  DCTT__DOWNLOAD,           (* 1 *)
                  DCTT__SUBDEV,             (* 2 *)
                  DCTT__DOWNLOAD_OUTLINE);  (* 3 *)
     DCTT_SET  = SET OF DCTT_ENUM;

CONST DCTT_BITMAP           = DCTT_SET {DCTT__BITMAP};           (* 0x0000001L *)
      DCTT_DOWNLOAD         = DCTT_SET {DCTT__DOWNLOAD};         (* 0x0000002L *)
      DCTT_SUBDEV           = DCTT_SET {DCTT__SUBDEV};           (* 0x0000004L *)
      DCTT_DOWNLOAD_OUTLINE = DCTT_SET {DCTT__DOWNLOAD_OUTLINE}; (* 0x0000008L *)


(* return values for DC_BINADJUST *)

CONST DCBA_FACEUPNONE       = 0000h;
      DCBA_FACEUPCENTER     = 0001h;
      DCBA_FACEUPLEFT       = 0002h;
      DCBA_FACEUPRIGHT      = 0003h;
      DCBA_FACEDOWNNONE     = 0100h;
      DCBA_FACEDOWNCENTER   = 0101h;
      DCBA_FACEDOWNLEFT     = 0102h;
      DCBA_FACEDOWNRIGHT    = 0103h;

PROCEDURE DeviceCapabilitiesA (DriverName : ARRAY OF CHAR;
                               PortDeviceName : ARRAY OF CHAR;
                               Capability : DC_TYPE;
                               Output : PSTR;
                  (* IN NIL *) dev : PDEVMODEA) : INTEGER;
PROCEDURE DeviceCapabilitiesW (DriverName : ARRAY OF WCHAR;
                               PortDeviceName : ARRAY OF WCHAR;
                               Capability : DC_TYPE;
                               Output : PWSTR;
                  (* IN NIL *) dev : PDEVMODEW) : INTEGER;

<* IF DEFINED (UNICODE) THEN*>
   CONST DeviceCapabilities = DeviceCapabilitiesW;
<* ELSE *>
   CONST DeviceCapabilities = DeviceCapabilitiesA;
<* END *>

PROCEDURE DrawEscape (hdc : HDC; Escape : INTEGER;
                      InputSize : INTEGER;
                      input : PCBYTE) : INTEGER;

PROCEDURE Ellipse (hdc : HDC; left, top, right, bottom : INTEGER) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE EnumFontFamiliesExA (hdc    : HDC;
                               lf     : LOGFONTA;
                               proc   : ENUMFONTFAMEXPROCA;
                               lparam : LPARAM;
                               flags  : DWORD) : INTEGER;
<* ELSE *>
PROCEDURE EnumFontFamiliesExA (hdc    : HDC;
                               lf     : PLOGFONTA;
                               proc   : ENUMFONTFAMEXPROCA;
                               lparam : LPARAM;
                               flags  : DWORD) : INTEGER;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE EnumFontFamiliesExW (hdc    : HDC;
                               lf     : LOGFONTW;
                               proc   : ENUMFONTFAMEXPROCW;
                               lparam : LPARAM;
                               flags  : DWORD) : INTEGER;
<* ELSE *>
PROCEDURE EnumFontFamiliesExW (hdc    : HDC;
                               lf     : PLOGFONTW;
                               proc   : ENUMFONTFAMEXPROCW;
                               lparam : LPARAM;
                               flags  : DWORD) : INTEGER;
<* END *> (*!*)

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumFontFamiliesEx = EnumFontFamiliesExW;
<* ELSE *>
      CONST EnumFontFamiliesEx = EnumFontFamiliesExA;
<* END *>

PROCEDURE EnumFontFamiliesA (hdc : HDC;
                             Family : PCSTR;
                             EnumFontFamProc : FONTENUMPROCA;
                             lParam : LPARAM) : INTEGER;

PROCEDURE EnumFontFamiliesW (hdc : HDC;
                             Family : PCWSTR;
                             EnumFontFamProc : FONTENUMPROCW;
                             lParam : LPARAM) : INTEGER;

PROCEDURE EnumFontsA (hdc : HDC;
                      FaceName : PCSTR;
                      EnumFontProc : FONTENUMPROCA;
                      lParam : LPARAM) : INTEGER;

PROCEDURE EnumFontsW (hdc : HDC;
                      FaceName : PCWSTR;
                      EnumFontProc : FONTENUMPROCW;
                      lParam : LPARAM) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumFontFamilies = EnumFontFamiliesW;
            EnumFonts        = EnumFontsW;
<* ELSE *>
      CONST EnumFontFamilies = EnumFontFamiliesA;
            EnumFonts        = EnumFontsA;
<* END *>

PROCEDURE EnumObjects (hdc : HDC;
                       ObjectType : OBJ_ENUM;
                       ObjectFunc : GOBJENUMPROC;
                       lParam : LPARAM) : INTEGER;

PROCEDURE EqualRgn (hRgn1 : HRGN; hRgn2 : HRGN) : BOOL;
PROCEDURE Escape (hdc : HDC; Escape : INTEGER; InputSize : INTEGER;
                  input : PCBYTE; output : PBYTE) : INTEGER;
PROCEDURE ExtEscape (hdc : HDC; Escape : INTEGER;
                     InputSize : INTEGER; input : PCBYTE;
                     OutputSize : INTEGER; output : PBYTE) : INTEGER;
PROCEDURE ExcludeClipRect (hdc : HDC; left, top, right, bottom : INTEGER) : RGN_CODE;
<* IF BACKEND # "C" THEN *>
PROCEDURE ExtCreateRegion ((* IN NIL *) Xform : PXFORM;
                           nCount : DWORD;
                           RgnData : RGNDATA) : HRGN;
<* ELSE *>
PROCEDURE ExtCreateRegion ((* IN NIL *) Xform : PXFORM;
                           nCount : DWORD;
                           RgnData : PRGNDATA) : HRGN;
<* END *> (*!*)
PROCEDURE ExtFloodFill (hdc : HDC; x, y : INTEGER; color : COLORREF;
                        mode : FLOODFILL_ENUM) : BOOL;
PROCEDURE FillRgn (hdc : HDC; hrgn : HRGN; hbrush : HBRUSH) : BOOL;
PROCEDURE FloodFill (hdc : HDC; x, y : INTEGER; color : COLORREF) : BOOL;
PROCEDURE FrameRgn  (hdc : HDC; hrgn : HRGN; hbrush : HBRUSH;
                     width, height : INTEGER) : BOOL;
PROCEDURE GetROP2 (hdc : HDC) : ROP2;
PROCEDURE GetAspectRatioFilterEx (hdc : HDC; VAR AspectRatio : SIZEL) : BOOL;
PROCEDURE GetBkColor (hdc : HDC) : COLORREF;
PROCEDURE GetBkMode (hdc : HDC) : BKMODE_ENUM;
PROCEDURE GetBitmapBits (hbmp : HBITMAP;
                         BufSize : LONG;
                         VAR Bits : ARRAY OF SYSTEM.BYTE) : LONG;
PROCEDURE GetBitmapDimensionEx (hbmp : HBITMAP; VAR Dimension : SIZEL) : BOOL;
PROCEDURE GetBoundsRect (hdc : HDC; VAR rect : RECT; flags : DCB__SET) : DCB__SET;
PROCEDURE GetBrushOrgEx (dc : HDC; VAR p : POINT) : BOOL;

PROCEDURE GetCharWidthA (hdc : HDC; FirstChar, LastChar : UINT;
                         VAR Buffer : ARRAY OF INTEGER) : BOOL;
PROCEDURE GetCharWidthW (hdc : HDC; FirstChar, LastChar : UINT;
                         VAR Buffer : ARRAY OF INTEGER) : BOOL;

PROCEDURE GetCharWidth32A (hdc : HDC; FirstChar, LastChar : UINT;
                           VAR Buffer : ARRAY OF INTEGER) : BOOL;
PROCEDURE GetCharWidth32W (hdc : HDC; FirstChar, LastChar : UINT;
                           VAR Buffer : ARRAY OF INTEGER) : BOOL;

PROCEDURE GetCharWidthFloatA (hdc : HDC; FirstChar, LastChar : UINT;
                              VAR Buffer : ARRAY OF FLOAT) : BOOL;
PROCEDURE GetCharWidthFloatW (hdc : HDC; FirstChar, LastChar : UINT;
                              VAR Buffer : ARRAY OF FLOAT) : BOOL;

PROCEDURE GetCharABCWidthsA (hdc : HDC; FirstChar, LastChar : UINT;
                             VAR abc : ARRAY OF ABC) : BOOL;
PROCEDURE GetCharABCWidthsW (hdc : HDC; FirstChar, LastChar : UINT;
                             VAR abc : ARRAY OF ABC) : BOOL;

PROCEDURE GetCharABCWidthsFloatA (hdc : HDC; FirstChar, LastChar : UINT;
                                  VAR abcflt : ARRAY OF ABCFLOAT) : BOOL;
PROCEDURE GetCharABCWidthsFloatW (hdc : HDC; FirstChar, LastChar : UINT;
                                  VAR abcflt : ARRAY OF ABCFLOAT) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetCharWidth          = GetCharWidthW;
            GetCharWidth32        = GetCharWidth32W;
            GetCharWidthFloat     = GetCharWidthFloatW;
            GetCharABCWidths      = GetCharABCWidthsW;
            GetCharABCWidthsFloat = GetCharABCWidthsFloatW;
<* ELSE *>
      CONST GetCharWidth          = GetCharWidthA;
            GetCharWidth32        = GetCharWidth32A;
            GetCharWidthFloat     = GetCharWidthFloatA;
            GetCharABCWidths      = GetCharABCWidthsA;
            GetCharABCWidthsFloat = GetCharABCWidthsFloatA;
<* END *>

PROCEDURE GetClipBox (hdc : HDC; VAR rc : RECT) : RGN_CODE;
PROCEDURE GetClipRgn (hdc : HDC; hrgn : HRGN) : INTEGER;
PROCEDURE GetMetaRgn (hdc : HDC; hrgn : HRGN) : RGN_CODE;
PROCEDURE GetCurrentObject (hdc : HDC; ObjectType : OBJ_ENUM) : HGDIOBJ;
PROCEDURE GetCurrentPositionEx (hdc : HDC; VAR position : POINT) : BOOL;
PROCEDURE GetDeviceCaps (hdc : HDC; index : INTEGER) : INTEGER;
PROCEDURE GetDIBits (hdc : HDC; hbmp : HBITMAP;
                     StartScan, ScanLines : UINT;
                     Bits : PBYTE;
                     VAR bmi : BITMAPINFOPARAM;
                     ColorUse : DIB_COLOR_ENUM) : INTEGER;
PROCEDURE GetFontData (hdc : HDC;
                       Table : DWORD;
                       Offset : DWORD;
                       Buffer : PBYTE;
                       Length : DWORD) : DWORD;

PROCEDURE GetGlyphOutlineA (hdc : HDC; Char : UINT;
                            Format : GGO_ENUM;
                            VAR pgm : GLYPHMETRICS;
                            BufSize : DWORD;
                            Buffr : PBYTE;
              (* IN, NIL *) mat2 : PMAT2) : DWORD;

PROCEDURE GetGlyphOutlineW (hdc : HDC; Char : UINT;
                            Format : GGO_ENUM;
                            VAR pgm : GLYPHMETRICS;
                            BufSize : DWORD;
                            Buffr : PBYTE;
              (* IN, NIL *) mat2 : PMAT2) : DWORD;
<* IF DEFINED (UNICODE) THEN *>
      CONST GetGlyphOutline = GetGlyphOutlineW;
<* ELSE *>
      CONST GetGlyphOutline = GetGlyphOutlineA;
<* END *>

PROCEDURE GetGraphicsMode (hdc : HDC) : GM_ENUM;
PROCEDURE GetMapMode (hdc : HDC) : MM_ENUM;

PROCEDURE GetMetaFileBitsEx (mf : HMETAFILE; sz : UINT;
                             Buffer : PBYTE) : UINT;

PROCEDURE GetMetaFileA (fname : ARRAY OF CHAR)  : HMETAFILE;
PROCEDURE GetMetaFileW (fname : ARRAY OF WCHAR) : HMETAFILE;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetMetaFile = GetMetaFileW;
<* ELSE *>
      CONST GetMetaFile = GetMetaFileA;
<* END *>

PROCEDURE GetNearestColor (hdc : HDC; color : COLORREF) : COLORREF;
PROCEDURE GetNearestPaletteIndex (hpal : HPALETTE; color : COLORREF) : UINT;
PROCEDURE GetObjectType (h : HGDIOBJ) : OBJ_ENUM;

<* IF NOT DEFINED (NOTEXTMETRIC) THEN *>

PROCEDURE GetOutlineTextMetricsA (hdc : HDC; BufLen : UINT;
                                  VAR Buf : ARRAY OF OUTLINETEXTMETRICA) : UINT;
PROCEDURE GetOutlineTextMetricsW (hdc : HDC; BufLen : UINT;
                                  VAR Buf : ARRAY OF OUTLINETEXTMETRICW) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetOutlineTextMetrics = GetOutlineTextMetricsW;
<* ELSE *>
      CONST GetOutlineTextMetrics = GetOutlineTextMetricsA;
<* END *>

<* END *> (* NOT DEFINED (NOTEXTMETRIC) *)

PROCEDURE GetPaletteEntries (hpal : HPALETTE;
                             StartIndex, Entries : UINT;
                             VAR [NIL] pc : PALETTEENTRY) : UINT;

PROCEDURE GetPixel (hdc : HDC; x, y : INTEGER) : COLORREF;
PROCEDURE GetPixelFormat (hdc : HDC) : INTEGER;
PROCEDURE GetPolyFillMode (hdc : HDC) : POLYFILL_ENUM;
PROCEDURE GetRasterizerCaps (VAR rs : RASTERIZER_STATUS; len : UINT) : BOOL;
PROCEDURE GetRegionData (hRgn : HRGN; BufSize : DWORD;
                         VAR [NIL] RgnData : RGNDATA) : DWORD;
PROCEDURE GetRgnBox (hRgn : HRGN; VAR rect : RECT) : RGN_CODE;
PROCEDURE GetStockObject (Object : STOCK_ENUM) : HGDIOBJ;
PROCEDURE GetStretchBltMode (hdc : HDC) : STRETCH_ENUM;
PROCEDURE GetSystemPaletteEntries (hdc : HDC;
                                   StartIndex, Entries : UINT;
                                   VAR [NIL] pc : PALETTEENTRY) : UINT;

PROCEDURE GetSystemPaletteUse (hdc : HDC) : SYSPAL_ENUM;
PROCEDURE GetTextCharacterExtra (hdc : HDC) : INTEGER;
PROCEDURE GetTextAlign (hdc : HDC) : TA_SET;
PROCEDURE GetTextColor (hdc : HDC) : COLORREF;

PROCEDURE GetTextExtentPointA (hdc : HDC; text : ARRAY OF CHAR;
                               len : INTEGER; VAR size : SIZEL) : BOOL;
PROCEDURE GetTextExtentPointW (hdc : HDC; text : ARRAY OF WCHAR;
                               len : INTEGER; VAR size : SIZEL) : BOOL;

PROCEDURE GetTextExtentPoint32A (hdc : HDC; text : ARRAY OF CHAR;
                                 len : INTEGER; VAR size : SIZEL) : BOOL;
PROCEDURE GetTextExtentPoint32W (hdc : HDC; text : ARRAY OF WCHAR;
                                 len : INTEGER; VAR size : SIZEL) : BOOL;

PROCEDURE GetTextExtentExPointA (hdc : HDC; text : ARRAY OF CHAR;
                                 len : INTEGER; MaxExtent : INTEGER;
                                 VAR fit : INTEGER;
                                 VAR [NIL] dx : ARRAY OF INTEGER;
                                 VAR size : SIZEL) : BOOL;

PROCEDURE GetTextExtentExPointW (hdc : HDC; text : ARRAY OF WCHAR;
                                 len : INTEGER; MaxExtent : INTEGER;
                                 VAR fit : INTEGER;
                                 VAR [NIL] dx : ARRAY OF INTEGER;
                                 VAR size : SIZEL) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetTextExtentPoint = GetTextExtentPointW;
            GetTextExtentPoint32 = GetTextExtentPoint32W;
            GetTextExtentExPoint = GetTextExtentExPointW;
<* ELSE *>
      CONST GetTextExtentPoint = GetTextExtentPointA;
            GetTextExtentPoint32 = GetTextExtentPoint32A;
            GetTextExtentExPoint = GetTextExtentExPointA;
<* END *>

PROCEDURE GetTextCharset (hdc : HDC) : CHARSET_TYPE;
PROCEDURE GetTextCharsetInfo (hdc : HDC;
                              VAR[NIL] Sig : FONTSIGNATURE;
                              dwFlags : DWORD) : CHARSET_TYPE;
PROCEDURE TranslateCharsetInfo (lpSrc : PDWORD;
                                VAR Cs : CHARSETINFO;
                                dwFlags : TCI_ENUM) : BOOL;
PROCEDURE GetFontLanguageInfo  (hdc : HDC) : DWORD;

PROCEDURE GetCharacterPlacementA (hdc : HDC; string : ARRAY OF CHAR;
                                  count : INTEGER; MaxExtent : INTEGER;
                                  VAR results : GCP_RESULTSA;
                                  flags : GCP_SET) : DWORD;
PROCEDURE GetCharacterPlacementW (hdc : HDC; string : ARRAY OF WCHAR;
                                  count : INTEGER; MaxExtent : INTEGER;
                                  VAR results : GCP_RESULTSW;
                                  flags : GCP_SET) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetCharacterPlacement = GetCharacterPlacementW;
<* ELSE *>
      CONST GetCharacterPlacement = GetCharacterPlacementA;
<* END *>

PROCEDURE GetViewportExtEx (hdc : HDC; VAR ext : SIZEL) : BOOL;
PROCEDURE GetViewportOrgEx    (hdc : HDC; VAR org : POINT) : BOOL;
PROCEDURE GetWindowExtEx (hdc : HDC; VAR ext : SIZEL) : BOOL;
PROCEDURE GetWindowOrgEx (hdc : HDC; VAR org : POINT) : BOOL;
PROCEDURE IntersectClipRect (hdc : HDC; left, top, right, bottom : INTEGER) : RGN_CODE;
PROCEDURE InvertRgn (hdc : HDC; hrgn : HRGN) : BOOL;

PROCEDURE LineDDA (xStart, YStart, XEnd, YEnd : INTEGER;
                   linefunc : LINEDDAPROC; lparam : LPARAM) : BOOL;

PROCEDURE LineTo (hdc : HDC; x, y : INTEGER) : BOOL;
PROCEDURE MaskBlt (hdcDest : HDC; XDest, YDest, Width, Height : INTEGER;
                   hdcSrc  : HDC; XSrc, YSrc : INTEGER;
                   Mask : HBITMAP; xMask, yMask : INTEGER;
                   rop : ROP4) : BOOL;

(* This structure was not present in wingdi.h; POINT * was used instead *)

TYPE PARALLELOGRAM = RECORD
                            UpperLeft  : POINT;
                            UpperRight : POINT;
                            LowerLeft  : POINT;
                     END;
     PPARALLELOGRAM = POINTER TO PARALLELOGRAM;

<* IF BACKEND # "C" THEN *>
PROCEDURE PlgBlt (hdcDest : HDC; plg : PARALLELOGRAM;
                  hdcSrc : HDC; XSrc, YSrc, Width, Height : INTEGER;
                  Mask : HBITMAP; xMask, yMask : INTEGER) : BOOL;
<* ELSE *>
PROCEDURE PlgBlt (hdcDest : HDC; plg : PPARALLELOGRAM;
                  hdcSrc : HDC; XSrc, YSrc, Width, Height : INTEGER;
                  Mask : HBITMAP; xMask, yMask : INTEGER) : BOOL;
<* END *>

PROCEDURE OffsetClipRgn (hdc : HDC; dx, dy : INTEGER) : RGN_CODE;
PROCEDURE OffsetRgn (hRgn : HRGN; x, y : INTEGER) : RGN_CODE;
PROCEDURE PatBlt (hdc : HDC; Left, Top, Width, Height : INTEGER;
                  operation : ROP) : BOOL;
PROCEDURE Pie (hdc : HDC; left, top, right, bottom : INTEGER;
               XRadial1, YRadial1, XRadial2, YRadial2 : INTEGER) : BOOL;
PROCEDURE PlayMetaFile (hdc : HDC; hmf : HMETAFILE) : BOOL;
PROCEDURE PaintRgn  (hdc : HDC; hrgn : HRGN) : BOOL;
PROCEDURE PolyPolygon (hdc : HDC; points : ARRAY OF POINT;
                       polypoints : ARRAY OF INTEGER; n : INTEGER) : BOOL;

PROCEDURE PtInRegion   (hRgn : HRGN; x, y : INTEGER) : BOOL;
PROCEDURE PtVisible (hdc : HDC; x, y : INTEGER) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE RectInRegion (hRgn : HRGN; rect : RECT) : BOOL;
<* ELSE *>
PROCEDURE RectInRegion (hRgn : HRGN; rect : PRECT) : BOOL;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE RectVisible (hdc : HDC; rect : RECT) : BOOL;
<* ELSE *>
PROCEDURE RectVisible (hdc : HDC; rect : PRECT) : BOOL;
<* END *> (*!*)
PROCEDURE Rectangle (hdc : HDC; left, top, right, bottom : INTEGER) : BOOL;
PROCEDURE RestoreDC (hdc : HDC; s : INTEGER) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE ResetDCA (hdc : HDC; InitData : DEVMODEA) : HDC;
<* ELSE *>
PROCEDURE ResetDCA (hdc : HDC; InitData : PDEVMODEA) : HDC;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE ResetDCW (hdc : HDC; InitData : DEVMODEW) : HDC;
<* ELSE *>
PROCEDURE ResetDCW (hdc : HDC; InitData : PDEVMODEW) : HDC;
<* END *> (*!*)

<* IF DEFINED (UNICODE) THEN *>
      CONST ResetDC = ResetDCW;
<* ELSE *>
      CONST ResetDC = ResetDCA;
<* END *>

PROCEDURE RealizePalette (hdc : HDC) : UINT;

PROCEDURE RemoveFontResourceA (FileName : ARRAY OF CHAR) : BOOL;
PROCEDURE RemoveFontResourceW (FileName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST RemoveFontResource = RemoveFontResourceW;
<* ELSE *>
      CONST RemoveFontResource = RemoveFontResourceA;
<* END *>

PROCEDURE RoundRect (hdc : HDC; left, top, right, bottom,
                                width, height : INTEGER) : BOOL;

PROCEDURE ResizePalette (hpal : HPALETTE; nEntries : UINT) : BOOL;
PROCEDURE SaveDC    (hdc : HDC) : INTEGER;
PROCEDURE SelectClipRgn     (hdc : HDC; hrgn : HRGN) : RGN_CODE;
PROCEDURE ExtSelectClipRgn  (hdc : HDC; hrgn : HRGN; mode : RGN_COMBINE_ENUM) : RGN_CODE;
PROCEDURE SetMetaRgn (hdc : HDC) : RGN_CODE;
PROCEDURE SelectObject (hdc : HDC; hObject : HGDIOBJ) : HGDIOBJ;
PROCEDURE SelectPalette (hdc : HDC; hpl : HPALETTE;
                         ForceBackGround : BOOL) : HPALETTE;

PROCEDURE SetBkColor (hdc : HDC; color : COLORREF) : COLORREF;
PROCEDURE SetBkMode (hdc : HDC; mode : BKMODE_ENUM) : BKMODE_ENUM;
PROCEDURE SetBitmapBits (hbmp : HBITMAP; NBits : DWORD;
                         Bits : ARRAY OF SYSTEM.BYTE) : LONG;
PROCEDURE SetBoundsRect (hdc : HDC; (* IN NIL *) rect : PRECT; flags : DCB__SET) : DCB__SET;
<* IF BACKEND # "C" THEN *>
PROCEDURE SetDIBits (hdc : HDC; hbmp : HBITMAP;
                     StartScan, ScanLines : UINT;
                     Bits : ARRAY OF SYSTEM.BYTE;
                     bmi : BITMAPINFOPARAM; (*!*)
                     ColorUse : DIB_COLOR_ENUM) : INTEGER;
<* ELSE *>
PROCEDURE SetDIBits (hdc : HDC; hbmp : HBITMAP;
                     StartScan, ScanLines : UINT;
                     Bits : ARRAY OF SYSTEM.BYTE;
                     bmi : PBITMAPINFOPARAM; (*!*)
                     ColorUse : DIB_COLOR_ENUM) : INTEGER;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE SetDIBitsToDevice (hdcDest : HDC; XDest, YDest, Width, Height : INTEGER;
                             XSrc, YSrc : INTEGER;
                             StartScan, ScanLines : UINT;
                             Bits : ARRAY OF BYTE;
                             BitsInfo : BITMAPINFOPARAM;
                             ColorUse : DIB_COLOR_ENUM) : INTEGER;
<* ELSE *>
PROCEDURE SetDIBitsToDevice (hdcDest : HDC; XDest, YDest, Width, Height : INTEGER;
                             XSrc, YSrc : INTEGER;
                             StartScan, ScanLines : UINT;
                             Bits : ARRAY OF BYTE;
                             BitsInfo : PBITMAPINFOPARAM;
                             ColorUse : DIB_COLOR_ENUM) : INTEGER;
<* END *>
PROCEDURE SetMapperFlags (hdc : HDC; flag : DWORD) : DWORD;
PROCEDURE SetGraphicsMode (hdc : HDC; Mode : GM_ENUM) : GM_ENUM;
PROCEDURE SetMapMode (hdc : HDC; map : MM_ENUM) : MM_ENUM;
PROCEDURE SetMetaFileBitsEx (sz : UINT; Buffer : ARRAY OF SYSTEM.BYTE) : HMETAFILE;
PROCEDURE SetPaletteEntries (hpal : HPALETTE;
                             StartIndex, Entries : UINT;
                             pc : ARRAY OF PALETTEENTRY) : UINT;
PROCEDURE SetPixel (hdc : HDC; x, y : INTEGER; color : COLORREF) : COLORREF;
PROCEDURE SetPixelV (hdc : HDC; x, y : INTEGER; color : COLORREF) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE SetPixelFormat (hdc : HDC; format : INTEGER;
                          pfd : PIXELFORMATDESCRIPTOR) : BOOL;
<* ELSE *>
PROCEDURE SetPixelFormat (hdc : HDC; format : INTEGER;
                          pfd : PPIXELFORMATDESCRIPTOR) : BOOL;
<* END *> (*!*)

PROCEDURE SetPolyFillMode (hdc : HDC; mode : POLYFILL_ENUM) : POLYFILL_ENUM;
PROCEDURE StretchBlt (hdcDest : HDC; XDest, YDest, WDest, HDest : INTEGER;
                      hdcSrc  : HDC; XSrc, YSrc, WSrc, HSrc : INTEGER;
                      operation : ROP) : BOOL;
PROCEDURE SetRectRgn (hRgn : HRGN;
                      LeftRect, TopRect, RightRect, BottomRect : INTEGER) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE StretchDIBits (hdcDest : HDC; XDest, YDest, WDest, HDest : INTEGER;
                         XSrc, YSrc, WSrc, HSrc : INTEGER;
                         Bits : ARRAY OF BYTE;
                         BitsInfo : BITMAPINFOPARAM; (*!*)
                         ColorUse : DIB_COLOR_ENUM; operation : ROP) : INTEGER;
<* ELSE *>
PROCEDURE StretchDIBits (hdcDest : HDC; XDest, YDest, WDest, HDest : INTEGER;
                         XSrc, YSrc, WSrc, HSrc : INTEGER;
                         Bits : ARRAY OF BYTE;
                         BitsInfo : PBITMAPINFOPARAM; (*!*)
                         ColorUse : DIB_COLOR_ENUM; operation : ROP) : INTEGER;
<* END *>
PROCEDURE SetROP2 (hdc : HDC; rop : ROP2) : ROP2;
PROCEDURE SetStretchBltMode (hdc : HDC; mode : STRETCH_ENUM) : STRETCH_ENUM;
PROCEDURE SetSystemPaletteUse (hdc : HDC; new : SYSPAL_ENUM) : SYSPAL_ENUM;
PROCEDURE SetTextCharacterExtra (hdc : HDC; extra : INTEGER) : INTEGER;
PROCEDURE SetTextColor (hdc : HDC; color : COLORREF) : COLORREF;
PROCEDURE SetTextAlign (hdc : HDC; align : TA_SET) : TA_SET;
PROCEDURE SetTextJustification (hdc : HDC; BreakExtra : INTEGER;
                                BreakOut : INTEGER) : BOOL;

PROCEDURE UpdateColors (hdc : HDC) : BOOL;

<* IF NOT DEFINED (NOMETAFILE) THEN *>

<* IF BACKEND # "C" THEN *>
PROCEDURE PlayMetaFileRecord (hdc : HDC;
                              VAR HandleTable : HANDLETABLE;
                              MetaRecord  : METARECORD;  (*!*)
                              nHandles    : UINT) : BOOL;
TYPE MFENUMPROC = PROCEDURE (HDC, VAR HANDLETABLE, VAR METARECORD, INTEGER, LPARAM) : INTEGER; (*!*)
<* ELSE *>
PROCEDURE PlayMetaFileRecord (hdc : HDC;
                              VAR HandleTable : HANDLETABLE;
                              MetaRecord  : PMETARECORD;  (*!*)
                              nHandles    : UINT) : BOOL;
TYPE MFENUMPROC = PROCEDURE (HDC, PHANDLETABLE, PMETARECORD, INTEGER, LPARAM) : INTEGER; (*!*)
<* END *>

PROCEDURE EnumMetaFile (hdc : HDC;
                        hMetaFile : HMETAFILE;
                        MetaFunc : MFENUMPROC;
                        lParam : LPARAM) : BOOL;

<* IF BACKEND # "C" THEN *>
TYPE ENHMFENUMPROC = PROCEDURE (HDC, VAR HANDLETABLE, VAR ENHMETARECORD, INTEGER, LPARAM) : INTEGER; (*!*)
<* ELSE *>
TYPE ENHMFENUMPROC = PROCEDURE (HDC, PHANDLETABLE, PENHMETARECORD, INTEGER, LPARAM) : INTEGER; (*!*)
<* END *>

(* Enhanced Metafile Function Declarations *)


PROCEDURE CloseEnhMetaFile (hdc : HDC) : HENHMETAFILE;
PROCEDURE CopyEnhMetaFileA (emf : HENHMETAFILE; filename : PCSTR)  : HENHMETAFILE;
PROCEDURE CopyEnhMetaFileW (emf : HENHMETAFILE; filename : PCWSTR) : HENHMETAFILE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CopyEnhMetaFile = CopyEnhMetaFileW;
<* ELSE *>
      CONST CopyEnhMetaFile = CopyEnhMetaFileA;
<* END *>

PROCEDURE CreateEnhMetaFileA (hdc : HDC; (* IN NIL *) filename : PCSTR;  (* IN NIL *) rect : PRECT; (* IN NIL *) descr : PCSTR) : HDC;
PROCEDURE CreateEnhMetaFileW (hdc : HDC; (* IN NIL *) filename : PCWSTR; (* IN NIL *) rect : PRECT; (* IN NIL *) descr : PCWSTR) : HDC;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateEnhMetaFile = CreateEnhMetaFileW;
<* ELSE *>
      CONST CreateEnhMetaFile = CreateEnhMetaFileA;
<* END *>

PROCEDURE DeleteEnhMetaFile (emf : HENHMETAFILE) : BOOL;
PROCEDURE EnumEnhMetaFile (hdc : HDC; emf : HENHMETAFILE; enumproc : ENHMFENUMPROC;
                           data : PVOID; (* IN NIL *) rect : PRECT) : BOOL;
PROCEDURE GetEnhMetaFileA (filename : PCSTR) : HENHMETAFILE;
PROCEDURE GetEnhMetaFileW (filename : PCWSTR): HENHMETAFILE;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetEnhMetaFile = GetEnhMetaFileW;
<* ELSE *>
      CONST GetEnhMetaFile = GetEnhMetaFileA;
<* END *>

PROCEDURE GetEnhMetaFileBits (emf : HENHMETAFILE; len : UINT; VAR [NIL] buf : ARRAY OF SYSTEM.BYTE) : UINT;
PROCEDURE GetEnhMetaFileDescriptionA (emf : HENHMETAFILE; bsize : UINT; VAR [NIL] buffer : ARRAY OF CHAR) : UINT;
PROCEDURE GetEnhMetaFileDescriptionW (emf : HENHMETAFILE; bsize : UINT; VAR [NIL] buffer : ARRAY OF WCHAR) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetEnhMetaFileDescription = GetEnhMetaFileDescriptionW;
<* ELSE *>
      CONST GetEnhMetaFileDescription = GetEnhMetaFileDescriptionA;
<* END *>

PROCEDURE GetEnhMetaFileHeader (emf : HENHMETAFILE;
                                bsize : UINT; VAR [NIL] buffer : ENHMETAHEADER) : UINT;
PROCEDURE GetEnhMetaFilePaletteEntries (emf : HENHMETAFILE;
                                        cEntries : UINT;
                                        VAR [NIL] entries : ARRAY OF PALETTEENTRY) : UINT;
PROCEDURE GetEnhMetaFilePixelFormat (emf : HENHMETAFILE; bufsize : UINT;
                                     VAR [NIL] format : PIXELFORMATDESCRIPTOR) : UINT;

PROCEDURE GetWinMetaFileBits (emf : HENHMETAFILE; bsize : UINT;
                              VAR [NIL] buffer : ARRAY OF SYSTEM.BYTE;
                              MapMode : MM_ENUM;
                              hdc : HDC) : UINT;
<* IF BACKEND # "C" THEN *>
PROCEDURE PlayEnhMetaFile (hdc : HDC; emf : HENHMETAFILE; rect : RECT) : BOOL;
<* ELSE *>
PROCEDURE PlayEnhMetaFile (hdc : HDC; emf : HENHMETAFILE; rect : PRECT) : BOOL;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE PlayEnhMetaFileRecord (hdc : HDC;
                                 VAR handles : HANDLETABLE;
                                 records : ENHMETARECORD; (*!*)
                                 nHandles : UINT) : BOOL;
<* ELSE *>
PROCEDURE PlayEnhMetaFileRecord (hdc : HDC;
                                 VAR handles : HANDLETABLE;
                                 records : PENHMETARECORD; (*!*)
                                 nHandles : UINT) : BOOL;
<* END *>
PROCEDURE SetEnhMetaFileBits (bsize : UINT;
                              buf : ARRAY OF SYSTEM.BYTE) : HENHMETAFILE;

<* IF BACKEND # "C" THEN *>
PROCEDURE SetWinMetaFileBits (bsize : UINT;
                              buf : ARRAY OF SYSTEM.BYTE;
                              hdc : HDC;
                              metapict : METAFILEPICT) : HENHMETAFILE;
<* ELSE *>
PROCEDURE SetWinMetaFileBits (bsize : UINT;
                              buf : ARRAY OF SYSTEM.BYTE;
                              hdc : HDC;
                              metapict : PMETAFILEPICT) : HENHMETAFILE;
<* END *>   (*!*)
PROCEDURE GdiComment (hdc : HDC; bsize : UINT; buf : ARRAY OF SYSTEM.BYTE) : BOOL;

<* END *> (* NOT DEFINED (NOMETAFILE) *)

<* IF NOT DEFINED (NOTEXTMETRIC) THEN *>

PROCEDURE GetTextMetricsA(hdc : HDC; VAR metrics : TEXTMETRICA) : BOOL;
PROCEDURE GetTextMetricsW(hdc : HDC; VAR metrics : TEXTMETRICW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetTextMetrics = GetTextMetricsW;
<* ELSE *>
      CONST GetTextMetrics = GetTextMetricsA;
<* END *>

<* END *> (* NOT DEFINED (NOTEXTMETRICS) *)

(* new GDI *)

TYPE DIBSECTION = RECORD
                         dsBm        : BITMAP;
                         dsBmih      : BITMAPINFOHEADER;
                         dsBitfields : ARRAY [0..2] OF DWORD;
                         dshSection  : HANDLE;
                         dsOffset    : DWORD;
                  END;
    PDIBSECTION = POINTER TO DIBSECTION;

PROCEDURE AngleArc (hdc : HDC; x, y : INTEGER; Radius : DWORD;
                    StartAngle, SweepAngle : FLOAT) : BOOL;
PROCEDURE PolyPolyline (hdc : HDC; points : ARRAY OF POINT;
                        polypoints : ARRAY OF DWORD; n : DWORD) : BOOL;

PROCEDURE GetWorldTransform (hdc : HDC; VAR xform : XFORM) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE SetWorldTransform (hdc : HDC; xform : XFORM) : BOOL;
<* ELSE *>
PROCEDURE SetWorldTransform (hdc : HDC; xform : PXFORM) : BOOL;
<* END *> (*!*)
PROCEDURE ModifyWorldTransform (hdc : HDC; xform : PXFORM; mode : MWT_ENUM) : BOOL; (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE CombineTransform (VAR Result : XFORM;
                            Xform1, Xform2 : XFORM) : BOOL;
<* ELSE *>
PROCEDURE CombineTransform (VAR Result : XFORM;
                            Xform1, Xform2 : PXFORM) : BOOL;
<* END *> (*!*)

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateDIBSection (hdc : HDC;
                            bmi : BITMAPINFOPARAM;
                            usage : DIB_COLOR_ENUM;
                            VAR bits : PBYTE;
                            hSection : HANDLE;
                            offset : DWORD) : HBITMAP;
<* ELSE *>
PROCEDURE CreateDIBSection (hdc : HDC;
                            bmi : PBITMAPINFOPARAM;
                            usage : DIB_COLOR_ENUM;
                            VAR bits : PBYTE;
                            hSection : HANDLE;
                            offset : DWORD) : HBITMAP;
<* END *>

PROCEDURE GetDIBColorTable (hdc : HDC; StartIndex : UINT; nEntries : UINT; VAR buffer : ARRAY OF RGBQUAD) : UINT;
PROCEDURE SetDIBColorTable (hdc : HDC; StartIndex : UINT; nEntries : UINT;     buffer : ARRAY OF RGBQUAD) : UINT;

(* COLORADJUSTMENT structure and values for its fields *)

   (* Flags value for COLORADJUSTMENT *)

TYPE CA_ENUM = (CA__NEGATIVE,    (* 0 *)
                CA__LOG_FILTER); (* 1 *)

<* PUSH *> <* SETSIZE = "2" *>

TYPE CA_SET = SET OF CA_ENUM;

CONST CA_NEGATIVE   = CA_SET {CA__NEGATIVE}; (* 0x0001 *)
      CA_LOG_FILTER = CA_SET {CA__LOG_FILTER}; (* 0x0002 *)

<* POP *>

(* IlluminantIndex values *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE ILLUMINANT_ENUM = (ILLUMINANT_DEVICE_DEFAULT, (* 0 *)
                        ILLUMINANT_A,              (* 1 *)
                        ILLUMINANT_B,              (* 2 *)
                        ILLUMINANT_C,              (* 3 *)
                        ILLUMINANT_D50,            (* 4 *)
                        ILLUMINANT_D55,            (* 5 *)
                        ILLUMINANT_D65,            (* 6 *)
                        ILLUMINANT_D75,            (* 7 *)
                        ILLUMINANT_F2);            (* 8 *)

CONST    ILLUMINANT_MAX_INDEX      = ILLUMINANT_F2;

         ILLUMINANT_TUNGSTEN       = ILLUMINANT_A;
         ILLUMINANT_DAYLIGHT       = ILLUMINANT_C;
         ILLUMINANT_FLUORESCENT    = ILLUMINANT_F2;
         ILLUMINANT_NTSC           = ILLUMINANT_C;

<* POP *>

(* Min and max for RedGamma, GreenGamma, BlueGamma *)
         RGB_GAMMA_MIN             = VAL (WORD, 2500);
         RGB_GAMMA_MAX             = VAL (WORD, 65000);

(* Min and max for ReferenceBlack and ReferenceWhite *)
         REFERENCE_WHITE_MIN       = VAL (WORD, 6000);
         REFERENCE_WHITE_MAX       = VAL (WORD, 10000);
         REFERENCE_BLACK_MIN       = VAL (WORD, 0);
         REFERENCE_BLACK_MAX       = VAL (WORD, 4000);

(* Min and max for Contrast, Brightness, Colorfulness, RedGreenTint *)
         COLOR_ADJ_MIN             = VAL (SHORT, -100);
         COLOR_ADJ_MAX             = VAL (SHORT, -100);

TYPE COLORADJUSTMENT = RECORD
                              caSize            : WORD;
                              caFlags           : CA_SET;
                              caIlluminantIndex : ILLUMINANT_ENUM;
                              caRedGamma        : WORD;
                              caGreenGamma      : WORD;
                              caBlueGamma       : WORD;
                              caReferenceBlack  : WORD;
                              caReferenceWhite  : WORD;
                              caContrast        : SHORT;
                              caBrightness      : SHORT;
                              caColorfulness    : SHORT;
                              caRedGreenTint    : SHORT;
                       END;
     PCOLORADJUSTMENT = POINTER TO COLORADJUSTMENT;

<* IF BACKEND # "C" THEN *>
PROCEDURE SetColorAdjustment (hdc : HDC; adj : COLORADJUSTMENT) : BOOL;
<* ELSE *>
PROCEDURE SetColorAdjustment (hdc : HDC; adj : PCOLORADJUSTMENT) : BOOL;
<* END *> (*!*)
PROCEDURE GetColorAdjustment (hdc : HDC; VAR adj : COLORADJUSTMENT) : BOOL;

PROCEDURE CreateHalftonePalette (hdc : HDC) : HPALETTE;

TYPE ABORTPROC = PROCEDURE (HDC, INTEGER) : BOOL;

CONST DI_APPBANDING = 1;

TYPE DOCINFOA = RECORD
                       cbSize : INTEGER;
                       lpszDocName  : PCSTR;
                       lpszOutput   : PCSTR;
                       lpszDatatype : PCSTR;
                       fwType       : DWORD;
                END;
     PDOCINFOA = POINTER TO DOCINFOA;

     DOCINFOW = RECORD
                       cbSize       : INTEGER;
                       lpszDocName  : PCWSTR;
                       lpszOutput   : PCWSTR;
                       lpszDatatype : PCWSTR;
                       fwType       : DWORD;
                END;
     PDOCINFOW = POINTER TO DOCINFOW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE DOCINFO = DOCINFOW;
           PDOCINFO = PDOCINFOW;
<* ELSE *>
      TYPE DOCINFO = DOCINFOA;
           PDOCINFO = PDOCINFOA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE  StartDocA    (hdc : HDC; dinfo : DOCINFOA) : INTEGER;
<* ELSE *>
PROCEDURE  StartDocA    (hdc : HDC; dinfo : PDOCINFOA) : INTEGER;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE  StartDocW    (hdc : HDC; dinfo : DOCINFOW) : INTEGER;
<* ELSE *>
PROCEDURE  StartDocW    (hdc : HDC; dinfo : PDOCINFOW) : INTEGER;
<* END *> (*!*)
PROCEDURE  EndDoc       (hdc : HDC) : INTEGER;
PROCEDURE  StartPage    (hdc : HDC) : INTEGER;
PROCEDURE  EndPage      (hdc : HDC) : INTEGER;
PROCEDURE  AbortDoc     (hdc : HDC) : INTEGER;
PROCEDURE  SetAbortProc (hdc : HDC; aproc : ABORTPROC) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST StartDoc = StartDocW;
<* ELSE *>
      CONST StartDoc = StartDocA;
<* END *>

PROCEDURE AbortPath (hdc : HDC) : BOOL;
PROCEDURE ArcTo (hdc : HDC; left, top, right, bottom : INTEGER;
                 XRadial1, YRadial1, XRadial2, YRadial2 : INTEGER) : BOOL;
PROCEDURE BeginPath (hdc : HDC) : BOOL;
PROCEDURE CloseFigure       (hdc : HDC) : BOOL;
PROCEDURE EndPath           (hdc : HDC) : BOOL;
PROCEDURE FillPath          (hdc : HDC) : BOOL;
PROCEDURE FlattenPath       (hdc : HDC) : BOOL;
PROCEDURE GetPath (hdc : HDC;
                   VAR [NIL] Points : POINT;
                   VAR [NIL] types  : PT_SET;
                   n : INTEGER) : INTEGER;
PROCEDURE PathToRegion (hdc : HDC) : HRGN;
PROCEDURE PolyDraw (hdc : HDC;
                    points : ARRAY OF POINT;
                    types : ARRAY OF PT_SET;
                    n : INTEGER) : BOOL;

PROCEDURE SelectClipPath  (hdc : HDC; mode : RGN_COMBINE_ENUM) : BOOL;
PROCEDURE SetArcDirection (hdc : HDC; ArcDirection : AD_ENUM) : AD_ENUM;
PROCEDURE SetMiterLimit (hdc : HDC; limit : FLOAT; VAR oldlimit : FLOAT) : BOOL;
PROCEDURE StrokeAndFillPath (hdc : HDC) : BOOL;
PROCEDURE StrokePath        (hdc : HDC) : BOOL;
PROCEDURE WidenPath         (hdc : HDC) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE ExtCreatePen (PenStyle : PS_SET; Width : DWORD;
                        lb : LOGBRUSH; StyleCount : DWORD; (*!*)
                        (* IN NIL *) Style : PDWORD) : HPEN;
<* ELSE *>
PROCEDURE ExtCreatePen (PenStyle : PS_SET; Width : DWORD;
                        lb : PLOGBRUSH; StyleCount : DWORD; (*!*)
                        (* IN NIL *) Style : PDWORD) : HPEN;
<* END *>
PROCEDURE GetMiterLimit (hdc : HDC; VAR limit : FLOAT) : BOOL;
PROCEDURE GetArcDirection (hdc : HDC) : AD_ENUM;


PROCEDURE GetObjectA (hObject : HGDIOBJ; BuffSize : INTEGER;
                      VAR [NIL] Buffer : ARRAY OF SYSTEM.BYTE) : INTEGER;
PROCEDURE GetObjectW (hObject : HGDIOBJ; BuffSize : INTEGER;
                      VAR [NIL] Buffer : ARRAY OF SYSTEM.BYTE) : INTEGER;
<*IF DEFINED (UNICODE) THEN *>
     CONST GetObject = GetObjectW;
<* ELSE *>
     CONST GetObject = GetObjectA;
<* END *>

PROCEDURE MoveToEx (hdc : HDC; x, y : INTEGER; VAR [NIL] old : POINT) : BOOL;
PROCEDURE TextOutA (hdc : HDC; XStart, YStart : INTEGER;
                    Str : ARRAY OF CHAR; len : INTEGER) : BOOL;
PROCEDURE TextOutW (hdc : HDC; XStart, YStart : INTEGER;
                    Str : ARRAY OF WCHAR; len : INTEGER) : BOOL;

PROCEDURE ExtTextOutA (hdc : HDC; XStart, YStart : INTEGER;
                       Options : ETO_SET; clipping : PRECT; (*!*)
                       Str : ARRAY OF CHAR; len : UINT;
                       (* IN NIL *) Dx : INTARRAY) : BOOL;
PROCEDURE ExtTextOutW (hdc : HDC; XStart, YStart : INTEGER;
                       Options : ETO_SET; clipping : PRECT; (*!*)
                       Str : ARRAY OF WCHAR; len : UINT;
                       (* IN NIL *) Dx : INTARRAY) : BOOL;

PROCEDURE PolyTextOutA (hdc : HDC; txts : ARRAY OF POLYTEXTA;
                        ntxts : INTEGER) : BOOL;
PROCEDURE PolyTextOutW (hdc : HDC; txts : ARRAY OF POLYTEXTW;
                        ntxts : INTEGER) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST TextOut = TextOutW;
            ExtTextOut = ExtTextOutW;
            PolyTextOut = PolyTextOutW;
<* ELSE *>
      CONST TextOut = TextOutA;
            ExtTextOut = ExtTextOutA;
            PolyTextOut = PolyTextOutA;
<* END *>


PROCEDURE CreatePolygonRgn (pt : ARRAY OF POINT;
                            cPoints : INTEGER;
                            PolyFillMode : POLYFILL_ENUM) : HRGN;


PROCEDURE DPtoLP (hdc : HDC; VAR points : ARRAY OF POINT; npoints : INTEGER) : BOOL;
PROCEDURE LPtoDP (hdc : HDC; VAR points : ARRAY OF POINT; npoints : INTEGER) : BOOL;

PROCEDURE Polygon (hdc : HDC; points : ARRAY OF POINT; n : INTEGER) : BOOL;
PROCEDURE Polyline   (hdc : HDC; points : ARRAY OF POINT; n : INTEGER) : BOOL;

PROCEDURE PolyBezier   (hdc : HDC; points : ARRAY OF POINT; n : DWORD) : BOOL;
PROCEDURE PolyBezierTo (hdc : HDC; points : ARRAY OF POINT; n : DWORD) : BOOL;
PROCEDURE PolylineTo (hdc : HDC; points : ARRAY OF POINT; n : DWORD) : BOOL;

PROCEDURE SetViewportExtEx (hdc : HDC; x, y : INTEGER; VAR [NIL] oldext : SIZEL) : BOOL;
PROCEDURE SetViewportOrgEx (hdc : HDC; x, y : INTEGER; VAR [NIL] oldorg : POINT) : BOOL;
PROCEDURE SetWindowOrgEx   (hdc : HDC; x, y : INTEGER; VAR [NIL] oldorg : POINT) : BOOL;
PROCEDURE SetWindowExtEx   (hdc : HDC; x, y : INTEGER; VAR [NIL] oldext : SIZEL) : BOOL;

PROCEDURE OffsetViewportOrgEx (hdc : HDC; dx, dy : INTEGER; VAR oldorg : POINT) : BOOL;
PROCEDURE OffsetWindowOrgEx   (hdc : HDC; dx, dy : INTEGER; VAR oldorg : POINT) : BOOL;
PROCEDURE ScaleViewportExtEx (hdc : HDC; Xnum, Xdenom, Ynum, Ydenom : INTEGER;
                              VAR [NIL] oldext : SIZEL) : BOOL;
PROCEDURE ScaleWindowExtEx   (hdc : HDC; Xnum, Xdenom, Ynum, Ydenom : INTEGER;
                              VAR [NIL] oldext : SIZEL) : BOOL;

PROCEDURE SetBitmapDimensionEx (hbmp : HBITMAP; Width, Height : INTEGER;
                                VAR [NIL] OldSize : SIZEL) : BOOL;

PROCEDURE SetBrushOrgEx (dc : HDC; x, y : INTEGER; VAR [NIL] old : POINT) : BOOL;

PROCEDURE GetTextFaceA (hdc : HDC; len : INTEGER;
                        VAR [NIL] Buffer : ARRAY OF CHAR) : INTEGER;
PROCEDURE GetTextFaceW (hdc : HDC; len : INTEGER;
                        VAR [NIL] Buffer : ARRAY OF WCHAR) : INTEGER;
<* IF DEFINED (UNICODE) THEN *>
      CONST GetTextFace = GetTextFaceW;
<* ELSE *>
      CONST GetTextFace = GetTextFaceA;
<* END *>

CONST FONTMAPPER_MAX = 10;

TYPE KERNINGPAIR = RECORD
                          wFirst  : WORD;
                          wSecond : WORD;
                          iKernAmount : INTEGER;
                   END;
    PKERNINGPAIR = POINTER TO KERNINGPAIR;


PROCEDURE GetKerningPairsA (hdc : HDC;
                            NumPairs : DWORD;
                            VAR [NIL] krnpair : ARRAY OF KERNINGPAIR) : DWORD;

PROCEDURE GetKerningPairsW (hdc : HDC;
                            NumPairs : DWORD;
                            VAR [NIL] krnpair : ARRAY OF KERNINGPAIR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetKerningPairs = GetKerningPairsW;
<* ELSE *>
      CONST GetKerningPairs = GetKerningPairsA;
<* END *>

PROCEDURE GetDCOrgEx (hdc : HDC; VAR point : POINT) : BOOL;
PROCEDURE FixBrushOrgEx (hdc : HDC; x, y : INTEGER; VAR [NIL] prev : POINT) : BOOL;
PROCEDURE UnrealizeObject (object : HGDIOBJ) : BOOL;

PROCEDURE GdiFlush() : BOOL;
PROCEDURE GdiSetBatchLimit (limit : DWORD) : DWORD;
PROCEDURE GdiGetBatchLimit () : DWORD;



TYPE ICM_ENUM = (ICM_0,
                 ICM_OFF,    (* 1 *)
                 ICM_ON,     (* 2 *)
                 ICM_QUERY); (* 3 *)

PROCEDURE SetICMMode (hdc : HDC; icm : ICM_ENUM) : ICM_ENUM;

PROCEDURE CheckColorsInGamut (hdc : HDC; rgn : ARRAY OF RGBQUAD;
                              VAR result : ARRAY OF GAMUT_RESULT;
                              count : DWORD) : BOOL;
PROCEDURE GetColorSpace (hdc : HDC) : HANDLE;
PROCEDURE GetLogColorSpaceA (hcolorspace : HCOLORSPACE; VAR cs : LOGCOLORSPACEA; size : DWORD) : BOOL;
PROCEDURE GetLogColorSpaceW (hcolorspace : HCOLORSPACE; VAR cs : LOGCOLORSPACEW; size : DWORD) : BOOL;
<* IF DEFINED (UNICODE) THEN *>
      CONST GetLogColorSpace = GetLogColorSpaceW;
<* ELSE *>
      CONST GetLogColorSpace = GetLogColorSpaceA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateColorSpaceA (cs : LOGCOLORSPACEA) : HCOLORSPACE;
<* ELSE *>
PROCEDURE CreateColorSpaceA (cs : PLOGCOLORSPACEA) : HCOLORSPACE;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE CreateColorSpaceW (cs : LOGCOLORSPACEW) : HCOLORSPACE;
<* ELSE *>
PROCEDURE CreateColorSpaceW (cs : PLOGCOLORSPACEW) : HCOLORSPACE;
<* END *> (*!*)

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateColorSpace = CreateColorSpaceW;
<* ELSE *>
      CONST CreateColorSpace = CreateColorSpaceA;
<* END *>

PROCEDURE SetColorSpace (hdc : HDC; hcs : HCOLORSPACE) : BOOL;
PROCEDURE DeleteColorSpace (hcs : HCOLORSPACE) : BOOL;
PROCEDURE GetICMProfileA (hdc : HDC; VAR size : DWORD; filename : PSTR)  : BOOL;
PROCEDURE GetICMProfileW (hdc : HDC; VAR size : DWORD; filename : PWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetICMProfile = GetICMProfileW;
<* ELSE *>
      CONST GetICMProfile = GetICMProfileA;
<* END *>

PROCEDURE SetICMProfileA (hdc : HDC; VAR filename : ARRAY OF CHAR)  : BOOL;
PROCEDURE SetICMProfileW (hdc : HDC; VAR filename : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetICMProfile = SetICMProfileW;
<* ELSE *>
      CONST SetICMProfile = SetICMProfileA;
<* END *>

TYPE RAMP_INDEX = (RAMP_INDEX_RED, RAMP_INDEX_GREEN, RAMP_INDEX_BLUE);
     RAMP_ARRAY = ARRAY RAMP_INDEX, [0..255] OF BYTE;

PROCEDURE GetDeviceGammaRamp (hdc : HDC; VAR ramp : RAMP_ARRAY) : BOOL;
PROCEDURE SetDeviceGammaRamp (hdc : HDC;     ramp : RAMP_ARRAY) : BOOL; (*!*)
PROCEDURE ColorMatchToTarget (hdc : HDC; hdctarget : HDC; action : DWORD) : BOOL;
PROCEDURE UpdateICMRegKeyA (reserved : DWORD; CMID : DWORD; filename : PSTR;  command : UINT) : BOOL;
PROCEDURE UpdateICMRegKeyW (reserved : DWORD; CMID : DWORD; filename : PWSTR; command : UINT) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST UpdateICMRegKey = UpdateICMRegKeyW;
<* ELSE *>
      CONST UpdateICMRegKey = UpdateICMRegKeyA;
<* END *>

TYPE ICMENUMPROCA = PROCEDURE (ARRAY OF CHAR,  LPARAM) : INTEGER;
TYPE ICMENUMPROCW = PROCEDURE (ARRAY OF WCHAR, LPARAM) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      TYPE ICMENUMPROC = ICMENUMPROCW;
<* ELSE *>
      TYPE ICMENUMPROC = ICMENUMPROCA;
<* END *>

PROCEDURE EnumICMProfilesA (hdc : HDC; enumfunc : ICMENUMPROCA; lparam : LPARAM) : INTEGER;
PROCEDURE EnumICMProfilesW (hdc : HDC; enumfunc : ICMENUMPROCW; lparam : LPARAM) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumICMProfiles = EnumICMProfilesW;
<* ELSE *>
      CONST EnumICMProfiles = EnumICMProfilesA;
<* END *>

<* IF NOT DEFINED (NOMETAFILE) THEN *>

(* Enhanced metafile constants. *)

CONST ENHMETA_SIGNATURE = 464D4520h;

(* Stock object flag used in the object handle index in the enhanced
 * metafile records.
 * E.g. The object handle index (META_STOCK_OBJECT + BLACK_BRUSH)
 * represents the stock object BLACK_BRUSH.
 *)
      ENHMETA_STOCK_OBJECT =  80000000h;

(* Enhanced metafile record types. *)

      EMR_HEADER                     = 1;
      EMR_POLYBEZIER                 = 2;
      EMR_POLYGON                    = 3;
      EMR_POLYLINE                   = 4;
      EMR_POLYBEZIERTO               = 5;
      EMR_POLYLINETO                 = 6;
      EMR_POLYPOLYLINE               = 7;
      EMR_POLYPOLYGON                = 8;
      EMR_SETWINDOWEXTEX             = 9;
      EMR_SETWINDOWORGEX             = 10;
      EMR_SETVIEWPORTEXTEX           = 11;
      EMR_SETVIEWPORTORGEX           = 12;
      EMR_SETBRUSHORGEX              = 13;
      EMR_EOF                        = 14;
      EMR_SETPIXELV                  = 15;
      EMR_SETMAPPERFLAGS             = 16;
      EMR_SETMAPMODE                 = 17;
      EMR_SETBKMODE                  = 18;
      EMR_SETPOLYFILLMODE            = 19;
      EMR_SETROP2                    = 20;
      EMR_SETSTRETCHBLTMODE          = 21;
      EMR_SETTEXTALIGN               = 22;
      EMR_SETCOLORADJUSTMENT         = 23;
      EMR_SETTEXTCOLOR               = 24;
      EMR_SETBKCOLOR                 = 25;
      EMR_OFFSETCLIPRGN              = 26;
      EMR_MOVETOEX                   = 27;
      EMR_SETMETARGN                 = 28;
      EMR_EXCLUDECLIPRECT            = 29;
      EMR_INTERSECTCLIPRECT          = 30;
      EMR_SCALEVIEWPORTEXTEX         = 31;
      EMR_SCALEWINDOWEXTEX           = 32;
      EMR_SAVEDC                     = 33;
      EMR_RESTOREDC                  = 34;
      EMR_SETWORLDTRANSFORM          = 35;
      EMR_MODIFYWORLDTRANSFORM       = 36;
      EMR_SELECTOBJECT               = 37;
      EMR_CREATEPEN                  = 38;
      EMR_CREATEBRUSHINDIRECT        = 39;
      EMR_DELETEOBJECT               = 40;
      EMR_ANGLEARC                   = 41;
      EMR_ELLIPSE                    = 42;
      EMR_RECTANGLE                  = 43;
      EMR_ROUNDRECT                  = 44;
      EMR_ARC                        = 45;
      EMR_CHORD                      = 46;
      EMR_PIE                        = 47;
      EMR_SELECTPALETTE              = 48;
      EMR_CREATEPALETTE              = 49;
      EMR_SETPALETTEENTRIES          = 50;
      EMR_RESIZEPALETTE              = 51;
      EMR_REALIZEPALETTE             = 52;
      EMR_EXTFLOODFILL               = 53;
      EMR_LINETO                     = 54;
      EMR_ARCTO                      = 55;
      EMR_POLYDRAW                   = 56;
      EMR_SETARCDIRECTION            = 57;
      EMR_SETMITERLIMIT              = 58;
      EMR_BEGINPATH                  = 59;
      EMR_ENDPATH                    = 60;
      EMR_CLOSEFIGURE                = 61;
      EMR_FILLPATH                   = 62;
      EMR_STROKEANDFILLPATH          = 63;
      EMR_STROKEPATH                 = 64;
      EMR_FLATTENPATH                = 65;
      EMR_WIDENPATH                  = 66;
      EMR_SELECTCLIPPATH             = 67;
      EMR_ABORTPATH                  = 68;

      EMR_GDICOMMENT                 = 70;
      EMR_FILLRGN                    = 71;
      EMR_FRAMERGN                   = 72;
      EMR_INVERTRGN                  = 73;
      EMR_PAINTRGN                   = 74;
      EMR_EXTSELECTCLIPRGN           = 75;
      EMR_BITBLT                     = 76;
      EMR_STRETCHBLT                 = 77;
      EMR_MASKBLT                    = 78;
      EMR_PLGBLT                     = 79;
      EMR_SETDIBITSTODEVICE          = 80;
      EMR_STRETCHDIBITS              = 81;
      EMR_EXTCREATEFONTINDIRECTW     = 82;
      EMR_EXTTEXTOUTA                = 83;
      EMR_EXTTEXTOUTW                = 84;
      EMR_POLYBEZIER16               = 85;
      EMR_POLYGON16                  = 86;
      EMR_POLYLINE16                 = 87;
      EMR_POLYBEZIERTO16             = 88;
      EMR_POLYLINETO16               = 89;
      EMR_POLYPOLYLINE16             = 90;
      EMR_POLYPOLYGON16              = 91;
      EMR_POLYDRAW16                 = 92;
      EMR_CREATEMONOBRUSH            = 93;
      EMR_CREATEDIBPATTERNBRUSHPT    = 94;
      EMR_EXTCREATEPEN               = 95;
      EMR_POLYTEXTOUTA               = 96;
      EMR_POLYTEXTOUTW               = 97;
      EMR_SETICMMODE                 = 98;
      EMR_CREATECOLORSPACE           = 99;
      EMR_SETCOLORSPACE              =100;
      EMR_DELETECOLORSPACE           =101;
      EMR_GLSRECORD                  =102;
      EMR_GLSBOUNDEDRECORD           =103;
      EMR_PIXELFORMAT                =104;

      EMR_MIN                        =  1;
      EMR_MAX                        =104;

(* Base record type for the enhanced metafile. *)

TYPE EMR = RECORD
                  iType : DWORD; (* Enhanced metafile record type  *)
                  nSize : DWORD; (* Length of the record in bytes. *)
           END;                  (* This must be a multiple of 4.  *)
     PEMR = POINTER TO EMR;

(* Base text record type for the enhanced metafile. *)

TYPE EMRTEXT = RECORD
                      ptlReference : POINTL;
                      nChars       : DWORD;
                      offString    : DWORD; (* Offset to the string *)
                      fOptions     : ETO_SET;
                      rcl          : RECTL;
                      offDx        : DWORD; (* Offset to the inter-character spacing array. *)
               END;                         (* This is always given. *)
    PEMRTEXT = POINTER TO EMRTEXT;

(* Record structures for the enhanced metafile. *)

TYPE EMRABORTPATH = RECORD
                         emr : EMR;
                    END;
                                       PEMRABORTPATH      = POINTER TO EMRABORTPATH;
     EMRBEGINPATH      = EMRABORTPATH; PPEMRBEGINPATH     = POINTER TO EMRBEGINPATH;
     EMRENDPATH        = EMRABORTPATH; PEMRENDPATH        = POINTER TO EMRENDPATH;
     EMRCLOSEFIGURE    = EMRABORTPATH; PEMRCLOSEFIGURE    = POINTER TO EMRCLOSEFIGURE;
     EMRFLATTENPATH    = EMRABORTPATH; PEMRFLATTENPATH    = POINTER TO EMRFLATTENPATH;
     EMRWIDENPATH      = EMRABORTPATH; PEMRWIDENPATH      = POINTER TO EMRWIDENPATH;
     EMRSETMETARGN     = EMRABORTPATH; PEMRSETMETARGN     = POINTER TO EMRSETMETARGN;
     EMRSAVEDC         = EMRABORTPATH; PEMRSAVEDC         = POINTER TO EMRSAVEDC;
     EMRREALIZEPALETTE = EMRABORTPATH; PEMRREALIZEPALETTE = POINTER TO EMRREALIZEPALETTE;

TYPE EMRSELECTCLIPPATH = RECORD
                                emr   : EMR;
                                iMode : DWORD;
                         END;
                                              PEMRSELECTCLIPPATH    = POINTER TO EMRSELECTCLIPPATH;
    EMRSETBKMODE         = EMRSELECTCLIPPATH; PEMRSETBKMODE         = POINTER TO EMRSETBKMODE;
    EMRSETMAPMODE        = EMRSELECTCLIPPATH; PEMRSETMAPMODE        = POINTER TO EMRSETMAPMODE;
    EMRSETPOLYFILLMODE   = EMRSELECTCLIPPATH; PEMRSETPOLYFILLMODE   = POINTER TO EMRSETPOLYFILLMODE;
    EMRSETROP2           = EMRSELECTCLIPPATH; PEMRSETROP2           = POINTER TO EMRSETROP2;
    EMRSETSTRETCHBLTMODE = EMRSELECTCLIPPATH; PEMRSETSTRETCHBLTMODE = POINTER TO EMRSETSTRETCHBLTMODE;
    EMRSETICMMODE        = EMRSELECTCLIPPATH; PEMRSETICMMODE        = POINTER TO EMRSETICMMODE;
    EMRSETTEXTALIGN      = EMRSELECTCLIPPATH; PEMRSETTEXTALIGN      = POINTER TO EMRSETTEXTALIGN;

TYPE EMRSETMITERLIMIT = RECORD
                               emr : EMR;
                               eMiterLimit : FLOAT;
                        END;
    PEMRSETMITERLIMIT = POINTER TO EMRSETMITERLIMIT;

TYPE EMRRESTOREDC = RECORD
                           emr : EMR;
                           iRelative : LONG; (* Specifies a relative instance *)
                    END;
    PEMRRESTOREDC = POINTER TO EMRRESTOREDC;

TYPE EMRSETARCDIRECTION = RECORD
                                 emr : EMR;
                                 iArcDirection : DWORD;
                                     (* Specifies the arc direction in the
                                        advanced graphics mode. *)
                          END;
    PEMRSETARCDIRECTION = POINTER TO EMRSETARCDIRECTION;

TYPE EMRSETMAPPERFLAGS = RECORD
                                emr : EMR;
                                dwFlags : DWORD;
                         END;
    PEMRSETMAPPERFLAGS = POINTER TO EMRSETMAPPERFLAGS;


TYPE EMRSETTEXTCOLOR = RECORD
                              emr : EMR;
                              crColor : COLORREF;
                       END;
      EMRSETBKCOLOR = EMRSETTEXTCOLOR;

      PEMRSETBKCOLOR   = POINTER TO EMRSETBKCOLOR;
      PEMRSETTEXTCOLOR = POINTER TO EMRSETTEXTCOLOR;

TYPE EMRSELECTOBJECT = RECORD
                              emr : EMR;
                              ihObject : DWORD ; (* Object handle index *)
                       END;
     PEMRSELECTOBJECT = POINTER TO EMRSELECTOBJECT;
      EMRDELETEOBJECT = EMRSELECTOBJECT;
     PEMRDELETEOBJECT = POINTER TO EMRDELETEOBJECT;

TYPE EMRSELECTCOLORSPACE = RECORD
                                  emr : EMR;
                                  ihCS : DWORD; (* ColorSpace handle index *)
                           END;
    PEMRSELECTCOLORSPACE = POINTER TO EMRSELECTCOLORSPACE;
     EMRDELETECOLORSPACE = EMRSELECTCOLORSPACE;
    PEMRDELETECOLORSPACE = POINTER TO EMRDELETECOLORSPACE;

TYPE EMRSELECTPALETTE = RECORD
                               emr : EMR;
                               ihPal : DWORD; (* Palette handle index, background mode only *)
                        END;
    PEMRSELECTPALETTE = POINTER TO EMRSELECTPALETTE;

TYPE EMRRESIZEPALETTE = RECORD
                               emr : EMR;
                               ihPal : DWORD;       (* Palette handle index *)
                               cEntries : DWORD;
                        END;
    PEMRRESIZEPALETTE = POINTER TO EMRRESIZEPALETTE;

TYPE EMRSETPALETTEENTRIES =
           RECORD
                  emr         : EMR;
                  ihPal       : DWORD;   (* Palette handle index *)
                  iStart      : DWORD;
                  cEntries    : DWORD;
                  aPalEntries : ARRAY[0..0] OF PALETTEENTRY;
           END;   (* The peFlags fields do not contain any flags *)

    PEMRSETPALETTEENTRIES = POINTER TO EMRSETPALETTEENTRIES;

TYPE EMRSETCOLORADJUSTMENT = RECORD
                                    emr : EMR;
                                    ColorAdjustment : COLORADJUSTMENT;
                             END;
    PEMRSETCOLORADJUSTMENT = POINTER TO EMRSETCOLORADJUSTMENT;

TYPE EMRGDICOMMENT = RECORD
                            emr    : EMR;
                            cbData : DWORD; (* Size of data in bytes *)
                            Data   : ARRAY [0..0] OF BYTE;
                     END;
    PEMRGDICOMMENT = POINTER TO EMRGDICOMMENT;

TYPE EMREOF = RECORD
                     emr           : EMR;
                     nPalEntries   : DWORD; (* Number of palette entries *)
                     offPalEntries : DWORD; (* Offset to the palette entries *)
                     nSizeLast     : DWORD; (* Same as nSize and must be the last DWORD *)
                                            (* of the record.  The palette entries, *)
              END;                          (* if exist, precede this field. *)
    PEMREOF = POINTER TO EMREOF;

TYPE EMRLINETO = RECORD
                        emr : EMR;
                        ptl : POINTL;
                 END;
    PEMRLINETO = POINTER TO EMRLINETO;
   EMRMOVETOEX = EMRLINETO;
  PEMRMOVETOEX = POINTER TO EMRMOVETOEX;

TYPE EMROFFSETCLIPRGN = RECORD
                               emr : EMR;
                               ptlOffset : POINTL;
                        END;
    PEMROFFSETCLIPRGN = POINTER TO EMROFFSETCLIPRGN;

TYPE EMRFILLPATH = RECORD
                          emr : EMR;
                          rclBounds : RECTL; (* Inclusive-inclusive bounds in device units *)
                   END;
    PEMRFILLPATH = POINTER TO EMRFILLPATH;
    EMRSTROKEANDFILLPATH = EMRFILLPATH;
    EMRSTROKEPATH = EMRFILLPATH;
   PEMRSTROKEANDFILLPATH = POINTER TO EMRSTROKEANDFILLPATH;
   PEMRSTROKEPATH        = POINTER TO EMRSTROKEPATH;

TYPE EMREXCLUDECLIPRECT = RECORD
                                 emr : EMR;
                                 rclClip : RECTL;
                          END;
    PEMREXCLUDECLIPRECT   = POINTER TO EMREXCLUDECLIPRECT;
     EMRINTERSECTCLIPRECT = EMREXCLUDECLIPRECT;
   PEMRINTERSECTCLIPRECT  = POINTER TO EMRINTERSECTCLIPRECT;

TYPE EMRSETVIEWPORTORGEX = RECORD
                                 emr : EMR;
                                 ptlOrigin : POINTL;
                           END;

   EMRSETWINDOWORGEX =  EMRSETVIEWPORTORGEX;
   EMRSETBRUSHORGEX  =  EMRSETVIEWPORTORGEX;
  PEMRSETVIEWPORTORGEX = POINTER TO EMRSETVIEWPORTORGEX;
  PEMRSETWINDOWORGEX   = POINTER TO EMRSETWINDOWORGEX;
  PEMRSETBRUSHORGEX    = POINTER TO EMRSETBRUSHORGEX;


TYPE EMRSETVIEWPORTEXTEX = RECORD
                                  emr : EMR;
                                  szlExtent : SIZEL;
                           END;
   PEMRSETVIEWPORTEXTEX = POINTER TO EMRSETVIEWPORTEXTEX;
    EMRSETWINDOWEXTEX   = EMRSETVIEWPORTEXTEX;
   PEMRSETWINDOWEXTEX   = POINTER TO EMRSETWINDOWEXTEX;

TYPE EMRSCALEVIEWPORTEXTEX = RECORD
                                    emr    : EMR;
                                    xNum   : LONG;
                                    xDenom : LONG;
                                    yNum   : LONG;
                                    yDenom : LONG;
                             END;
    PEMRSCALEVIEWPORTEXTEX = POINTER TO EMRSCALEVIEWPORTEXTEX;
   EMRSCALEWINDOWEXTEX     = EMRSCALEVIEWPORTEXTEX;
  PEMRSCALEWINDOWEXTEX     = POINTER TO EMRSCALEWINDOWEXTEX;

TYPE EMRSETWORLDTRANSFORM = RECORD
                                   emr : EMR;
                                   xform : XFORM;
                            END;
    PEMRSETWORLDTRANSFORM = POINTER TO EMRSETWORLDTRANSFORM;

TYPE EMRMODIFYWORLDTRANSFORM = RECORD
                                      emr   : EMR;
                                      xform : XFORM;
                                      iMode : MWT_ENUM;
                               END;
    PEMRMODIFYWORLDTRANSFORM = POINTER TO EMRMODIFYWORLDTRANSFORM;

TYPE EMRSETPIXELV = RECORD
                           emr      : EMR;
                           ptlPixel : POINTL;
                           crColor  : COLORREF;
                    END;
    PEMRSETPIXELV = POINTER TO EMRSETPIXELV;

TYPE EMREXTFLOODFILL = RECORD
                              emr      : EMR;
                              ptlStart : POINTL;
                              crColor  : COLORREF;
                              iMode    : FLOODFILL_ENUM;
                       END;
    PEMREXTFLOODFILL = POINTER TO EMREXTFLOODFILL;

TYPE EMRELLIPSE = RECORD
                         emr : EMR;
                         rclBox : RECTL; (* Inclusive-inclusive bounding rectangle *)
                  END;
  PEMRELLIPSE   = POINTER TO EMRELLIPSE;
   EMRRECTANGLE = EMRELLIPSE;
  PEMRRECTANGLE = POINTER TO EMRRECTANGLE;

TYPE EMRROUNDRECT = RECORD
                           emr : EMR;
                           rclBox : RECTL;    (* Inclusive-inclusive bounding rectangle *)
                           szlCorner : SIZEL;
                    END;
    PEMRROUNDRECT = POINTER TO EMRROUNDRECT;

TYPE EMRARC = RECORD
                     emr      : EMR;
                     rclBox   : RECTL;  (* Inclusive-inclusive bounding rectangle *)
                     ptlStart : POINTL;
                     ptlEnd   : POINTL;
              END;

  EMRARCTO  = EMRARC;
  EMRCHORD  = EMRARC;
  EMRPIE    = EMRARC;
  PEMRARC   = POINTER TO EMRARC;
  PEMRARCTO = POINTER TO EMRARCTO;
  PEMRCHORD = POINTER TO EMRCHORD;
  PEMRPIE   = POINTER TO EMRPIE;

TYPE EMRANGLEARC = RECORD
                          emr : EMR;
                          ptlCenter : POINTL;
                          nRadius : DWORD;
                          eStartAngle : FLOAT;
                          eSweepAngle : FLOAT;
                   END;
    PEMRANGLEARC = POINTER TO EMRANGLEARC;

TYPE EMRPOLYLINE = RECORD
                          emr : EMR;
                          rclBounds : RECTL; (* Inclusive-inclusive bounds in device units *)
                          cptl : DWORD;
                          aptl : ARRAY [0..0] OF POINTL;
                   END;

     EMRPOLYBEZIER   = EMRPOLYLINE;
     EMRPOLYGON      = EMRPOLYLINE;
     EMRPOLYBEZIERTO = EMRPOLYLINE;
     EMRPOLYLINETO   = EMRPOLYLINE;

    PEMRPOLYLINE     = POINTER TO EMRPOLYLINE;
    PEMRPOLYBEZIER   = POINTER TO EMRPOLYBEZIER;
    PEMRPOLYGON      = POINTER TO EMRPOLYGON;
    PEMRPOLYBEZIERTO = POINTER TO EMRPOLYBEZIERTO;
    PEMRPOLYLINETO   = POINTER TO EMRPOLYLINETO;

TYPE EMRPOLYLINE16 = RECORD
                            emr : EMR;
                            rclBounds : RECTL; (* Inclusive-inclusive bounds in device units *)
                            cpts : DWORD;
                            apts : ARRAY [0..0] OF POINTS;
                     END;
     EMRPOLYBEZIER16   =  EMRPOLYLINE16;
     EMRPOLYGON16      =  EMRPOLYLINE16;
     EMRPOLYBEZIERTO16 =  EMRPOLYLINE16;
     EMRPOLYLINETO16   =  EMRPOLYLINE16;

    PEMRPOLYLINE16     = POINTER TO EMRPOLYLINE16;
    PEMRPOLYBEZIER16   = POINTER TO EMRPOLYBEZIER16;
    PEMRPOLYGON16      = POINTER TO EMRPOLYGON16;
    PEMRPOLYBEZIERTO16 = POINTER TO EMRPOLYBEZIERTO16;
    PEMRPOLYLINETO16   = POINTER TO EMRPOLYLINETO16;

TYPE EMRPOLYDRAW =
     RECORD
            emr : EMR;
            rclBounds : RECTL;              (* Inclusive-inclusive bounds in device units *)
            cptl : DWORD;                   (* Number of points *)
            aptl : ARRAY [0..0] OF POINTL;  (* Array of points *)
            abTypes : ARRAY [0..0] OF BYTE; (* Array of point types *)
     END;
    PEMRPOLYDRAW = POINTER TO EMRPOLYDRAW;

TYPE EMRPOLYDRAW16 =
     RECORD
            emr       : EMR;
            rclBounds : RECTL;                  (* Inclusive-inclusive bounds in device units *)
            cpts      : DWORD;                  (* Number of points *)
            apts      : ARRAY [0..0] OF POINTS; (* Array of points  *)
            abTypes   : ARRAY [0..0] OF BYTE;   (* Array of point types *)
     END;
    PEMRPOLYDRAW16 = POINTER TO EMRPOLYDRAW16;

TYPE EMRPOLYPOLYLINE =
     RECORD
            emr : EMR;
            rclBounds : RECTL;          (* Inclusive-inclusive bounds in device units *)
            nPolys : DWORD;             (* Number of polys *)
            cptl : DWORD;               (* Total number of points in all polys *)
            aPolyCounts : ARRAY [0..0] OF DWORD; (* Array of point counts for each poly *)
            aptl : ARRAY [0..0] OF POINTL;       (* Array of points *)
     END;
     EMRPOLYPOLYGON  = EMRPOLYPOLYLINE;
    PEMRPOLYPOLYLINE = POINTER TO EMRPOLYPOLYLINE;
    PEMRPOLYPOLYGON  = POINTER TO EMRPOLYPOLYGON;

TYPE EMRPOLYPOLYLINE16 =
     RECORD
            emr         : EMR;
            rclBounds   : RECTL;          (* Inclusive-inclusive bounds in device units *)
            nPolys      : DWORD;          (* Number of polys *)
            cpts        : DWORD;          (* Total number of points in all polys *)
            aPolyCounts : ARRAY [0..0] OF DWORD;     (* Array of point counts for each poly *)
            apts        : ARRAY [0..0] OF POINTS;    (* Array of points *)
     END;
     EMRPOLYPOLYGON16 = EMRPOLYPOLYLINE16;
    PEMRPOLYPOLYLINE16 = POINTER TO EMRPOLYPOLYLINE16;
    PEMRPOLYPOLYGON16  = POINTER TO EMRPOLYPOLYGON16;

TYPE EMRINVERTRGN =
     RECORD
            emr : EMR;
            rclBounds : RECTL;          (* Inclusive-inclusive bounds in device units *)
            cbRgnData : DWORD;          (* Size of region data in bytes *)
            RgnData : ARRAY [0..0] OF BYTE;
     END;
     EMRPAINTRGN = EMRINVERTRGN;
    PEMRINVERTRGN = POINTER TO EMRINVERTRGN;
    PEMRPAINTRGN  = POINTER TO EMRPAINTRGN;

TYPE EMRFILLRGN =
     RECORD
            emr : EMR;
            rclBounds : RECTL;            (* Inclusive-inclusive bounds in device units *)
            cbRgnData : DWORD;            (* Size of region data in bytes *)
            ihBrush   : DWORD;            (* Brush handle index *)
            RgnData   : ARRAY [0..0] OF BYTE;
     END;
     PEMRFILLRGN = POINTER TO EMRFILLRGN;

TYPE EMRFRAMERGN =
     RECORD
            emr       : EMR;
            rclBounds : RECTL;          (* Inclusive-inclusive bounds in device units *)
            cbRgnData : DWORD;          (* Size of region data in bytes *)
            ihBrush   : DWORD;          (* Brush handle index *)
            szlStroke : SIZEL;
            RgnData   : ARRAY [0..0] OF BYTE;
     END;
     PEMRFRAMERGN = POINTER TO EMRFRAMERGN;

TYPE EMREXTSELECTCLIPRGN =
     RECORD
            emr : EMR;
            cbRgnData : DWORD;         (* Size of region data in bytes *)
            iMode     : RGN_COMBINE_ENUM;
            RgnData   : ARRAY [0..0] OF BYTE;
     END;
     PEMREXTSELECTCLIPRGN = POINTER TO EMREXTSELECTCLIPRGN;

TYPE EMREXTTEXTOUTA =
     RECORD
            emr : EMR;
            rclBounds : RECTL;       (* Inclusive-inclusive bounds in device units *)
            iGraphicsMode : GM_ENUM; (* Current graphics mode *)
            exScale : FLOAT;         (* X and Y scales from Page units to .01mm units *)
            eyScale : FLOAT;         (* if graphics mode is GM_COMPATIBLE. *)
            emrtext : EMRTEXT;       (* This is followed by the string and spacing array *)
     END;
     EMREXTTEXTOUTW = EMREXTTEXTOUTA;
    PEMREXTTEXTOUTA = POINTER TO EMREXTTEXTOUTA;
    PEMREXTTEXTOUTW = POINTER TO EMREXTTEXTOUTW;


TYPE EMRPOLYTEXTOUTA =
     RECORD
            emr : EMR;
            rclBounds : RECTL;          (* Inclusive-inclusive bounds in device units *)
            iGraphicsMode : GM_ENUM;    (* Current graphics mode *)
            exScale : FLOAT;            (* X and Y scales from Page units to .01mm units *)
            eyScale : FLOAT;            (*   if graphics mode is GM_COMPATIBLE. *)
            cStrings : LONG;
            aemrtext : ARRAY [0..0] OF EMRTEXT; (* Array of EMRTEXT structures.  This is *)
                                                (* followed by the strings and spacing arrays. *)
     END;
     EMRPOLYTEXTOUTW  = EMRPOLYTEXTOUTA;
     PEMRPOLYTEXTOUTA = POINTER TO EMRPOLYTEXTOUTA;
     PEMRPOLYTEXTOUTW = POINTER TO EMRPOLYTEXTOUTW;

TYPE EMRBITBLT =
     RECORD
            emr          : EMR;
            rclBounds    : RECTL;    (* Inclusive-inclusive bounds in device units *)
            xDest        : LONG;
            yDest        : LONG;
            cxDest       : LONG;
            cyDest       : LONG;
            dwRop        : ROP;
            xSrc         : LONG;
            ySrc         : LONG;
            xformSrc     : XFORM;    (* Source DC transform *)
            crBkColorSrc : COLORREF; (* Source DC BkColor in RGB *)
            iUsageSrc    : DIB_COLOR_ENUM; (* Source bitmap info color table usage *)
                                     (* (DIB_RGB_COLORS) *)
            offBmiSrc    : DWORD;    (* Offset to the source BITMAPINFO structure *)
            cbBmiSrc     : DWORD;    (* Size of the source BITMAPINFO structure *)
            offBitsSrc   : DWORD;    (* Offset to the source bitmap bits *)
            cbBitsSrc    : DWORD;    (* Size of the source bitmap bits *)
END;
PEMRBITBLT = POINTER TO EMRBITBLT;

TYPE EMRSTRETCHBLT =
     RECORD
            emr          : EMR;
            rclBounds    : RECTL;          (* Inclusive-inclusive bounds in device units *)
            xDest        : LONG;
            yDest        : LONG;
            cxDest       : LONG;
            cyDest       : LONG;
            dwRop        : ROP;
            xSrc         : LONG;
            ySrc         : LONG;
            xformSrc     : XFORM;          (* Source DC transform *)
            crBkColorSrc : COLORREF;       (* Source DC BkColor in RGB *)
            iUsageSrc    : DIB_COLOR_ENUM; (* Source bitmap info color table usage *)
                                           (* (DIB_RGB_COLORS) *)
            offBmiSrc    : DWORD;          (* Offset to the source BITMAPINFO structure *)
            cbBmiSrc     : DWORD;          (* Size of the source BITMAPINFO structure *)
            offBitsSrc   : DWORD;          (* Offset to the source bitmap bits *)
            cbBitsSrc    : DWORD;          (* Size of the source bitmap bits *)
            cxSrc        : LONG;
            cySrc        : LONG;
     END;
     PEMRSTRETCHBLT = POINTER TO EMRSTRETCHBLT;

TYPE EMRMASKBLT =
     RECORD
            emr          : EMR;
            rclBounds    : RECTL;  (* Inclusive-inclusive bounds in device units *)
            xDest        : LONG;
            yDest        : LONG;
            cxDest       : LONG;
            cyDest       : LONG;
            dwRop        : ROP;
            xSrc         : LONG;
            ySrc         : LONG;
            xformSrc     : XFORM;          (* Source DC transform *)
            crBkColorSrc : COLORREF;       (* Source DC BkColor in RGB *)
            iUsageSrc    : DIB_COLOR_ENUM; (* Source bitmap info color table usage *)
            offBmiSrc    : DWORD;          (* Offset to the source BITMAPINFO structure *)
            cbBmiSrc     : DWORD;          (* Size of the source BITMAPINFO structure *)
            offBitsSrc   : DWORD;          (* Offset to the source bitmap bits *)
            cbBitsSrc    : DWORD;          (* Size of the source bitmap bits *)
            xMask        : LONG;
            yMask        : LONG;
            iUsageMask   : DIB_COLOR_ENUM; (* Mask bitmap info color table usage *)
            offBmiMask   : DWORD;          (* Offset to the mask BITMAPINFO structure if any *)
            cbBmiMask    : DWORD;          (* Size of the mask BITMAPINFO structure if any *)
            offBitsMask  : DWORD;          (* Offset to the mask bitmap bits if any *)
            cbBitsMask   : DWORD;          (* Size of the mask bitmap bits if any *)
     END;
     PEMRMASKBLT = POINTER TO EMRMASKBLT;

TYPE EMRPLGBLT =
     RECORD
            emr          : EMR;
            rclBounds    : RECTL;         (* Inclusive-inclusive bounds in device units *)
            aptlDest     : ARRAY [0..2] OF POINTL;
            xSrc         : LONG;
            ySrc         : LONG;
            cxSrc        : LONG;
            cySrc        : LONG;
            xformSrc     : XFORM;         (* Source DC transform *)
            crBkColorSrc : COLORREF;      (* Source DC BkColor in RGB *)
            iUsageSrc    : DIB_COLOR_ENUM;(* Source bitmap info color table usage *)
            offBmiSrc    : DWORD;         (* Offset to the source BITMAPINFO structure *)
            cbBmiSrc     : DWORD;         (* Size of the source BITMAPINFO structure *)
            offBitsSrc   : DWORD;         (* Offset to the source bitmap bits *)
            cbBitsSrc    : DWORD;         (* Size of the source bitmap bits *)
            xMask        : LONG;
            yMask        : LONG;
            iUsageMask   : DIB_COLOR_ENUM; (* Mask bitmap info color table usage *)
            offBmiMask   : DWORD;          (* Offset to the mask BITMAPINFO structure if any *)
            cbBmiMask    : DWORD;          (* Size of the mask BITMAPINFO structure if any *)
            offBitsMask  : DWORD;          (* Offset to the mask bitmap bits if any *)
            cbBitsMask   : DWORD;          (* Size of the mask bitmap bits if any *)
     END;
     PEMRPLGBLT = POINTER TO EMRPLGBLT;

TYPE EMRSETDIBITSTODEVICE =
     RECORD
            emr        : EMR;
            rclBounds  : RECTL;          (* Inclusive-inclusive bounds in device units *)
            xDest      : LONG;
            yDest      : LONG;
            xSrc       : LONG;
            ySrc       : LONG;
            cxSrc      : LONG;
            cySrc      : LONG;
            offBmiSrc  : DWORD;         (* Offset to the source BITMAPINFO structure *)
            cbBmiSrc   : DWORD;         (* Size of the source BITMAPINFO structure *)
            offBitsSrc : DWORD;         (* Offset to the source bitmap bits *)
            cbBitsSrc  : DWORD;         (* Size of the source bitmap bits *)
            iUsageSrc  : DIB_COLOR_ENUM;(* Source bitmap info color table usage *)
            iStartScan : DWORD;
            cScans     : DWORD;
     END;
    PEMRSETDIBITSTODEVICE = POINTER TO EMRSETDIBITSTODEVICE;

TYPE EMRSTRETCHDIBITS =
     RECORD
            emr        : EMR;
            rclBounds  : RECTL;          (* Inclusive-inclusive bounds in device units *)
            xDest      : LONG;
            yDest      : LONG;
            xSrc       : LONG;
            ySrc       : LONG;
            cxSrc      : LONG;
            cySrc      : LONG;
            offBmiSrc  : DWORD;          (* Offset to the source BITMAPINFO structure *)
            cbBmiSrc   : DWORD;          (* Size of the source BITMAPINFO structure *)
            offBitsSrc : DWORD;          (* Offset to the source bitmap bits *)
            cbBitsSrc  : DWORD;          (* Size of the source bitmap bits *)
            iUsageSrc  : DIB_COLOR_ENUM; (* Source bitmap info color table usage *)
            dwRop      : ROP;
            cxDest     : LONG;
            cyDest     : LONG;
     END;
     PEMRSTRETCHDIBITS = POINTER TO EMRSTRETCHDIBITS;

TYPE EMREXTCREATEFONTINDIRECTW = RECORD
                                        emr : EMR;
                                        ihFont : DWORD; (* Font handle index *)
                                        elfw : EXTLOGFONTW;
                                 END;
    PEMREXTCREATEFONTINDIRECTW = POINTER TO EMREXTCREATEFONTINDIRECTW;

TYPE EMRCREATEPALETTE = RECORD
                               emr   : EMR;
                               ihPal : DWORD;      (* Palette handle index *)
                               lgpl  : LOGPALETTE; (* The peFlags fields in the palette entries *)
                        END;                       (* do not contain any flags *)
    PEMRCREATEPALETTE = POINTER TO EMRCREATEPALETTE;

TYPE EMRCREATECOLORSPACE = RECORD
                                  emr  : EMR;
                                  ihCS : DWORD; (* ColorSpace handle index *)
                                  lcs  : LOGCOLORSPACEW;
                           END;
    PEMRCREATECOLORSPACE = POINTER TO EMRCREATECOLORSPACE;

TYPE EMRCREATEPEN = RECORD
                           emr : EMR;
                           ihPen : DWORD; (* Pen handle index *)
                           lopn : LOGPEN;
                    END;
    PEMRCREATEPEN = POINTER TO EMRCREATEPEN;

TYPE EMREXTCREATEPEN =
     RECORD
            emr     : EMR;
            ihPen   : DWORD;     (* Pen handle index *)
            offBmi  : DWORD;     (* Offset to the BITMAPINFO structure if any *)
            cbBmi   : DWORD;     (* Size of the BITMAPINFO structure if any *)
                                 (* The bitmap info is followed by the bitmap *)
                                 (* bits to form a packed DIB. *)
            offBits : DWORD;     (* Offset to the brush bitmap bits if any *)
            cbBits  : DWORD;     (* Size of the brush bitmap bits if any *)
            elp     : EXTLOGPEN; (* The extended pen with the style array. *)
     END;
     PEMREXTCREATEPEN = POINTER TO EMREXTCREATEPEN;

TYPE EMRCREATEBRUSHINDIRECT =
     RECORD
            emr     : EMR;
            ihBrush : DWORD;    (* Brush handle index *)
            lb      : LOGBRUSH; (* The style must be BS_SOLID, BS_HOLLOW, *)
                                (* BS_NULL or BS_HATCHED. *)
     END;
     PEMRCREATEBRUSHINDIRECT = POINTER TO EMRCREATEBRUSHINDIRECT;

TYPE EMRCREATEMONOBRUSH =
     RECORD
            emr     : EMR;
            ihBrush : DWORD;            (* Brush handle index *)
            iUsage  : DIB_COLOR_ENUM;   (* Bitmap info color table usage *)
            offBmi  : DWORD;            (* Offset to the BITMAPINFO structure *)
            cbBmi   : DWORD;            (* Size of the BITMAPINFO structure *)
            offBits : DWORD;            (* Offset to the bitmap bits *)
            cbBits  : DWORD;            (* Size of the bitmap bits *)
     END;
     PEMRCREATEMONOBRUSH = POINTER TO EMRCREATEMONOBRUSH;

TYPE EMRCREATEDIBPATTERNBRUSHPT =
     RECORD
            emr     : EMR;
            ihBrush : DWORD;    (* Brush handle index *)
            iUsage  : DWORD;    (* Bitmap info color table usage *)
            offBmi  : DWORD;    (* Offset to the BITMAPINFO structure *)
            cbBmi   : DWORD;    (* Size of the BITMAPINFO structure *)
                                (* The bitmap info is followed by the bitmap *)
                                (* bits to form a packed DIB. *)
            offBits : DWORD;    (* Offset to the bitmap bits *)
            cbBits  : DWORD;    (* Size of the bitmap bits *)
     END;
     PEMRCREATEDIBPATTERNBRUSHPT = POINTER TO EMRCREATEDIBPATTERNBRUSHPT;


TYPE EMRFORMAT =
     RECORD
            dSignature : DWORD;  (* Format signature, e.g. ENHMETA_SIGNATURE. *)
            nVersion : DWORD;    (* Format version number. *)
            cbData : DWORD;      (* Size of data in bytes. *)
            offData : DWORD;     (* Offset to data from GDICOMMENT_IDENTIFIER. *)
                                 (* It must begin at a DWORD offset. *)
     END;
     PEMRFORMAT = POINTER TO EMRFORMAT;

TYPE EMRGLSRECORD =
     RECORD
            emr : EMR;
            cbData : DWORD;             (* Size of data in bytes *)
            Data : ARRAY [0..0] OF BYTE;
     END;
     PEMRGLSRECORD = POINTER TO EMRGLSRECORD;

TYPE EMRGLSBOUNDEDRECORD =
     RECORD
            emr : EMR;
            rclBounds : RECTL;          (* Bounds in recording coordinates *)
            cbData : DWORD;             (* Size of data in bytes *)
            Data : ARRAY [0..0] OF BYTE;
     END;
     PEMRGLSBOUNDEDRECORD = POINTER TO EMRGLSBOUNDEDRECORD;

TYPE EMRPIXELFORMAT =
     RECORD
            emr : EMR;
            pfd : PIXELFORMATDESCRIPTOR;
     END;
     PEMRPIXELFORMAT = POINTER  TO EMRPIXELFORMAT;


CONST GDICOMMENT_IDENTIFIER        = 43494447h;
      GDICOMMENT_WINDOWS_METAFILE  = 80000001h;
      GDICOMMENT_BEGINGROUP        = 00000002h;
      GDICOMMENT_ENDGROUP          = 00000003h;
      GDICOMMENT_MULTIFORMATS      = 40000004h;
      EPS_SIGNATURE                = 46535045h;

<* END *>  (* NOT DEFINED (NOMETAFILE) *)


(* OpenGL wgl prototypes *)

PROCEDURE wglCopyContext (src : HGLRC; dst : HGLRC; mask : UINT) : BOOL;
PROCEDURE wglCreateContext (hdc : HDC) : HGLRC;
PROCEDURE wglCreateLayerContext (hdc : HDC; LayerPlane : INTEGER) : HGLRC;
PROCEDURE wglDeleteContext (hglrc : HGLRC) : BOOL;
PROCEDURE wglGetCurrentContext (): HGLRC;
PROCEDURE wglGetCurrentDC (): HDC;
PROCEDURE wglGetProcAddress (proc : ARRAY OF CHAR) : PROC;
PROCEDURE wglMakeCurrent (hdc : HDC; hrlrc : HGLRC) : BOOL;
PROCEDURE wglShareLists (hglrc1, hglrc2 : HGLRC) : BOOL;
PROCEDURE wglUseFontBitmapsA (hdc : HDC; first : DWORD; count : DWORD; listbase : DWORD) : BOOL;
PROCEDURE wglUseFontBitmapsW (hdc : HDC; first : DWORD; count : DWORD; listbase : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST wglUseFontBitmaps = wglUseFontBitmapsW;
<* ELSE *>
      CONST wglUseFontBitmaps = wglUseFontBitmapsA;
<* END *>

PROCEDURE SwapBuffers (hdc : HDC) : BOOL;

TYPE POINTFLOAT = RECORD
                         x : FLOAT;
                         y : FLOAT;
                  END;
    PPOINTFLOAT = POINTER TO POINTFLOAT;

TYPE GLYPHMETRICSFLOAT = RECORD
                                gmfBlackBoxX : FLOAT;
                                gmfBlackBoxY : FLOAT;
                                gmfptGlyphOrigin : POINTFLOAT;
                                gmfCellIncX : FLOAT;
                                gmfCellIncY : FLOAT;
                         END;
    PGLYPHMETRICSFLOAT = POINTER TO GLYPHMETRICSFLOAT;

TYPE WGI_FONT_ENUM = (WGL_FONT_LINES,     (* 0 *)
                      WGL_FONT_POLYGONS); (* 1 *)

PROCEDURE wglUseFontOutlinesA (hdc       : HDC;
                               first     : DWORD;
                               count     : DWORD;
                               listbase  : DWORD;
                               deviation : FLOAT;
                               extursion : FLOAT;
                               format    : WGI_FONT_ENUM;
                               VAR [NIL] gmf : ARRAY OF GLYPHMETRICSFLOAT) : BOOL;
PROCEDURE wglUseFontOutlinesW (hdc       : HDC;
                               first     : DWORD;
                               count     : DWORD;
                               listbase  : DWORD;
                               deviation : FLOAT;
                               extursion : FLOAT;
                               format    : WGI_FONT_ENUM;
                               VAR [NIL] gmf : ARRAY OF GLYPHMETRICSFLOAT) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST wglUseFontOutlines = wglUseFontOutlinesW;
<* ELSE *>
      CONST wglUseFontOutlines = wglUseFontOutlinesA;
<* END *>

(* LAYERPLANEDESCRIPTOR flags *)

TYPE LPD_ENUM = (LPD__DOUBLEBUFFER,       (* 0 *)
                 LPD__STEREO,             (* 1 *)
                 LPD__2, LPD__3,
                 LPD__SUPPORT_GDI,        (* 4 *)
                 LPD__SUPPORT_OPENGL,     (* 5*)
                 LPD__SHARE_DEPTH,        (* 6 *)
                 LPD__SHARE_STENCIL,      (* 7 *)
                 LPD__SHARE_ACCUM,        (* 8 *)
                 LPD__SWAP_EXCHANGE,      (* 9 *)
                 LPD__SWAP_COPY,          (* 10 *)
                 LPD__11,
                 LPD__TRANSPARENT);       (* 12 *)

TYPE LPD_SET = SET OF LPD_ENUM;

CONST LPD_DOUBLEBUFFER   = LPD_SET {LPD__DOUBLEBUFFER  }; (* 0x00000001 *)
      LPD_STEREO         = LPD_SET {LPD__STEREO        }; (* 0x00000002 *)
      LPD_SUPPORT_GDI    = LPD_SET {LPD__SUPPORT_GDI   }; (* 0x00000010 *)
      LPD_SUPPORT_OPENGL = LPD_SET {LPD__SUPPORT_OPENGL}; (* 0x00000020 *)
      LPD_SHARE_DEPTH    = LPD_SET {LPD__SHARE_DEPTH   }; (* 0x00000040 *)
      LPD_SHARE_STENCIL  = LPD_SET {LPD__SHARE_STENCIL }; (* 0x00000080 *)
      LPD_SHARE_ACCUM    = LPD_SET {LPD__SHARE_ACCUM   }; (* 0x00000100 *)
      LPD_SWAP_EXCHANGE  = LPD_SET {LPD__SWAP_EXCHANGE }; (* 0x00000200 *)
      LPD_SWAP_COPY      = LPD_SET {LPD__SWAP_COPY     }; (* 0x00000400 *)
      LPD_TRANSPARENT    = LPD_SET {LPD__TRANSPARENT   }; (* 0x00001000 *)

<* PUSH *> <* ENUMSIZE = "1" *>

TYPE LPD_TYPE_ENUM = (LPD_TYPE_RGBA,        (* 0 *)
                      LPD_TYPE_COLORINDEX); (* 1 *)

<* POP *>

TYPE LAYERPLANEDESCRIPTOR = RECORD
                                   nSize           : WORD;
                                   nVersion        : WORD;
                                   dwFlags         : LPD_SET;
                                   iPixelType      : LPD_TYPE_ENUM;
                                   cColorBits      : BYTE;
                                   cRedBits        : BYTE;
                                   cRedShift       : BYTE;
                                   cGreenBits      : BYTE;
                                   cGreenShift     : BYTE;
                                   cBlueBits       : BYTE;
                                   cBlueShift      : BYTE;
                                   cAlphaBits      : BYTE;
                                   cAlphaShift     : BYTE;
                                   cAccumBits      : BYTE;
                                   cAccumRedBits   : BYTE;
                                   cAccumGreenBits : BYTE;
                                   cAccumBlueBits  : BYTE;
                                   cAccumAlphaBits : BYTE;
                                   cDepthBits      : BYTE;
                                   cStencilBits    : BYTE;
                                   cAuxBuffers     : BYTE;
                                   iLayerPlane     : BYTE;
                                   bReserved       : BYTE;
                                   crTransparent   : COLORREF;
                            END;
     PLAYERPLANEDESCRIPTOR = POINTER TO LAYERPLANEDESCRIPTOR;

(* wglSwapLayerBuffers flags *)

TYPE WGL_SWAP_ENUM = (WGL_SWAP__MAIN_PLANE,     (*  0 *)
                      WGL_SWAP__OVERLAY1,       (*  1 *)
                      WGL_SWAP__OVERLAY2,       (*  2 *)
                      WGL_SWAP__OVERLAY3,       (*  3 *)
                      WGL_SWAP__OVERLAY4,       (*  4 *)
                      WGL_SWAP__OVERLAY5,       (*  5 *)
                      WGL_SWAP__OVERLAY6,       (*  6 *)
                      WGL_SWAP__OVERLAY7,       (*  7 *)
                      WGL_SWAP__OVERLAY8,       (*  8 *)
                      WGL_SWAP__OVERLAY9,       (*  9 *)
                      WGL_SWAP__OVERLAY10,      (* 10 *)
                      WGL_SWAP__OVERLAY11,      (* 11 *)
                      WGL_SWAP__OVERLAY12,      (* 12 *)
                      WGL_SWAP__OVERLAY13,      (* 13 *)
                      WGL_SWAP__OVERLAY14,      (* 14 *)
                      WGL_SWAP__OVERLAY15,      (* 15 *)
                      WGL_SWAP__UNDERLAY1,      (* 16 *)
                      WGL_SWAP__UNDERLAY2,      (* 17 *)
                      WGL_SWAP__UNDERLAY3,      (* 18 *)
                      WGL_SWAP__UNDERLAY4,      (* 19 *)
                      WGL_SWAP__UNDERLAY5,      (* 20 *)
                      WGL_SWAP__UNDERLAY6,      (* 21 *)
                      WGL_SWAP__UNDERLAY7,      (* 22 *)
                      WGL_SWAP__UNDERLAY8,      (* 23 *)
                      WGL_SWAP__UNDERLAY9,      (* 24 *)
                      WGL_SWAP__UNDERLAY10,     (* 25 *)
                      WGL_SWAP__UNDERLAY11,     (* 26 *)
                      WGL_SWAP__UNDERLAY12,     (* 27 *)
                      WGL_SWAP__UNDERLAY13,     (* 28 *)
                      WGL_SWAP__UNDERLAY14,     (* 29 *)
                      WGL_SWAP__UNDERLAY15);    (* 30 *)

      WGL_SWAP_SET = SET OF WGL_SWAP_ENUM;

CONST WGL_SWAP_MAIN_PLANE = WGL_SWAP_SET {WGL_SWAP__MAIN_PLANE}; (* 0x00000001 *)
      WGL_SWAP_OVERLAY1   = WGL_SWAP_SET {WGL_SWAP__OVERLAY1  }; (* 0x00000002 *)
      WGL_SWAP_OVERLAY2   = WGL_SWAP_SET {WGL_SWAP__OVERLAY2  }; (* 0x00000004 *)
      WGL_SWAP_OVERLAY3   = WGL_SWAP_SET {WGL_SWAP__OVERLAY3  }; (* 0x00000008 *)
      WGL_SWAP_OVERLAY4   = WGL_SWAP_SET {WGL_SWAP__OVERLAY4  }; (* 0x00000010 *)
      WGL_SWAP_OVERLAY5   = WGL_SWAP_SET {WGL_SWAP__OVERLAY5  }; (* 0x00000020 *)
      WGL_SWAP_OVERLAY6   = WGL_SWAP_SET {WGL_SWAP__OVERLAY6  }; (* 0x00000040 *)
      WGL_SWAP_OVERLAY7   = WGL_SWAP_SET {WGL_SWAP__OVERLAY7  }; (* 0x00000080 *)
      WGL_SWAP_OVERLAY8   = WGL_SWAP_SET {WGL_SWAP__OVERLAY8  }; (* 0x00000100 *)
      WGL_SWAP_OVERLAY9   = WGL_SWAP_SET {WGL_SWAP__OVERLAY9  }; (* 0x00000200 *)
      WGL_SWAP_OVERLAY10  = WGL_SWAP_SET {WGL_SWAP__OVERLAY10 }; (* 0x00000400 *)
      WGL_SWAP_OVERLAY11  = WGL_SWAP_SET {WGL_SWAP__OVERLAY11 }; (* 0x00000800 *)
      WGL_SWAP_OVERLAY12  = WGL_SWAP_SET {WGL_SWAP__OVERLAY12 }; (* 0x00001000 *)
      WGL_SWAP_OVERLAY13  = WGL_SWAP_SET {WGL_SWAP__OVERLAY13 }; (* 0x00002000 *)
      WGL_SWAP_OVERLAY14  = WGL_SWAP_SET {WGL_SWAP__OVERLAY14 }; (* 0x00004000 *)
      WGL_SWAP_OVERLAY15  = WGL_SWAP_SET {WGL_SWAP__OVERLAY15 }; (* 0x00008000 *)
      WGL_SWAP_UNDERLAY1  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY1 }; (* 0x00010000 *)
      WGL_SWAP_UNDERLAY2  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY2 }; (* 0x00020000 *)
      WGL_SWAP_UNDERLAY3  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY3 }; (* 0x00040000 *)
      WGL_SWAP_UNDERLAY4  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY4 }; (* 0x00080000 *)
      WGL_SWAP_UNDERLAY5  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY5 }; (* 0x00100000 *)
      WGL_SWAP_UNDERLAY6  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY6 }; (* 0x00200000 *)
      WGL_SWAP_UNDERLAY7  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY7 }; (* 0x00400000 *)
      WGL_SWAP_UNDERLAY8  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY8 }; (* 0x00800000 *)
      WGL_SWAP_UNDERLAY9  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY9 }; (* 0x01000000 *)
      WGL_SWAP_UNDERLAY10 = WGL_SWAP_SET {WGL_SWAP__UNDERLAY10}; (* 0x02000000 *)
      WGL_SWAP_UNDERLAY11 = WGL_SWAP_SET {WGL_SWAP__UNDERLAY11}; (* 0x04000000 *)
      WGL_SWAP_UNDERLAY12 = WGL_SWAP_SET {WGL_SWAP__UNDERLAY12}; (* 0x08000000 *)
      WGL_SWAP_UNDERLAY13 = WGL_SWAP_SET {WGL_SWAP__UNDERLAY13}; (* 0x10000000 *)
      WGL_SWAP_UNDERLAY14 = WGL_SWAP_SET {WGL_SWAP__UNDERLAY14}; (* 0x20000000 *)
      WGL_SWAP_UNDERLAY15 = WGL_SWAP_SET {WGL_SWAP__UNDERLAY15}; (* 0x40000000 *)

PROCEDURE wglDescribeLayerPlane (hdc : HDC; PixelFormat : INTEGER;
                                 LayerPlane : INTEGER;
                                 nBytes : UINT;
                                 VAR lpd : LAYERPLANEDESCRIPTOR) : BOOL;

PROCEDURE wglSetLayerPaletteEntries (hdc : HDC;
                                     LayerPlane : INTEGER;
                                     Start : INTEGER;
                                     nEntries : INTEGER;
                                     cr : ARRAY OF COLORREF) : INTEGER;

PROCEDURE wglGetLayerPaletteEntries (hdc : HDC;
                                     LayerPlane : INTEGER;
                                     Start : INTEGER;
                                     nEntries : INTEGER;
                                     VAR cr : ARRAY OF COLORREF) : INTEGER;

PROCEDURE wglRealizeLayerPalette (hdc : HDC; LayerPlane : INTEGER; Realize : BOOL) : BOOL;
PROCEDURE wglSwapLayerBuffers (hdc : HDC; Planes : WGL_SWAP_SET) : BOOL;


END WinGDI.
