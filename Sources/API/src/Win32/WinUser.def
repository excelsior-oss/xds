<* +M2EXTENSIONS  *>
<* ALIGNMENT="8" *>
<* ENUMSIZE="4" *>
<* SETSIZE="4" *>

DEFINITION MODULE ["StdCall"] WinUser;

IMPORT SYSTEM;

FROM WinDef IMPORT BOOL, UINT, ULONG, WCHAR, SHORT, USHORT, LONG,
            BYTE, WORD, DWORD, PVOID, PBYTE, PWORD,
            PSTR, PWSTR, PCSTR, PCWSTR,
            RESOURCESTR, RESOURCESTRA, RESOURCESTRW,
            ATOM, ATOMSTR, ATOMWSTR,
            HANDLE, HINSTANCE, HWND, HDC, HRGN,
            HICON, HCURSOR, HBRUSH, HMENU, HBITMAP,
            HACCEL, HKL, HDESK, HWINSTA, HHOOK,
            WPARAM, LPARAM, LRESULT,
            RECT, PRECT, POINT, PPOINT, COLORREF,
            MAKELONG;

FROM WinBase IMPORT PSECURITY_ATTRIBUTES, SLE_ENUM;
FROM WinNT   IMPORT SECURITY_INFORMATION, PSECURITY_DESCRIPTOR;
FROM WinGDI  IMPORT DEVMODEA, DEVMODEW, PDEVMODEA, PDEVMODEW, LOGFONTA, LOGFONTW;

(* ----------------------------------------------------- *)

TYPE HDWP = HANDLE;
TYPE PMENUTEMPLATEA = PVOID;
     PMENUTEMPLATEW = PVOID;

TYPE WNDPROC = PROCEDURE (HWND, UINT, WPARAM, LPARAM) : LRESULT;
     DLGPROC = PROCEDURE (HWND, UINT, WPARAM, LPARAM) : BOOL;
     TIMERPROC = PROCEDURE (HWND,
                            (* Msg     : *) UINT,
                            (* IdEvent : *) UINT,
                            (* Time    : *) DWORD);
     GRAYSTRINGPROC = PROCEDURE (HDC, LPARAM, INTEGER) : BOOL;
     WNDENUMPROC   = PROCEDURE (HWND, LPARAM) : BOOL;
     HOOKPROC      = PROCEDURE ((* code : *) INTEGER,
                                (* wParam : *) WPARAM,
                                (* lParam : *) LPARAM) : LRESULT;
     SENDASYNCPROC = PROCEDURE (HWND, UINT, DWORD, LRESULT);

TYPE PROPENUMPROCW   = PROCEDURE (HWND, ARRAY OF WCHAR, HANDLE) : BOOL;
     PROPENUMPROCA   = PROCEDURE (HWND, ARRAY OF CHAR,  HANDLE) : BOOL;
     PROPENUMPROCEXW = PROCEDURE (HWND, ARRAY OF WCHAR, HANDLE, DWORD) : BOOL;
     PROPENUMPROCEXA = PROCEDURE (HWND, ARRAY OF CHAR,  HANDLE, DWORD) : BOOL;

TYPE PCREATESTRUCTA = POINTER TO CREATESTRUCTA; (* used before definition in *)
     PCREATESTRUCTW = POINTER TO CREATESTRUCTW; (* CBT_CREATEWNDA *)

(*
 * EDITWORDBREAKPROC code values
 *)

TYPE WB_ENUM = (WB_LEFT, WB_RIGHT, WB_ISDELIMITER);

TYPE EDITWORDBREAKPROCA = PROCEDURE ((* lpch    : *) ARRAY OF CHAR,
                                     (* Current : *) INTEGER,
                                     (* cch     : *) INTEGER,
                                     (* code    : *) WB_ENUM) : INTEGER;

TYPE EDITWORDBREAKPROCW = PROCEDURE ((* lpch    : *) ARRAY OF WCHAR,
                                     (* Current : *) INTEGER,
                                     (* cch     : *) INTEGER,
                                     (* code    : *) WB_ENUM) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      TYPE PROPENUMPROC      = PROPENUMPROCW;
           PROPENUMPROCEX    = PROPENUMPROCEXW;
           EDITWORDBREAKPROC = EDITWORDBREAKPROCW;
<* ELSE *>
      TYPE PROPENUMPROC      = PROPENUMPROCA;
           PROPENUMPROCEX    = PROPENUMPROCEXA;
           EDITWORDBREAKPROC = EDITWORDBREAKPROCA;
<* END *>

TYPE DRAWSTATEPROC = PROCEDURE ((* hdc :   *) HDC,
                                (* lData : *) LPARAM,
                                (* wData : *) WPARAM,
                                (* cx :    *) INTEGER,
                                (* cy :    *) INTEGER) : BOOL;

TYPE  NAMEENUMPROCA = PROCEDURE (PSTR,  LPARAM) : BOOL;
      NAMEENUMPROCW = PROCEDURE (PWSTR, LPARAM) : BOOL;

TYPE   WINSTAENUMPROCA  = NAMEENUMPROCA;
       DESKTOPENUMPROCA = NAMEENUMPROCA;
       WINSTAENUMPROCW  = NAMEENUMPROCW;
       DESKTOPENUMPROCW = NAMEENUMPROCW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE WINSTAENUMPROC  = WINSTAENUMPROCW;
           DESKTOPENUMPROC = DESKTOPENUMPROCW;
<* ELSE *>
      TYPE WINSTAENUMPROC  = WINSTAENUMPROCA;
           DESKTOPENUMPROC = DESKTOPENUMPROCA;
<* END *>

(* MAKEINTRESOURCE is RTL call instead of C macro *)

PROCEDURE MAKEINTRESOURCEA (x : INTEGER) : RESOURCESTRA;
PROCEDURE MAKEINTRESOURCEW (x : INTEGER) : RESOURCESTRW;

<* IF DEFINED (UNICODE) THEN *>
      CONST MAKEINTRESOURCE = MAKEINTRESOURCEW;
<* ELSE *>
      CONST MAKEINTRESOURCE = MAKEINTRESOURCEA;
<* END *>

(* Predefined Resource Types *)

CONST RT_CURSOR       = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 1));
      RT_BITMAP       = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 2));
      RT_ICON         = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 3));
      RT_MENU         = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 4));
      RT_DIALOG       = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 5));
      RT_STRING       = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 6));
      RT_FONTDIR      = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 7));
      RT_FONT         = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 8));
      RT_ACCELERATOR  = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 9));
      RT_RCDATA       = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 10));
      RT_MESSAGETABLE = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 11));

CONST DIFFERENCE = 11;

CONST RT_GROUP_CURSOR = SYSTEM.CAST (RESOURCESTR, SYSTEM.CAST (ULONG, RT_CURSOR) + DIFFERENCE);
      RT_GROUP_ICON   = SYSTEM.CAST (RESOURCESTR, SYSTEM.CAST (ULONG, RT_ICON)   + DIFFERENCE);
      RT_VERSION      = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 16));
      RT_DLGINCLUDE   = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 17));
      RT_PLUGPLAY     = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 19));
      RT_VXD          = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 20));
      RT_ANICURSOR    = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 21));
      RT_ANIICON      = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 22));

PROCEDURE wvsprintfA (VAR result : ARRAY OF CHAR;
                      format : ARRAY OF CHAR;
                      arglist : SYSTEM.ADDRESS) : INTEGER;
PROCEDURE wvsprintfW (VAR result : ARRAY OF WCHAR;
                      format : ARRAY OF WCHAR;
                      arglist : SYSTEM.ADDRESS) : INTEGER;

PROCEDURE wsprintfA (VAR result : ARRAY OF CHAR;
                     format : ARRAY OF CHAR;
                     SEQ args : SYSTEM.BYTE) : INTEGER;
PROCEDURE wsprintfW (VAR result : ARRAY OF WCHAR;
                     format : ARRAY OF WCHAR;
                     SEQ args : SYSTEM.BYTE) : INTEGER;


<* IF DEFINED (UNICODE) THEN *>
      CONST wsprintf  = wsprintfW;
            wvsprintf = wvsprintfW;
<* ELSE *>
      CONST wsprintf = wsprintfA;
            wvsprintf = wvsprintfA;
<* END *>


(* Scroll Bar Constants *)

TYPE SB_TYPE = (SB_HORZ,      (* 0 *)
                SB_VERT,      (* 1 *)
                SB_CTL,       (* 2 *)
                SB_BOTH);     (* 3 *)

(* Scroll Bar Commands *)

TYPE SB_ENUM = (SB_LINEUP,         (* 0 *)
                SB_LINEDOWN,       (* 1 *)
                SB_PAGEUP,         (* 2 *)
                SB_PAGEDOWN,       (* 3 *)
                SB_THUMBPOSITION,  (* 4 *)
                SB_THUMBTRACK,     (* 5 *)
                SB_TOP,            (* 6 *)
                SB_BOTTOM,         (* 7 *)
                SB_ENDSCROLL);     (* 8 *)


CONST SB_LINELEFT  = SB_LINEUP;
      SB_LINERIGHT = SB_LINEDOWN;
      SB_PAGELEFT  = SB_PAGEUP;
      SB_PAGERIGHT = SB_PAGEDOWN;
      SB_LEFT      = SB_TOP;
      SB_RIGHT     = SB_BOTTOM;

(* ShowWindow commands *)

TYPE SW_ENUM = (SW_HIDE,            (* 0 *)
                SW_SHOWNORMAL,      (* 1 *)
                SW_SHOWMINIMIZED,   (* 2 *)
                SW_SHOWMAXIMIZED,   (* 3 *)
                SW_SHOWNOACTIVATE,  (* 4 *)
                SW_SHOW,            (* 5 *)
                SW_MINIMIZE,        (* 6 *)
                SW_SHOWMINNOACTIVE, (* 7 *)
                SW_SHOWNA,          (* 8 *)
                SW_RESTORE,         (* 9 *)
                SW_SHOWDEFAULT);    (* 10 *)

CONST SW_NORMAL   = SW_SHOWNORMAL;    (* 1 *)
      SW_MAXIMIZE = SW_SHOWMAXIMIZED; (* 3 *)
      SW_MAX      = SW_SHOWDEFAULT;   (* 10 *)

(* Old ShowWindow () Commands *)

CONST  HIDE_WINDOW         = SW_HIDE;             (* 0 *)
       SHOW_OPENWINDOW     = SW_NORMAL;           (* 1 *)
       SHOW_ICONWINDOW     = SW_SHOWMINIMIZED;    (* 2 *)
       SHOW_FULLSCREEN     = SW_SHOWMAXIMIZED;    (* 3 *)
       SHOW_OPENNOACTIVATE = SW_SHOWNOACTIVATE;   (* 4 *)


(* Identifiers for the LPARAM of WM_SHOWWINDOW message: 0 means ShowWindow
   has been called; otherwise, following values: *)

CONST SW_PARENTCLOSING = 1;
      SW_OTHERZOOM     = 2;
      SW_PARENTOPENING = 3;
      SW_OTHERUNZOOM   = 4;

(*
 * WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags - ???
 *)

TYPE KF_ENUM = (KF__0, KF__1,
                KF__2, KF__3,
                KF__4, KF__5,
                KF__6, KF__7,
                KF__EXTENDED,        (* 8 *)
                KF__9, KF__10,
                KF__DLGMODE,          (* 11 *)
                KF__MENUMODE,         (* 12 *)
                KF__ALTDOWN,          (* 13 *)
                KF__REPEAT,           (* 14 *)
                KF__UP);              (* 15 *)
     KF_SET = SET OF KF_ENUM;

CONST KF_EXTENDED = KF_SET {KF__EXTENDED};    (* 0x0100 *)
      KF_DLGMODE  = KF_SET {KF__DLGMODE};     (* 0x0800 *)
      KF_MENUMODE = KF_SET {KF__MENUMODE};    (* 0x1000 *)
      KF_ALTDOWN  = KF_SET {KF__ALTDOWN};     (* 0x2000 *)
      KF_REPEAT   = KF_SET {KF__REPEAT};      (* 0x4000 *)
      KF_UP       = KF_SET {KF__UP};          (* 0x8000 *)

(* Virtual Keys, Standard Set *)

CONST VK_LBUTTON     = 01h;
      VK_RBUTTON     = 02h;
      VK_CANCEL      = 03h;
      VK_MBUTTON     = 04h;    (* NOT contiguous with L & RBUTTON *)

      VK_BACK        = 08h;
      VK_TAB         = 09h;

      VK_CLEAR       = 0Ch;
      VK_RETURN      = 0Dh;

      VK_SHIFT       = 10h;
      VK_CONTROL     = 11h;
      VK_MENU        = 12h;
      VK_PAUSE       = 13h;
      VK_CAPITAL     = 14h;

      VK_ESCAPE      = 1Bh;

      VK_SPACE       = 20h;
      VK_PRIOR       = 21h;
      VK_NEXT        = 22h;
      VK_END         = 23h;
      VK_HOME        = 24h;
      VK_LEFT        = 25h;
      VK_UP          = 26h;
      VK_RIGHT       = 27h;
      VK_DOWN        = 28h;
      VK_SELECT      = 29h;
      VK_PRINT       = 2Ah;
      VK_EXECUTE     = 2Bh;
      VK_SNAPSHOT    = 2Ch;
      VK_INSERT      = 2Dh;
      VK_DELETE      = 2Eh;
      VK_HELP        = 2Fh;

(* VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) *)
(* VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) *)

      VK_LWIN        = 5Bh;
      VK_RWIN        = 5Ch;
      VK_APPS        = 5Dh;

      VK_NUMPAD0     = 60h;
      VK_NUMPAD1     = 61h;
      VK_NUMPAD2     = 62h;
      VK_NUMPAD3     = 63h;
      VK_NUMPAD4     = 64h;
      VK_NUMPAD5     = 65h;
      VK_NUMPAD6     = 66h;
      VK_NUMPAD7     = 67h;
      VK_NUMPAD8     = 68h;
      VK_NUMPAD9     = 69h;
      VK_MULTIPLY    = 6Ah;
      VK_ADD         = 6Bh;
      VK_SEPARATOR   = 6Ch;
      VK_SUBTRACT    = 6Dh;
      VK_DECIMAL     = 6Eh;
      VK_DIVIDE      = 6Fh;
      VK_F1          = 70h;
      VK_F2          = 71h;
      VK_F3          = 72h;
      VK_F4          = 73h;
      VK_F5          = 74h;
      VK_F6          = 75h;
      VK_F7          = 76h;
      VK_F8          = 77h;
      VK_F9          = 78h;
      VK_F10         = 79h;
      VK_F11         = 7Ah;
      VK_F12         = 7Bh;
      VK_F13         = 7Ch;
      VK_F14         = 7Dh;
      VK_F15         = 7Eh;
      VK_F16         = 7Fh;
      VK_F17         = 80h;
      VK_F18         = 81h;
      VK_F19         = 82h;
      VK_F20         = 83h;
      VK_F21         = 84h;
      VK_F22         = 85h;
      VK_F23         = 86h;
      VK_F24         = 87h;

      VK_NUMLOCK     = 90h;
      VK_SCROLL      = 91h;

(*
 * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 *)
      VK_LSHIFT      = 0A0h;
      VK_RSHIFT      = 0A1h;
      VK_LCONTROL    = 0A2h;
      VK_RCONTROL    = 0A3h;
      VK_LMENU       = 0A4h;
      VK_RMENU       = 0A5h;

      VK_PROCESSKEY  = 0E5h;

      VK_ATTN        = 0F6h;
      VK_CRSEL       = 0F7h;
      VK_EXSEL       = 0F8h;
      VK_EREOF       = 0F9h;
      VK_PLAY        = 0FAh;
      VK_ZOOM        = 0FBh;
      VK_NONAME      = 0FCh;
      VK_PA1         = 0FDh;
      VK_OEM_CLEAR   = 0FEh;


(* SetWindowsHook() codes *)

CONST WH_MIN              = -1;
      WH_MSGFILTER        = -1;
      WH_JOURNALRECORD    =  0;
      WH_JOURNALPLAYBACK  =  1;
      WH_KEYBOARD         =  2;
      WH_GETMESSAGE       =  3;
      WH_CALLWNDPROC      =  4;
      WH_CBT              =  5;
      WH_SYSMSGFILTER     =  6;
      WH_MOUSE            =  7;
      WH_HARDWARE         =  8;
      WH_DEBUG            =  9;
      WH_SHELL            = 10;
      WH_FOREGROUNDIDLE   = 11;
      WH_CALLWNDPROCRET   = 12;
      WH_MAX              = 12;
      WH_MINHOOK          = WH_MIN;
      WH_MAXHOOK          = WH_MAX;

(* Hook Codes *)

CONST HC_ACTION           = 0;
      HC_GETNEXT          = 1;
      HC_SKIP             = 2;
      HC_NOREMOVE         = 3;
      HC_NOREM            = HC_NOREMOVE;
      HC_SYSMODALON       = 4;
      HC_SYSMODALOFF      = 5;

(* CBT Hook Codes *)

CONST HCBT_MOVESIZE       = 0;
      HCBT_MINMAX         = 1;
      HCBT_QS             = 2;
      HCBT_CREATEWND      = 3;
      HCBT_DESTROYWND     = 4;
      HCBT_ACTIVATE       = 5;
      HCBT_CLICKSKIPPED   = 6;
      HCBT_KEYSKIPPED     = 7;
      HCBT_SYSCOMMAND     = 8;
      HCBT_SETFOCUS       = 9;

(* HCBT_CREATEWND parameters pointed to by lParam *)

TYPE CBT_CREATEWNDA  = RECORD
                              lpcs : PCREATESTRUCTA;
                              hwndInsertAfter : HWND;
                       END;
     PCBT_CREATEWNDA = POINTER TO CBT_CREATEWNDA;
     CBT_CREATEWNDW  = RECORD
                              lpcs : PCREATESTRUCTW;
                              hwndInsertAfter : HWND;
                       END;
     PCBT_CREATEWNDW = POINTER TO CBT_CREATEWNDW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE CBT_CREATEWND  = CBT_CREATEWNDW;
      TYPE PCBT_CREATEWND = PCBT_CREATEWNDW;
<* ELSE *>
      TYPE CBT_CREATEWND  = CBT_CREATEWNDA;
      TYPE PCBT_CREATEWND = PCBT_CREATEWNDA;
<* END *>

(* HCBT_ACTIVATE structure pointed to by lParam *)

TYPE CBTACTIVATESTRUCT = RECORD
                                fMouse : BOOL;
                                hWndActive : HWND;
                         END;
     PCBTACTIVATESTRUCT = POINTER TO CBTACTIVATESTRUCT;

(* WH_MSGFILTER Filter Proc Codes *)

CONST MSGF_DIALOGBOX    = 0;
      MSGF_MESSAGEBOX   = 1;
      MSGF_MENU         = 2;
      MSGF_MOVE         = 3;
      MSGF_SIZE         = 4;
      MSGF_SCROLLBAR    = 5;
      MSGF_NEXTWINDOW   = 6;
      MSGF_MAINLOOP     = 8;
      MSGF_MAX          = 8;
      MSGF_USER         = 4096;

(* Shell support *)

CONST HSHELL_WINDOWCREATED        = 1;
      HSHELL_WINDOWDESTROYED      = 2;
      HSHELL_ACTIVATESHELLWINDOW  = 3;
      HSHELL_WINDOWACTIVATED      = 4;
      HSHELL_GETMINRECT           = 5;
      HSHELL_REDRAW               = 6;
      HSHELL_TASKMAN              = 7;
      HSHELL_LANGUAGE             = 8;

(* Message Structure used in Journaling *)

TYPE EVENTMSG = RECORD
                       message : UINT;
                       paramL  : UINT;
                       paramH  : UINT;
                       time    : DWORD;
                       hwnd    : HWND;
                END;
    PEVENTMSG = POINTER TO EVENTMSG;

(* Message structure used by WH_CALLWNDPROC *)

TYPE CWPSTRUCT = RECORD
                       lParam  : LPARAM;
                       wParam  : WPARAM;
                       message : UINT;
                       hwnd    : HWND;
                 END;
    PCWPSTRUCT = POINTER TO CWPSTRUCT;

(* Message structure used by WH_CALLWNDPROCRET *)

TYPE CWPRETSTRUCT = RECORD
                           lResult : LRESULT;
                           lParam  : LPARAM;
                           wParam  : WPARAM;
                           message : UINT;
                           hwnd    : HWND;
                    END;
    PCWPRETSTRUCT = POINTER TO CWPRETSTRUCT;

(* Structure used by WH_DEBUG *)

TYPE DEBUGHOOKINFO = RECORD
                            idThread          : DWORD;
                            idThreadInstaller : DWORD;
                            lParam            : LPARAM;
                            wParam            : WPARAM;
                            code              : INTEGER;
                     END;
    PDEBUGHOOKINFO = POINTER TO DEBUGHOOKINFO;

(* Structure used by WH_MOUSE *)

TYPE MOUSEHOOKSTRUCT = RECORD
                              pt           : POINT;
                              hwnd         : HWND;
                              wHitTestCode : UINT;
                              dwExtraInfo  : DWORD;
                       END;
    PMOUSEHOOKSTRUCT = POINTER TO MOUSEHOOKSTRUCT;

(* Structure used by WH_HARDWARE *)

TYPE HARDWAREHOOKSTRUCT = RECORD
                                 hwnd    : HWND;
                                 message : UINT;
                                 wParam  : WPARAM;
                                 lParam  : LPARAM;
                          END;
    PHARDWAREHOOKSTRUCT = POINTER TO HARDWAREHOOKSTRUCT;

(* Keyboard Layout API *)

CONST HKL_PREV  = SYSTEM.CAST (HKL, VAL (ULONG, 0));
      HKL_NEXT  = SYSTEM.CAST (HKL, VAL (ULONG, 1));

TYPE KLF_ENUM = (KLF__ACTIVATE,       (* 0 *)
                 KLF__SUBSTITUTE_OK,  (* 1 *)
                 KLF__UNLOADPREVIOUS, (* 2 *)
                 KLF__REORDER,        (* 3 *)
                 KLF__REPLACELANG,    (* 4 *)
                 KLF__5, KLF__6,
                 KLF__NOTELLSHELL);   (* 7 *)

     KLF_SET = SET OF KLF_ENUM;

CONST KLF_ACTIVATE       = KLF_SET {KLF__ACTIVATE};      (* 0x00000001 *)
      KLF_SUBSTITUTE_OK  = KLF_SET {KLF__SUBSTITUTE_OK}; (* 0x00000002 *)
      KLF_UNLOADPREVIOUS = KLF_SET {KLF__UNLOADPREVIOUS};(* 0x00000004 *)
      KLF_REORDER        = KLF_SET {KLF__REORDER};       (* 0x00000008 *)
      KLF_REPLACELANG    = KLF_SET {KLF__REPLACELANG};   (* 0x00000010 *)
      KLF_NOTELLSHELL    = KLF_SET {KLF__NOTELLSHELL};   (* 0x00000080 *)

(*
 * Size of KeyboardLayoutName (number of characters), including nul terminator
 *)
CONST KL_NAMELENGTH = 9;

PROCEDURE LoadKeyboardLayoutA (KLID : ARRAY OF CHAR;  Flags : KLF_SET) : HKL;
PROCEDURE LoadKeyboardLayoutW (KLID : ARRAY OF WCHAR; Flags : KLF_SET) : HKL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadKeyboardLayout    = LoadKeyboardLayoutW;
<* ELSE *>
      CONST LoadKeyboardLayout    = LoadKeyboardLayoutA;
<* END *>

PROCEDURE ActivateKeyboardLayout (hkl  : HKL; Flags : KLF_SET) : HKL;
PROCEDURE ToUnicodeEx (wVirtKey   : UINT;
                       wScanCode  : UINT;
                       lpKeyState : PBYTE;
                       VAR Buff   : ARRAY OF CHAR;
                       cchBuff    : INTEGER;
                       wFlags     : UINT;
                       dwhkl      : HKL) : INTEGER;

PROCEDURE UnloadKeyboardLayout   (hkl  : HKL) : BOOL;
PROCEDURE GetKeyboardLayoutNameA (VAR KLID : ARRAY OF CHAR)  : BOOL;
PROCEDURE GetKeyboardLayoutNameW (VAR KLID : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetKeyboardLayoutName = GetKeyboardLayoutNameW;
<* ELSE *>
      CONST GetKeyboardLayoutName = GetKeyboardLayoutNameA;
<* END *>

PROCEDURE GetKeyboardLayoutList (nBuff : INTEGER;
                                 VAR lpList : ARRAY OF HKL) : INTEGER;

PROCEDURE GetKeyboardLayout (dwLayout : DWORD) : HKL;

(*
 * Desktop-specific access flags
 *)

TYPE DESKTOP_ENUM = (DESKTOP__READOBJECTS,     (* 0 *)
                     DESKTOP__CREATEWINDOW,    (* 1 *)
                     DESKTOP__CREATEMENU,      (* 2 *)
                     DESKTOP__HOOKCONTROL,     (* 3 *)
                     DESKTOP__JOURNALRECORD,   (* 4 *)
                     DESKTOP__JOURNALPLAYBACK, (* 5 *)
                     DESKTOP__ENUMERATE,       (* 6 *)
                     DESKTOP__WRITEOBJECTS,    (* 7 *)
                     DESKTOP__SWITCHDESKTOP);  (* 8 *)
     DESKTOP_SET = SET OF DESKTOP_ENUM;

CONST DESKTOP_READOBJECTS     = DESKTOP_SET {DESKTOP__READOBJECTS};     (* 0x0001L *)
      DESKTOP_CREATEWINDOW    = DESKTOP_SET {DESKTOP__CREATEWINDOW};    (* 0x0002L *)
      DESKTOP_CREATEMENU      = DESKTOP_SET {DESKTOP__CREATEMENU};      (* 0x0004L *)
      DESKTOP_HOOKCONTROL     = DESKTOP_SET {DESKTOP__HOOKCONTROL};     (* 0x0008L *)
      DESKTOP_JOURNALRECORD   = DESKTOP_SET {DESKTOP__JOURNALRECORD};   (* 0x0010L *)
      DESKTOP_JOURNALPLAYBACK = DESKTOP_SET {DESKTOP__JOURNALPLAYBACK}; (* 0x0020L *)
      DESKTOP_ENUMERATE       = DESKTOP_SET {DESKTOP__ENUMERATE};       (* 0x0040L *)
      DESKTOP_WRITEOBJECTS    = DESKTOP_SET {DESKTOP__WRITEOBJECTS};    (* 0x0080L *)
      DESKTOP_SWITCHDESKTOP   = DESKTOP_SET {DESKTOP__SWITCHDESKTOP};   (* 0x0100L *)

(*
 * Desktop-specific control flags
 *)

TYPE DF_ENUM = (DF__ALLOWOTHERACCOUNTHOOK); (* 0 *)
TYPE DF_SET = SET OF DF_ENUM;
CONST DF_ALLOWOTHERACCOUNTHOOK = DF_SET {DF__ALLOWOTHERACCOUNTHOOK}; (* 0001h *)

PROCEDURE CreateDesktopA (Desktop           : ARRAY OF CHAR;
                          lpszDevice        : PCSTR; (* NIL *)
                          VAR [NIL] Devmode : DEVMODEA; (* must be NIL *)
                          dwFlags           : DF_SET;
                          dwDesiredAccess   : DESKTOP_SET;
                          lpsa              : PSECURITY_ATTRIBUTES) : HDESK;

PROCEDURE CreateDesktopW (Desktop           : ARRAY OF WCHAR;
                          lpszDevice        : PCWSTR; (* NIL *)
                          VAR [NIL] Devmode : DEVMODEA; (* must be NIL *)
                          dwFlags           : DF_SET;
                          dwDesiredAccess   : DESKTOP_SET;
                          lpsa              : PSECURITY_ATTRIBUTES) : HDESK;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateDesktop = CreateDesktopW;
<* ELSE *>
      CONST CreateDesktop = CreateDesktopA;
<* END *>

PROCEDURE OpenDesktopA (lpszDesktop     : ARRAY OF CHAR;
                        dwFlags         : DF_SET;
                        fInherit        : BOOL;
                        dwDesiredAccess : DESKTOP_SET) : HDESK;

PROCEDURE OpenDesktopW (lpszDesktop     : ARRAY OF WCHAR;
                        dwFlags         : DF_SET;
                        fInherit        : BOOL;
                        dwDesiredAccess : DESKTOP_SET) : HDESK;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenDesktop = OpenDesktopW;
<* ELSE *>
      CONST OpenDesktop = OpenDesktopA;
<* END *>

PROCEDURE OpenInputDesktop (dwFlags         : DF_SET;
                            fInherit        : BOOL;
                            dwDesiredAccess : DESKTOP_SET) : HDESK;

PROCEDURE EnumDesktopsA (hwinsta    : HWINSTA;
                         lpEnumFunc : DESKTOPENUMPROCA;
                         lParam     : LPARAM)
                                               : BOOL;

PROCEDURE EnumDesktopsW (hwinsta    : HWINSTA;
                         lpEnumFunc : DESKTOPENUMPROCW;
                         lParam     : LPARAM)
                                               : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumDesktops = EnumDesktopsW;
<* ELSE *>
      CONST EnumDesktops = EnumDesktopsA;
<* END *>

PROCEDURE EnumDesktopWindows (hDesktop : HDESK;
                              lpfn : WNDENUMPROC;
                              lParam : LPARAM) : BOOL;

PROCEDURE SwitchDesktop    (hDesktop   : HDESK) : BOOL;
PROCEDURE SetThreadDesktop (hDesktop   : HDESK) : BOOL;
PROCEDURE CloseDesktop     (hDesktop   : HDESK) : BOOL;
PROCEDURE GetThreadDesktop (dwThreadId : DWORD) : HDESK;

(*
 * Windowstation-specific access flags
 *)

TYPE WINSTA_ENUM = (WINSTA__ENUMDESKTOPS,      (* 0 *)
                    WINSTA__READATTRIBUTES,    (* 1 *)
                    WINSTA__ACCESSCLIPBOARD,   (* 2 *)
                    WINSTA__CREATEDESKTOP,     (* 3 *)
                    WINSTA__WRITEATTRIBUTES,   (* 4 *)
                    WINSTA__ACCESSGLOBALATOMS, (* 5 *)
                    WINSTA__EXITWINDOWS,       (* 6 *)
                    WINSTA__7,
                    WINSTA__ENUMERATE,         (* 8 *)
                    WINSTA__READSCREEN);       (* 9 *)
     WINSTA_SET = SET OF WINSTA_ENUM;

CONST WINSTA_ENUMDESKTOPS      = WINSTA_SET {WINSTA__ENUMDESKTOPS};      (* 0x0001L *)
      WINSTA_READATTRIBUTES    = WINSTA_SET {WINSTA__READATTRIBUTES};    (* 0x0002L *)
      WINSTA_ACCESSCLIPBOARD   = WINSTA_SET {WINSTA__ACCESSCLIPBOARD};   (* 0x0004L *)
      WINSTA_CREATEDESKTOP     = WINSTA_SET {WINSTA__CREATEDESKTOP};     (* 0x0008L *)
      WINSTA_WRITEATTRIBUTES   = WINSTA_SET {WINSTA__WRITEATTRIBUTES};   (* 0x0010L *)
      WINSTA_ACCESSGLOBALATOMS = WINSTA_SET {WINSTA__ACCESSGLOBALATOMS}; (* 0x0020L *)
      WINSTA_EXITWINDOWS       = WINSTA_SET {WINSTA__EXITWINDOWS};       (* 0x0040L *)
      WINSTA_ENUMERATE         = WINSTA_SET {WINSTA__ENUMERATE};         (* 0x0100L *)
      WINSTA_READSCREEN        = WINSTA_SET {WINSTA__READSCREEN};        (* 0x0200L *)

(*
 * Windowstation-specific attribute flags
 *)

CONST WSF_VISIBLE = 1;

PROCEDURE CreateWindowStationA (lpwinsta        : PCSTR;  (* NIL *)
                                dwReserved      : DWORD;
                                dwDesiredAccess : WINSTA_SET;
                                lpsa            : PSECURITY_ATTRIBUTES) : HWINSTA;

PROCEDURE CreateWindowStationW (lpwinsta        : PCWSTR; (* NIL *)
                                dwReserved      : DWORD;
                                dwDesiredAccess : WINSTA_SET;
                                lpsa            : PSECURITY_ATTRIBUTES) : HWINSTA;


PROCEDURE OpenWindowStationA (lpszWinSta      : ARRAY OF CHAR;
                              fInherit        : BOOL;
                              dwDesiredAccess : WINSTA_SET) : HWINSTA;

PROCEDURE OpenWindowStationW (lpszWinSta      : ARRAY OF WCHAR;
                              fInherit        : BOOL;
                              dwDesiredAccess : WINSTA_SET) : HWINSTA;

PROCEDURE EnumWindowStationsA (lpEnumFunc : WINSTAENUMPROCA;
                               lParam     : LPARAM) : BOOL;

PROCEDURE EnumWindowStationsW (lpEnumFunc : WINSTAENUMPROCW;
                               lParam     : LPARAM) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateWindowStation = CreateWindowStationW;
            OpenWindowStation   = OpenWindowStationW;
            EnumWindowStations  = EnumWindowStationsW;
<* ELSE *>
      CONST CreateWindowStation = CreateWindowStationA;
            OpenWindowStation   = OpenWindowStationA;
            EnumWindowStations  = EnumWindowStationsA;
<* END *>

PROCEDURE CloseWindowStation      (hWinSta : HWINSTA) : BOOL;
PROCEDURE SetProcessWindowStation (hWinSta : HWINSTA) : BOOL;
PROCEDURE GetProcessWindowStation () : HWINSTA;

PROCEDURE SetUserObjectSecurity (hObj : HANDLE;
                                 VAR SIRequested : SECURITY_INFORMATION;
                                 pSID : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE GetUserObjectSecurity (hObj : HANDLE;
                                 VAR SIRequested : SECURITY_INFORMATION;
                                 pSID : PSECURITY_DESCRIPTOR;
                                 nLength : DWORD;
                                 VAR LengthNeeded : DWORD) : BOOL;

TYPE UOI_INDEX = (UOI_0,
                  UOI_FLAGS,     (* 1 *)
                  UOI_NAME,      (* 2 *)
                  UOI_TYPE,      (* 3 *)
                  UOI_USER_SID); (* 4 *)

TYPE USEROBJECTFLAGS = RECORD
                              fInherit  : BOOL;
                              fReserved : BOOL;
                              dwFlags   : DWORD;
                       END;
    PUSEROBJECTFLAGS = POINTER TO USEROBJECTFLAGS;

PROCEDURE GetUserObjectInformationA (hObj    : HANDLE;
                                     nIndex  : UOI_INDEX;
                                     pvInfo  : PVOID;
                                     nLength : DWORD;
                                     VAR LengthNeeded : DWORD) : BOOL;

PROCEDURE GetUserObjectInformationW (hObj    : HANDLE;
                                     nIndex  : UOI_INDEX;
                                     pvInfo  : PVOID;
                                     nLength : DWORD;
                                     VAR LengthNeeded : DWORD) : BOOL;

PROCEDURE SetUserObjectInformationA (hObj    : HANDLE;
                                     nIndex  : UOI_INDEX;
                                     pvInfo  : PVOID;
                                     nLength : DWORD) : BOOL;

PROCEDURE SetUserObjectInformationW (hObj    : HANDLE;
                                     nIndex  : UOI_INDEX;
                                     pvInfo  : PVOID;
                                     nLength : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetUserObjectInformation = GetUserObjectInformationW;
            SetUserObjectInformation = SetUserObjectInformationW;
<* ELSE *>
      CONST GetUserObjectInformation = GetUserObjectInformationA;
            SetUserObjectInformation = SetUserObjectInformationA;
<* END *>

(* Class style constants *)

TYPE CS_ENUM = (CS__VREDRAW,          (* 0 *)
                CS__HREDRAW,          (* 1 *)
                CS__KEYCVTWINDOW,     (* 2 *)
                CS__DBLCLKS,          (* 3 *)
                CS__4,
                CS__OWNDC,            (* 5 *)
                CS__CLASSDC,          (* 6 *)
                CS__PARENTDC,         (* 7 *)
                CS__NOKEYCVT,         (* 8 *)
                CS__NOCLOSE,          (* 9 *)
                CS__10,
                CS__SAVEBITS,         (*11 *)
                CS__BYTEALIGNCLIENT,  (*12 *)
                CS__BYTEALIGNWINDOW,  (*13 *)
                CS__GLOBALCLASS,      (*14 *)
                CS__15,
                CS__IME);             (*16 *)

TYPE CS_SET = SET OF CS_ENUM;

CONST CS_VREDRAW          = CS_SET {CS__VREDRAW};           (* 0x00001 *)
      CS_HREDRAW          = CS_SET {CS__HREDRAW};           (* 0x00002 *)
      CS_KEYCVTWINDOW     = CS_SET {CS__KEYCVTWINDOW};      (* 0x00004 *)
      CS_DBLCLKS          = CS_SET {CS__DBLCLKS};           (* 0x00008 *)
      CS_OWNDC            = CS_SET {CS__OWNDC};             (* 0x00020 *)
      CS_CLASSDC          = CS_SET {CS__CLASSDC};           (* 0x00040 *)
      CS_PARENTDC         = CS_SET {CS__PARENTDC};          (* 0x00080 *)
      CS_NOKEYCVT         = CS_SET {CS__NOKEYCVT};          (* 0x00100 *)
      CS_NOCLOSE          = CS_SET {CS__NOCLOSE};           (* 0x00200 *)
      CS_SAVEBITS         = CS_SET {CS__SAVEBITS};          (* 0x00800 *)
      CS_BYTEALIGNCLIENT  = CS_SET {CS__BYTEALIGNCLIENT};   (* 0x01000 *)
      CS_BYTEALIGNWINDOW  = CS_SET {CS__BYTEALIGNWINDOW};   (* 0x02000 *)
      CS_GLOBALCLASS      = CS_SET {CS__GLOBALCLASS};       (* 0x04000 *)
      CS_IME              = CS_SET {CS__IME};               (* 0x10000 *)

TYPE WNDCLASSEXA = RECORD
                          cbSize        : UINT;
                          style         : CS_SET;
                          lpfnWndProc   : WNDPROC;
                          cbClsExtra    : INTEGER;
                          cbWndExtra    : INTEGER;
                          hInstance     : HINSTANCE;
                          hIcon         : HICON;
                          hCursor       : HCURSOR;
                          hbrBackground : HBRUSH;
                          lpszMenuName  : RESOURCESTRA;
                          lpszClassName : ATOMSTR;
                          hIconSm       : HICON;
                   END;
      PWNDCLASSEXA = POINTER TO WNDCLASSEXA;

TYPE WNDCLASSEXW = RECORD
                          cbSize        : UINT;
                          style         : CS_SET;
                          lpfnWndProc   : WNDPROC;
                          cbClsExtra    : INTEGER;
                          cbWndExtra    : INTEGER;
                          hInstance     : HINSTANCE;
                          hIcon         : HICON;
                          hCursor       : HCURSOR;
                          hbrBackground : HBRUSH;
                          lpszMenuName  : RESOURCESTRW;
                          lpszClassName : ATOMWSTR;
                          hIconSm       : HICON;
                  END;
      PWNDCLASSEXW = POINTER TO WNDCLASSEXW;

TYPE WNDCLASSA = RECORD
                        style         : CS_SET;
                        lpfnWndProc   : WNDPROC;
                        cbClsExtra    : INTEGER;
                        cbWndExtra    : INTEGER;
                        hInstance     : HINSTANCE;
                        hIcon         : HICON;
                        hCursor       : HCURSOR;
                        hbrBackground : HBRUSH;
                        lpszMenuName  : RESOURCESTRA;
                        lpszClassName : ATOMSTR;
                END;
      PWNDCLASSA = POINTER TO WNDCLASSA;

TYPE WNDCLASSW = RECORD
                        style         : CS_SET;
                        lpfnWndProc   : WNDPROC;
                        cbClsExtra    : INTEGER;
                        cbWndExtra    : INTEGER;
                        hInstance     : HINSTANCE;
                        hIcon         : HICON;
                        hCursor       : HCURSOR;
                        hbrBackground : HBRUSH;
                        lpszMenuName  : RESOURCESTRW;
                        lpszClassName : ATOMWSTR;
                 END;
      PWNDCLASSW = POINTER TO WNDCLASSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE
           WNDCLASSEX   = WNDCLASSEXW;
           WNDCLASS     = WNDCLASSW;
           PWNDCLASSEX  = PWNDCLASSEXW;
           PWNDCLASS    = PWNDCLASSW;
<* ELSE *>
      TYPE WNDCLASSEX   = WNDCLASSEXA;
           WNDCLASS     = WNDCLASSA;
           PWNDCLASSEX  = PWNDCLASSEXA;
           PWNDCLASS    = PWNDCLASSA;
<* END *>

TYPE MSG = RECORD
                hwnd    : HWND;
                message : UINT;
                wParam  : WPARAM;
                lParam  : LPARAM;
                time    : DWORD;
                pt      : POINT;
           END;
    PMSG = POINTER TO MSG;

(* Following 2 procedures were macra in windows.h, so they're implemented
   in RTL
*)

PROCEDURE POINTSTOPOINT (VAR pt : POINT; pts : LPARAM);
<* IF BACKEND # "C" THEN *>
PROCEDURE POINTTOPOINTS (pt : POINT) : LPARAM;
<* ELSE *>
PROCEDURE POINTTOPOINTS (pt : PPOINT) : LPARAM;
<* END *>

(*
PROCEDURE MAKEWPARAM  (l, h : WORD) : WPARAM;
PROCEDURE MAKELPARAM  (l, h : WORD) : LPARAM;
PROCEDURE MAKELRESULT (l, h : WORD) : LRESULT;
*)

CONST MAKEWPARAM  = MAKELONG;
      MAKELPARAM  = MAKELONG;
      MAKELRESULT = MAKELONG;

(* Window field offsets for GetWindowLong *)

CONST GWL_WNDPROC     =   -4;
      GWL_HINSTANCE   =   -6;
      GWL_HWNDPARENT  =   -8;
      GWL_STYLE       =   -16;
      GWL_EXSTYLE     =   -20;
      GWL_USERDATA    =   -21;
      GWL_ID          =   -12;

(* Class field offsets for GetClassLong *)
CONST  GCL_MENUNAME        = -8;
       GCL_HBRBACKGROUND   = -10;
       GCL_HCURSOR         = -12;
       GCL_HICON           = -14;
       GCL_HMODULE         = -16;
       GCL_CBWNDEXTRA      = -18;
       GCL_CBCLSEXTRA      = -20;
       GCL_WNDPROC         = -24;
       GCL_STYLE           = -26;
       GCW_ATOM            = -32;
       GCL_HICONSM         = -34;

(* Window Messages                                                      *)

CONST WM_NULL                   =      0000h;
      WM_CREATE                 =      0001h;
      WM_DESTROY                =      0002h;
      WM_MOVE                   =      0003h;
      WM_SIZE                   =      0005h;
      WM_ACTIVATE   =                  0006h;

(* WM_ACTIVATE state values *)
           WA_INACTIVE    =  0;
           WA_ACTIVE      =  1;
           WA_CLICKACTIVE =  2;

       WM_SETFOCUS              =      0007h;
       WM_KILLFOCUS             =      0008h;
       WM_ENABLE                =      000Ah;
       WM_SETREDRAW             =      000Bh;
       WM_SETTEXT               =      000Ch;
       WM_GETTEXT               =      000Dh;
       WM_GETTEXTLENGTH         =      000Eh;
       WM_PAINT                 =      000Fh;
       WM_CLOSE                 =      0010h;
       WM_QUERYENDSESSION       =      0011h;
       WM_QUIT                  =      0012h;
       WM_QUERYOPEN             =      0013h;
       WM_ERASEBKGND            =      0014h;
       WM_SYSCOLORCHANGE        =      0015h;
       WM_ENDSESSION            =      0016h;
       WM_SHOWWINDOW            =      0018h;
       WM_WININICHANGE          =      001Ah;
       WM_SETTINGCHANGE         =      WM_WININICHANGE;
       WM_DEVMODECHANGE         =      001Bh;
       WM_ACTIVATEAPP           =      001Ch;
       WM_FONTCHANGE            =      001Dh;
       WM_TIMECHANGE            =      001Eh;
       WM_CANCELMODE            =      001Fh;
       WM_SETCURSOR             =      0020h;
       WM_MOUSEACTIVATE         =      0021h;
       WM_CHILDACTIVATE         =      0022h;
       WM_QUEUESYNC             =      0023h;

       WM_GETMINMAXINFO         =      0024h;

(* Struct pointed to by WM_GETMINMAXINFO lParam *)

TYPE MINMAXINFO = RECORD
                       ptReserved     : POINT;
                       ptMaxSize      : POINT;
                       ptMaxPosition  : POINT;
                       ptMinTrackSize : POINT;
                       ptMaxTrackSize : POINT;
                  END;
    PMINMAXINFO = POINTER TO MINMAXINFO;

CONST  WM_PAINTICON             =      0026h;
       WM_ICONERASEBKGND        =      0027h;
       WM_NEXTDLGCTL            =      0028h;
       WM_SPOOLERSTATUS         =      002Ah;
       WM_DRAWITEM              =      002Bh;
       WM_MEASUREITEM           =      002Ch;
       WM_DELETEITEM            =      002Dh;
       WM_VKEYTOITEM            =      002Eh;
       WM_CHARTOITEM            =      002Fh;
       WM_SETFONT               =      0030h;
       WM_GETFONT               =      0031h;
       WM_SETHOTKEY             =      0032h;
       WM_GETHOTKEY             =      0033h;
       WM_QUERYDRAGICON         =      0037h;
       WM_COMPAREITEM           =      0039h;
       WM_COMPACTING            =      0041h;
       WM_OTHERWINDOWCREATED    =      0042h;  (* no longer suported *)
       WM_OTHERWINDOWDESTROYED  =      0043h;  (* no longer suported *)
       WM_COMMNOTIFY            =      0044h;  (* no longer suported *)
       WM_WINDOWPOSCHANGING     =      0046h;
       WM_WINDOWPOSCHANGED      =      0047h;

CONST  WM_POWER                 =      0048h;

(* wParam for WM_POWER window message and DRV_POWER driver notification *)
           PWR_OK              =  1;
           PWR_FAIL            = -1;
           PWR_SUSPENDREQUEST  =  1;
           PWR_SUSPENDRESUME   =  2;
           PWR_CRITICALRESUME  =  3;

       WM_COPYDATA              =      004Ah;
       WM_CANCELJOURNAL         =      004Bh;

(* lParam of WM_COPYDATA message points to... *)

TYPE COPYDATASTRUCT = RECORD
                           dwData : DWORD;
                           cbData : DWORD;
                           lpData : PBYTE;
                      END;
    PCOPYDATASTRUCT = POINTER TO COPYDATASTRUCT;

CONST  WM_NOTIFY                =      004Eh;
       WM_INPUTLANGCHANGEREQUEST=      0050h;
       WM_INPUTLANGCHANGE       =      0051h;
       WM_TCARD                 =      0052h;
       WM_HELP                  =      0053h;
       WM_USERCHANGED           =      0054h;
       WM_NOTIFYFORMAT          =      0055h;

(* return codes for WM_NOTIFYFORMAT *)

           NFR_ANSI            = 1;
           NFR_UNICODE         = 2;

(* lParam values for WM_NOTIFYFORMAT *)

           NF_QUERY            = 3;
           NF_REQUERY          = 4;

       WM_CONTEXTMENU           =      007Bh;
       WM_STYLECHANGING         =      007Ch;
       WM_STYLECHANGED          =      007Dh;
       WM_DISPLAYCHANGE         =      007Eh;
       WM_GETICON               =      007Fh;
       WM_SETICON               =      0080h;

       WM_NCCREATE              =      0081h;
       WM_NCDESTROY             =      0082h;
       WM_NCCALCSIZE            =      0083h;
       WM_NCHITTEST             =      0084h;
       WM_NCPAINT               =      0085h;
       WM_NCACTIVATE            =      0086h;
       WM_GETDLGCODE            =      0087h;

       WM_NCMOUSEMOVE           =      00A0h;
       WM_NCLBUTTONDOWN         =      00A1h;
       WM_NCLBUTTONUP           =      00A2h;
       WM_NCLBUTTONDBLCLK       =      00A3h;
       WM_NCRBUTTONDOWN         =      00A4h;
       WM_NCRBUTTONUP           =      00A5h;
       WM_NCRBUTTONDBLCLK       =      00A6h;
       WM_NCMBUTTONDOWN         =      00A7h;
       WM_NCMBUTTONUP           =      00A8h;
       WM_NCMBUTTONDBLCLK       =      00A9h;

       WM_KEYFIRST              =      0100h;
       WM_KEYDOWN               =      0100h;
       WM_KEYUP                 =      0101h;
       WM_CHAR                  =      0102h;
       WM_DEADCHAR              =      0103h;
       WM_SYSKEYDOWN            =      0104h;
       WM_SYSKEYUP              =      0105h;
       WM_SYSCHAR               =      0106h;
       WM_SYSDEADCHAR           =      0107h;
       WM_KEYLAST               =      0108h;

       WM_IME_STARTCOMPOSITION  =      010Dh;
       WM_IME_ENDCOMPOSITION    =      010Eh;
       WM_IME_COMPOSITION       =      010Fh;
       WM_IME_KEYLAST           =      010Fh;

       WM_INITDIALOG            =      0110h;
       WM_COMMAND               =      0111h;
       WM_SYSCOMMAND            =      0112h;
       WM_TIMER                 =      0113h;
       WM_HSCROLL               =      0114h;
       WM_VSCROLL               =      0115h;
       WM_INITMENU              =      0116h;
       WM_INITMENUPOPUP         =      0117h;
       WM_MENUSELECT            =      011Fh;
       WM_MENUCHAR              =      0120h;
       WM_ENTERIDLE             =      0121h;

       WM_CTLCOLORMSGBOX        =      0132h;
       WM_CTLCOLOREDIT          =      0133h;
       WM_CTLCOLORLISTBOX       =      0134h;
       WM_CTLCOLORBTN           =      0135h;
       WM_CTLCOLORDLG           =      0136h;
       WM_CTLCOLORSCROLLBAR     =      0137h;
       WM_CTLCOLORSTATIC        =      0138h;

       WM_MOUSEFIRST            =      0200h;
       WM_MOUSEMOVE             =      0200h;
       WM_LBUTTONDOWN           =      0201h;
       WM_LBUTTONUP             =      0202h;
       WM_LBUTTONDBLCLK         =      0203h;
       WM_RBUTTONDOWN           =      0204h;
       WM_RBUTTONUP             =      0205h;
       WM_RBUTTONDBLCLK         =      0206h;
       WM_MBUTTONDOWN           =      0207h;
       WM_MBUTTONUP             =      0208h;
       WM_MBUTTONDBLCLK         =      0209h;
       WM_MOUSEWHEEL            =      020Ah;
       WM_MOUSELAST             =      020Ah;

CONST WHEEL_DELTA               =      120;            (*  Value for rolling one detent *)
      WHEEL_PAGESCROLL          =      MAX (CARDINAL); (* Scroll one page *)

CONST  WM_PARENTNOTIFY          =      0210h;
           MENULOOP_WINDOW = 0;
           MENULOOP_POPUP  = 1;
       WM_ENTERMENULOOP         =      0211h;
       WM_EXITMENULOOP          =      0212h;

       WM_NEXTMENU              =      0213h;

TYPE MDINEXTMENU = RECORD
                          hmenuIn   : HMENU;
                          hmenuNext : HMENU;
                          hwndNext  : HWND;
                   END;
    PMDINEXTMENU = POINTER TO MDINEXTMENU;

CONST  WM_SIZING                =      0214h;
       WM_CAPTURECHANGED        =      0215h;
       WM_MOVING                =      0216h;
       WM_POWERBROADCAST        =      0218h;

       PBT_APMQUERYSUSPEND       =         0;
       PBT_APMQUERYSTANDBY       =         1;
       PBT_APMQUERYSUSPENDFAILED =         2;
       PBT_APMQUERYSTANDBYFAILED =         3;
       PBT_APMSUSPEND            =         4;
       PBT_APMSTANDBY            =         5;
       PBT_APMRESUMECRITICAL     =         6;
       PBT_APMRESUMESUSPEND      =         7;
       PBT_APMRESUMESTANDBY      =         7;
       PBT_APMRESUMEFROMFAILURE  =         1;
       PBT_APMBATTERYLOW         =         9;
       PBT_APMPOWERSTATUSCHANGE  =        10;
       PBT_APMOEMEVENT           =        11;

       WM_DEVICECHANGE          =      0219h;

       WM_IME_SETCONTEXT        =      0281h;
       WM_IME_NOTIFY            =      0282h;
       WM_IME_CONTROL           =      0283h;
       WM_IME_COMPOSITIONFULL   =      0284h;
       WM_IME_SELECT            =      0285h;
       WM_IME_CHAR              =      0286h;
       WM_IME_KEYDOWN           =      0290h;
       WM_IME_KEYUP             =      0291h;

       WM_MDICREATE             =      0220h;
       WM_MDIDESTROY            =      0221h;
       WM_MDIACTIVATE           =      0222h;
       WM_MDIRESTORE            =      0223h;
       WM_MDINEXT               =      0224h;
       WM_MDIMAXIMIZE           =      0225h;
       WM_MDITILE               =      0226h;
       WM_MDICASCADE            =      0227h;
       WM_MDIICONARRANGE        =      0228h;
       WM_MDIGETACTIVE          =      0229h;

       WM_MDISETMENU            =      0230h;
       WM_ENTERSIZEMOVE         =      0231h;
       WM_EXITSIZEMOVE          =      0232h;
       WM_DROPFILES             =      0233h;
       WM_MDIREFRESHMENU        =      0234h;

       WM_MOUSEHOVER            =      02A1h;
       WM_MOUSELEAVE            =      02A3h;

       WM_CUT                   =      0300h;
       WM_COPY                  =      0301h;
       WM_PASTE                 =      0302h;
       WM_CLEAR                 =      0303h;
       WM_UNDO                  =      0304h;
       WM_RENDERFORMAT          =      0305h;
       WM_RENDERALLFORMATS      =      0306h;
       WM_DESTROYCLIPBOARD      =      0307h;
       WM_DRAWCLIPBOARD         =      0308h;
       WM_PAINTCLIPBOARD        =      0309h;
       WM_VSCROLLCLIPBOARD      =      030Ah;
       WM_SIZECLIPBOARD         =      030Bh;
       WM_ASKCBFORMATNAME       =      030Ch;
       WM_CHANGECBCHAIN         =      030Dh;
       WM_HSCROLLCLIPBOARD      =      030Eh;
       WM_QUERYNEWPALETTE       =      030Fh;
       WM_PALETTEISCHANGING     =      0310h;
       WM_PALETTECHANGED        =      0311h;
       WM_HOTKEY                =      0312h;

       WM_PRINT                 =      0317h;
       WM_PRINTCLIENT           =      0318h;

       WM_HANDHELDFIRST         =      0358h;
       WM_HANDHELDLAST          =      035Fh;

       WM_AFXFIRST              =      0360h;
       WM_AFXLAST               =      037Fh;

       WM_PENWINFIRST           =      0380h;
       WM_PENWINLAST            =      038Fh;

       WM_APP                   =      8000h;

(* NOTE: All Message Numbers below 0x0400 are RESERVED.
 *
 * Private Window Messages Start Here:
 *)
       WM_USER                  =      0400h;

(*  wParam for WM_SIZING message  *)

CONST WMSZ_LEFT        = 1;
      WMSZ_RIGHT       = 2;
      WMSZ_TOP         = 3;
      WMSZ_TOPLEFT     = 4;
      WMSZ_TOPRIGHT    = 5;
      WMSZ_BOTTOM      = 6;
      WMSZ_BOTTOMLEFT  = 7;
      WMSZ_BOTTOMRIGHT = 8;

CONST ST_BEGINSWP = 0;
      ST_ENDSWP   = 1;

(* WM_NCHITTEST and MOUSEHOOKSTRUCT Mouse Position Codes *)

CONST HTERROR       = -2;
      HTTRANSPARENT = -1;
      HTNOWHERE     =  0;
      HTCLIENT      =  1;
      HTCAPTION     =  2;
      HTSYSMENU     =  3;
      HTGROWBOX     =  4;
      HTSIZE        =  HTGROWBOX;
      HTMENU        =  5;
      HTHSCROLL     =  6;
      HTVSCROLL     =  7;
      HTMINBUTTON   =  8;
      HTMAXBUTTON   =  9;
      HTLEFT        = 10;
      HTRIGHT       = 11;
      HTTOP         = 12;
      HTTOPLEFT     = 13;
      HTTOPRIGHT    = 14;
      HTBOTTOM      = 15;
      HTBOTTOMLEFT  = 16;
      HTBOTTOMRIGHT = 17;
      HTBORDER      = 18;
      HTREDUCE      = HTMINBUTTON;
      HTZOOM        = HTMAXBUTTON;
      HTSIZEFIRST   = HTLEFT;
      HTSIZELAST    = HTBOTTOMRIGHT;
      HTOBJECT      = 19;
      HTCLOSE       = 20;
      HTHELP        = 21;

(*
 * SendMessageTimeout values
 *)

TYPE  SMTO_ENUM = (SMTO__BLOCK,        (* 0 *)
                   SMTO__ABORTIFHUNG); (* 1 *)
      SMTO_SET = SET OF SMTO_ENUM;

CONST SMTO_NORMAL      = SMTO_SET {};                   (* 0x0000 *)
      SMTO_BLOCK       = SMTO_SET {SMTO__BLOCK};        (* 0x0001 *)
      SMTO_ABORTIFHUNG = SMTO_SET {SMTO__ABORTIFHUNG};  (* 0x0002 *)

(* WM_MOUSEACTIVATE Return Codes *)

CONST MA_ACTIVATE         = 1;
      MA_ACTIVATEANDEAT   = 2;
      MA_NOACTIVATE       = 3;
      MA_NOACTIVATEANDEAT = 4;

(* WM_SETICON / WM_GETICON Type Codes *)

CONST ICON_SMALL = 0;
      ICON_BIG   = 1;

PROCEDURE RegisterWindowMessageA (String : ARRAY OF CHAR) : UINT;
PROCEDURE RegisterWindowMessageW (String : ARRAY OF WCHAR) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegisterWindowMessage = RegisterWindowMessageW;
<* ELSE *>
      CONST RegisterWindowMessage = RegisterWindowMessageA;
<* END *>

(* WM_SIZE message wParam values *)

CONST SIZE_RESTORED   = 0;
      SIZE_MINIMIZED  = 1;
      SIZE_MAXIMIZED  = 2;
      SIZE_MAXSHOW    = 3;
      SIZE_MAXHIDE    = 4;

(* Obsolete constant names *)

      SIZENORMAL      = SIZE_RESTORED;
      SIZEICONIC      = SIZE_MINIMIZED;
      SIZEFULLSCREEN  = SIZE_MAXIMIZED;
      SIZEZOOMSHOW    = SIZE_MAXSHOW;
      SIZEZOOMHIDE    = SIZE_MAXHIDE;

(* Constants for SetWindowPos and WM_WINDOWPOSCHANGING structure *)

TYPE SWP_ENUM = (SWP__NOSIZE,          (* 0 *)
                 SWP__NOMOVE,          (* 1 *)
                 SWP__NOZORDER,        (* 2 *)
                 SWP__NOREDRAW,        (* 3 *)
                 SWP__NOACTIVATE,      (* 4 *)
                 SWP__FRAMECHANGED,    (* 5 *)
                 SWP__SHOWWINDOW,      (* 6 *)
                 SWP__HIDEWINDOW,      (* 7 *)
                 SWP__NOCOPYBITS,      (* 8 *)
                 SWP__NOOWNERZORDER,   (* 9 *)
                 SWP__NOSENDCHANGING,  (*10 *)
                 SWP__11, SWP__12,
                 SWP__DEFERERASE,      (*13 *)
                 SWP__ASYNCWINDOWPOS); (*14 *)

       SWP_SET = SET OF SWP_ENUM;

CONST  SWP_NOSIZE          = SWP_SET {SWP__NOSIZE};        (* 0x0001 *)
       SWP_NOMOVE          = SWP_SET {SWP__NOMOVE};        (* 0x0002 *)
       SWP_NOZORDER        = SWP_SET {SWP__NOZORDER};      (* 0x0004 *)
       SWP_NOREDRAW        = SWP_SET {SWP__NOREDRAW};      (* 0x0008 *)
       SWP_NOACTIVATE      = SWP_SET {SWP__NOACTIVATE};    (* 0x0010 *)
       SWP_FRAMECHANGED    = SWP_SET {SWP__FRAMECHANGED};  (* 0x0020 *)
                        (* The frame changed: send WM_NCCALCSIZE *)
       SWP_SHOWWINDOW      = SWP_SET {SWP__SHOWWINDOW};    (* 0x0040 *)
       SWP_HIDEWINDOW      = SWP_SET {SWP__HIDEWINDOW};    (* 0x0080 *)
       SWP_NOCOPYBITS      = SWP_SET {SWP__NOCOPYBITS};    (* 0x0100 *)
       SWP_NOOWNERZORDER   = SWP_SET {SWP__NOOWNERZORDER}; (* 0x0200 *)
                        (* Don't do owner Z ordering *)
       SWP_NOSENDCHANGING  = SWP_SET {SWP__NOSENDCHANGING}; (* 0x0400 *)
       SWP_DEFERERASE      = SWP_SET {SWP__DEFERERASE};     (* 0x2000 *)
       SWP_ASYNCWINDOWPOS  = SWP_SET {SWP__ASYNCWINDOWPOS}; (* 0x4000 *)

       SWP_DRAWFRAME       = SWP_FRAMECHANGED;
       SWP_NOREPOSITION    = SWP_NOOWNERZORDER;

(* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam *)

TYPE WINDOWPOS = RECORD
                        hwnd : HWND;
                        hwndInsertAfter : HWND;
                        x, y, cx, cy : INTEGER;
                        flags : SWP_SET;
                 END;
    PWINDOWPOS = POINTER TO WINDOWPOS;

(* WM_NCCALCSIZE parameter structure *)

TYPE NCCALCSIZE_PARAMS = RECORD
                                rgrc  : ARRAY [0..2] OF RECT;
                                lppos : PWINDOWPOS;
                         END;
    PNCCALCSIZE_PARAMS = POINTER TO NCCALCSIZE_PARAMS;

(* WM_NCCALCSIZE "window valid rect" return values *)

CONST  WVR_ALIGNTOP        = 0010h;
       WVR_ALIGNLEFT       = 0020h;
       WVR_ALIGNBOTTOM     = 0040h;
       WVR_ALIGNRIGHT      = 0080h;
       WVR_HREDRAW         = 0100h;
       WVR_VREDRAW         = 0200h;
       WVR_REDRAW          = (WVR_HREDRAW + WVR_VREDRAW);
       WVR_VALIDRECTS      = 0400h;

(* Key State Masks for Mouse Messages *)

TYPE MK_ENUM = (MK__LBUTTON,  (* 0 *)
                MK__RBUTTON,  (* 1 *)
                MK__SHIFT,    (* 2 *)
                MK__CONTROL,  (* 3 *)
                MK__MBUTTON); (* 4 *)
     MK_SET = SET OF MK_ENUM;

CONST  MK_LBUTTON  = MK_SET {MK__LBUTTON}; (* 0x0001 *)
       MK_RBUTTON  = MK_SET {MK__RBUTTON}; (* 0x0002 *)
       MK_SHIFT    = MK_SET {MK__SHIFT};   (* 0x0004 *)
       MK_CONTROL  = MK_SET {MK__CONTROL}; (* 0x0008 *)
       MK_MBUTTON  = MK_SET {MK__MBUTTON}; (* 0x0010 *)

TYPE TME_ENUM = [0..31];
CONST TME__HOVER  = 0;
      TME__LEAVE  = 1;
      TME__QUERY  = 30;
      TME__CANCEL = 31;

TYPE  TME_SET = SET OF TME_ENUM;

CONST TME_HOVER  = TME_SET {TME__HOVER};  (* 0x00000001 *)
      TME_LEAVE  = TME_SET {TME__LEAVE};  (* 0x00000002 *)
      TME_QUERY  = TME_SET {TME__QUERY};  (* 0x40000000 *)
      TME_CANCEL = TME_SET {TME__CANCEL}; (* 0x80000000 *)

CONST HOVER_DEFAULT = 0FFFFFFFFh;

TYPE TRACKMOUSEEVENT = RECORD
                              cbSize : DWORD;
                              dwFlags : TME_SET;
                              hwndTrack : HWND;
                              dwHoverTime : DWORD;
                       END;
    PTRACKMOUSEEVENT = POINTER TO TRACKMOUSEEVENT;

PROCEDURE TrackMouseEvent (VAR EventTrack : TRACKMOUSEEVENT);

(* Window Styles *)

TYPE WS_ENUM =  (WS__0,  WS__1,  WS__2,  WS__3,  WS__4,  WS__5,  WS__6,  WS__7,
                 WS__8,  WS__9,  WS__10, WS__11, WS__12, WS__13, WS__14, WS__15,
                 WS__16, WS__17, WS__18, WS__19, WS__20, WS__21, WS__22, WS__23,
                 WS__24, WS__25, WS__26, WS__27, WS__28, WS__29, WS__30, WS__31);

     WS_SET = SET OF WS_ENUM; (* 32-bit value with bit 0 LSB *)

(* Basic window Styles *)

CONST WS_OVERLAPPED     = WS_SET {  };                (* 0x00000000L *)
      WS_POPUP          = WS_SET {WS__31};            (* 0x80000000L *)
      WS_CHILD          = WS_SET {WS__30};            (* 0x40000000L *)
      WS_MINIMIZE       = WS_SET {WS__29};            (* 0x20000000L *)
      WS_VISIBLE        = WS_SET {WS__28};            (* 0x10000000L *)
      WS_DISABLED       = WS_SET {WS__27};            (* 0x08000000L *)
      WS_CLIPSIBLINGS   = WS_SET {WS__26};            (* 0x04000000L *)
      WS_CLIPCHILDREN   = WS_SET {WS__25};            (* 0x02000000L *)
      WS_MAXIMIZE       = WS_SET {WS__24};            (* 0x01000000L *)
      WS_BORDER         = WS_SET {WS__23};            (* 0x00800000L *)
      WS_DLGFRAME       = WS_SET {WS__22};            (* 0x00400000L *)
      WS_CAPTION        = WS_BORDER + WS_DLGFRAME;    (* 0x00C00000L *)
      WS_VSCROLL        = WS_SET {WS__21};            (* 0x00200000L *)
      WS_HSCROLL        = WS_SET {WS__20};            (* 0x00100000L *)
      WS_SYSMENU        = WS_SET {WS__19};            (* 0x00080000L *)
      WS_THICKFRAME     = WS_SET {WS__18};            (* 0x00040000L *)
      WS_GROUP          = WS_SET {WS__17};            (* 0x00020000L *)
      WS_TABSTOP        = WS_SET {WS__16};            (* 0x00010000L *)

      WS_MINIMIZEBOX    = WS_SET {WS__17};            (* 0x00020000L *)
      WS_MAXIMIZEBOX    = WS_SET {WS__16};            (* 0x00010000L *)

      WS_TILED          = WS_OVERLAPPED;
      WS_ICONIC         = WS_MINIMIZE;
      WS_SIZEBOX        = WS_THICKFRAME;

(* Common Window Styles *)

CONST WS_OVERLAPPEDWINDOW = WS_OVERLAPPED  +
                            WS_CAPTION     +
                            WS_SYSMENU     +
                            WS_THICKFRAME  +
                            WS_MINIMIZEBOX +
                            WS_MAXIMIZEBOX;

      WS_TILEDWINDOW    = WS_OVERLAPPEDWINDOW;

      WS_POPUPWINDOW      = WS_POPUP   +
                            WS_BORDER  +
                            WS_SYSMENU;

      WS_CHILDWINDOW      = WS_CHILD;

(* Extended window styles *)

TYPE WS_EX_ENUM =  (WS_EX__DLGMODALFRAME,   (* 0 *)
                    WS_EX__1,
                    WS_EX__NOPARENTNOTIFY,  (* 2 *)
                    WS_EX__TOPMOST,         (* 3 *)
                    WS_EX__ACCEPTFILES,     (* 4 *)
                    WS_EX__TRANSPARENT,     (* 5 *)
                    WS_EX__MDICHILD,        (* 6 *)
                    WS_EX__TOOLWINDOW,      (* 7 *)
                    WS_EX__WINDOWEDGE,      (* 8 *)
                    WS_EX__CLIENTEDGE,      (* 9 *)
                    WS_EX__CONTEXTHELP,     (*10 *)
                    WS_EX__11,
                    WS_EX__RIGHT,           (* 12 *)
                    WS_EX__RTLREADING,      (* 13 *)
                    WS_EX__LEFTSCROLLBAR,   (* 14 *)
                    WS_EX__15,
                    WS_EX__CONTROLPARENT,   (* 16 *)
                    WS_EX__STATICEDGE,      (* 17 *)
                    WS_EX__APPWINDOW);      (* 18 *)

     WS_EX_SET = SET OF WS_EX_ENUM; (* assumed 32-bit set *)

CONST WS_EX_DLGMODALFRAME  = WS_EX_SET {WS_EX__DLGMODALFRAME};  (* 0x00000001L *)
      WS_EX_NOPARENTNOTIFY = WS_EX_SET {WS_EX__NOPARENTNOTIFY}; (* 0x00000004L *)
      WS_EX_TOPMOST        = WS_EX_SET {WS_EX__TOPMOST};        (* 0x00000008L *)
      WS_EX_ACCEPTFILES    = WS_EX_SET {WS_EX__ACCEPTFILES};    (* 0x00000010L *)
      WS_EX_TRANSPARENT    = WS_EX_SET {WS_EX__TRANSPARENT};    (* 0x00000020L *)
      WS_EX_MDICHILD       = WS_EX_SET {WS_EX__MDICHILD};       (* 0x00000040L *)
      WS_EX_TOOLWINDOW     = WS_EX_SET {WS_EX__TOOLWINDOW};     (* 0x00000080L *)
      WS_EX_WINDOWEDGE     = WS_EX_SET {WS_EX__WINDOWEDGE};     (* 0x00000100L *)
      WS_EX_CLIENTEDGE     = WS_EX_SET {WS_EX__CLIENTEDGE};     (* 0x00000200L *)
      WS_EX_CONTEXTHELP    = WS_EX_SET {WS_EX__CONTEXTHELP};    (* 0x00000400L *)
      WS_EX_RIGHT          = WS_EX_SET {WS_EX__RIGHT};          (* 0x00001000L *)
      WS_EX_LEFT           = WS_EX_SET {};                      (* 0x00000000L *)
      WS_EX_RTLREADING     = WS_EX_SET {WS_EX__RTLREADING};     (* 0x00002000L *)
      WS_EX_LTRREADING     = WS_EX_SET {};                      (* 0x00000000L *)
      WS_EX_LEFTSCROLLBAR  = WS_EX_SET {WS_EX__LEFTSCROLLBAR};  (* 0x00004000L *)
      WS_EX_RIGHTSCROLLBAR = WS_EX_SET {};                      (* 0x00000000L *)
      WS_EX_CONTROLPARENT  = WS_EX_SET {WS_EX__CONTROLPARENT};  (* 0x00010000L *)
      WS_EX_STATICEDGE     = WS_EX_SET {WS_EX__STATICEDGE};     (* 0x00020000L *)
      WS_EX_APPWINDOW      = WS_EX_SET {WS_EX__APPWINDOW};      (* 0x00040000L *)

      WS_EX_OVERLAPPEDWINDOW = WS_EX_WINDOWEDGE + WS_EX_CLIENTEDGE;
      WS_EX_PALETTEWINDOW    = WS_EX_WINDOWEDGE + WS_EX_TOOLWINDOW + WS_EX_TOPMOST;

(* Class types declared earlier near WNDCLASS structure *)

(* WM_PRINT flags *)

TYPE PRF_ENUM = (PRF__CHECKVISIBLE,  (* 0 *)
                 PRF__NONCLIENT,     (* 1 *)
                 PRF__CLIENT,        (* 2 *)
                 PRF__ERASEBKGND,    (* 3 *)
                 PRF__CHILDREN,      (* 4 *)
                 PRF__OWNED);        (* 5 *)
     PRF_SET = SET OF PRF_ENUM;

CONST PRF_CHECKVISIBLE = PRF_SET {PRF__CHECKVISIBLE}; (* 0x00000001L *)
      PRF_NONCLIENT    = PRF_SET {PRF__NONCLIENT};    (* 0x00000002L *)
      PRF_CLIENT       = PRF_SET {PRF__CLIENT};       (* 0x00000004L *)
      PRF_ERASEBKGND   = PRF_SET {PRF__ERASEBKGND};   (* 0x00000008L *)
      PRF_CHILDREN     = PRF_SET {PRF__CHILDREN};     (* 0x00000010L *)
      PRF_OWNED        = PRF_SET {PRF__OWNED};        (* 0x00000020L *)

(* 3D border styles *)

TYPE BDR_ENUM = (BDR__RAISEDOUTER,  (* 0 *)
                 BDR__SUNKENOUTER,  (* 1 *)
                 BDR__RAISEDINNER,  (* 2 *)
                 BDR__SUNKENINNER); (* 3 *)
      BDR_SET = SET OF BDR_ENUM;

CONST BDR_RAISEDOUTER = BDR_SET {BDR__RAISEDOUTER}; (* 0x0001 *)
      BDR_SUNKENOUTER = BDR_SET {BDR__SUNKENOUTER}; (* 0x0002 *)
      BDR_RAISEDINNER = BDR_SET {BDR__RAISEDINNER}; (* 0x0004 *)
      BDR_SUNKENINNER = BDR_SET {BDR__SUNKENINNER}; (* 0x0008 *)

      BDR_OUTER  =  BDR_SUNKENOUTER + BDR_RAISEDOUTER; (* 0x0003 *)
      BDR_INNER  =  BDR_SUNKENINNER + BDR_RAISEDINNER; (* 0x000c *)
      BDR_RAISED =  BDR_RAISEDINNER + BDR_RAISEDOUTER; (* 0x0005 *)
      BDR_SUNKEN =  BDR_SUNKENINNER + BDR_SUNKENOUTER; (* 0x000a *)

      EDGE_RAISED = BDR_RAISEDOUTER + BDR_RAISEDINNER;
      EDGE_SUNKEN = BDR_SUNKENOUTER + BDR_SUNKENINNER;
      EDGE_ETCHED = BDR_SUNKENOUTER + BDR_RAISEDINNER;
      EDGE_BUMP   = BDR_RAISEDOUTER + BDR_SUNKENINNER;

(* Border flags *)

TYPE BF_ENUM = (BF__LEFT,       (* 0 *)
                BF__TOP,        (* 1 *)
                BF__RIGHT,      (* 2 *)
                BF__BOTTOM,     (* 3 *)
                BF__DIAGONAL,   (* 4 *)
                BF__5, BF__6,
                BF__7, BF__8,
                BF__9, BF__10,
                BF__MIDDLE,     (* 11 *)
                BF__SOFT,       (* 12 *)
                BF__ADJUST,     (* 13 *)
                BF__FLAT,       (* 14 *)
                BF__MONO);      (* 15 *)

     BF_SET = SET OF BF_ENUM;

CONST BF_LEFT   = BF_SET {BF__LEFT};       (* 0x0001 *)
      BF_TOP    = BF_SET {BF__TOP};        (* 0x0002 *)
      BF_RIGHT  = BF_SET {BF__RIGHT};      (* 0x0004 *)
      BF_BOTTOM = BF_SET {BF__BOTTOM};     (* 0x0008 *)

      BF_TOPLEFT     = BF_TOP + BF_LEFT;
      BF_TOPRIGHT    = BF_TOP + BF_RIGHT;
      BF_BOTTOMLEFT  = BF_BOTTOM + BF_LEFT;
      BF_BOTTOMRIGHT = BF_BOTTOM + BF_RIGHT;
      BF_RECT        = BF_LEFT + BF_TOP + BF_RIGHT + BF_BOTTOM;

      BF_DIAGONAL    = BF_SET {BF__DIAGONAL}; (* 0x0010 *)

(* For diagonal lines, the BF_RECT flags specify the end point of the
   vector bounded by the rectangle parameter.
*)

CONST  BF_DIAGONAL_ENDTOPRIGHT    = BF_DIAGONAL + BF_TOP    + BF_RIGHT;
       BF_DIAGONAL_ENDTOPLEFT     = BF_DIAGONAL + BF_TOP    + BF_LEFT;
       BF_DIAGONAL_ENDBOTTOMLEFT  = BF_DIAGONAL + BF_BOTTOM + BF_LEFT;
       BF_DIAGONAL_ENDBOTTOMRIGHT = BF_DIAGONAL + BF_BOTTOM + BF_RIGHT;

CONST BF_MIDDLE = BF_SET {BF__MIDDLE};  (* 0x0800  - Fill in the middle *)
      BF_SOFT   = BF_SET {BF__SOFT};    (* 0x1000  - For softer buttons *)
      BF_ADJUST = BF_SET {BF__ADJUST};  (* 0x2000  - Calculate the space left over *)
      BF_FLAT   = BF_SET {BF__FLAT};    (* 0x4000  - For flat rather than 3D borders *)
      BF_MONO   = BF_SET {BF__MONO};    (* 0x8000  - For monochrome borders *)

<* IF BACKEND # "C" THEN *>
PROCEDURE DrawEdge (hdc : HDC; qrc : RECT; (* NIL *)
                    edge : BDR_SET;
                    grfFlags : BF_SET) : BOOL;
<* ELSE *>
PROCEDURE DrawEdge (hdc : HDC; qrc : PRECT; (* NIL *)
                    edge : BDR_SET;
                    grfFlags : BF_SET) : BOOL;
<* END *>


(* flags for DrawFrameControl *)

TYPE DFC_ENUM = (DFC_0,
                 DFC_CAPTION, (* 1 *)
                 DFC_MENU,    (* 2 *)
                 DFC_SCROLL,  (* 3 *)
                 DFC_BUTTON); (* 4 *)

TYPE DFCS_ENUM = (DFCS__0, DFCS__1,
                  DFCS__2, DFCS__3,
                  DFCS__4, DFCS__5,
                  DFCS__6, DFCS__7,
                  DFCS__INACTIVE,        (*  8 *)
                  DFCS__PUSHED,          (*  9 *)
                  DFCS__CHECKED,         (* 10 *)
                  DFCS__11, DFCS__12,
                  DFCS__ADJUSTRECT,      (* 13 *)
                  DFCS__FLAT,            (* 14 *)
                  DFCS__MONO);           (* 15 *)
     DFCS_SET = SET OF DFCS_ENUM;

CONST DFCS_CAPTIONCLOSE        = DFCS_SET {};                 (* 0x0000 *)
      DFCS_CAPTIONMIN          = DFCS_SET {DFCS__0};          (* 0x0001 *)
      DFCS_CAPTIONMAX          = DFCS_SET {DFCS__1};          (* 0x0002 *)
      DFCS_CAPTIONRESTORE      = DFCS_SET {DFCS__0, DFCS__1}; (* 0x0003 *)
      DFCS_CAPTIONHELP         = DFCS_SET {DFCS__2};          (* 0x0004 *)

      DFCS_MENUARROW           = DFCS_SET {};                 (* 0x0000 *)
      DFCS_MENUCHECK           = DFCS_SET {DFCS__0};          (* 0x0001 *)
      DFCS_MENUBULLET          = DFCS_SET {DFCS__1};          (* 0x0002 *)
      DFCS_MENUARROWRIGHT      = DFCS_SET {DFCS__2};          (* 0x0004 *)

      DFCS_SCROLLUP            = DFCS_SET {};                 (* 0x0000 *)
      DFCS_SCROLLDOWN          = DFCS_SET {DFCS__0};          (* 0x0001 *)
      DFCS_SCROLLLEFT          = DFCS_SET {DFCS__1};          (* 0x0002 *)
      DFCS_SCROLLRIGHT         = DFCS_SET {DFCS__0, DFCS__1}; (* 0x0003 *)
      DFCS_SCROLLCOMBOBOX      = DFCS_SET {DFCS__0, DFCS__2}; (* 0x0005 *)
      DFCS_SCROLLSIZEGRIP      = DFCS_SET {DFCS__3};          (* 0x0008 *)
      DFCS_SCROLLSIZEGRIPRIGHT = DFCS_SET {DFCS__4};          (* 0x0010 *)

      DFCS_BUTTONCHECK         = DFCS_SET {};                 (* 0x0000 *)
      DFCS_BUTTONRADIOIMAGE    = DFCS_SET {DFCS__0};          (* 0x0001 *)
      DFCS_BUTTONRADIOMASK     = DFCS_SET {DFCS__1};          (* 0x0002 *)
      DFCS_BUTTONRADIO         = DFCS_SET {DFCS__2};          (* 0x0004 *)
      DFCS_BUTTON3STATE        = DFCS_SET {DFCS__3};          (* 0x0008 *)
      DFCS_BUTTONPUSH          = DFCS_SET {DFCS__4};          (* 0x0010 *)

      DFCS_INACTIVE            = DFCS_SET {DFCS__INACTIVE};   (* 0x0100 *)
      DFCS_PUSHED              = DFCS_SET {DFCS__PUSHED};     (* 0x0200 *)
      DFCS_CHECKED             = DFCS_SET {DFCS__CHECKED};    (* 0x0400 *)
      DFCS_ADJUSTRECT          = DFCS_SET {DFCS__ADJUSTRECT}; (* 0x2000 *)
      DFCS_FLAT                = DFCS_SET {DFCS__FLAT};       (* 0x4000 *)
      DFCS_MONO                = DFCS_SET {DFCS__MONO};       (* 0x8000 *)

<* IF BACKEND # "C" THEN *>
PROCEDURE DrawFrameControl (hdc : HDC; rect : RECT; (* IN *)
                            uType : DFC_ENUM; uState : DFCS_SET) : BOOL;
<* ELSE *>
PROCEDURE DrawFrameControl (hdc : HDC; rect : PRECT; (* IN *)
                            uType : DFC_ENUM; uState : DFCS_SET) : BOOL;
<* END *>

(* flags for DrawCaption *)

TYPE DC_ENUM = (DC__ACTIVE,    (* 0 *)
                DC__SMALLCAP,  (* 1 *)
                DC__ICON,      (* 2 *)
                DC__TEXT,      (* 3 *)
                DC__INBUTTON); (* 4 *)
     DC_SET = SET OF DC_ENUM;

CONST DC_ACTIVE   = DC_SET {DC__ACTIVE};   (* 0x0001 *)
      DC_SMALLCAP = DC_SET {DC__SMALLCAP}; (* 0x0002 *)
      DC_ICON     = DC_SET {DC__ICON};     (* 0x0004 *)
      DC_TEXT     = DC_SET {DC__TEXT};     (* 0x0008 *)
      DC_INBUTTON = DC_SET {DC__INBUTTON}; (* 0x0010 *)

<* IF BACKEND # "C" THEN *>
PROCEDURE DrawCaption (hwnd : HWND; hdc : HDC;
                       rect : RECT; (* NIL *)
                       wFlags : DC_SET) : BOOL;
<* ELSE *>
PROCEDURE DrawCaption (hwnd : HWND; hdc : HDC;
                       rect : PRECT; (* NIL *)
                       wFlags : DC_SET) : BOOL;
<* END *>


TYPE IDANI_ENUM = (IDANI_0,
                   IDANI_OPEN,     (* 1 *)
                   IDANI_CLOSE,    (* 2 *)
                   IDANI_CAPTION); (* 3 *)

<* IF BACKEND # "C" THEN *>
PROCEDURE DrawAnimatedRects (hwnd : HWND;
                             idAni : IDANI_ENUM;
                             lprcFrom : RECT; (* IN *)
                             lprcTo   : RECT  (* IN *)) : BOOL;
<* ELSE *>
PROCEDURE DrawAnimatedRects (hwnd : HWND;
                             idAni : IDANI_ENUM;
                             lprcFrom : PRECT; (* IN *)
                             lprcTo   : PRECT  (* IN *)) : BOOL;
<* END *>


TYPE CF_TYPE = UINT;

(* Predefined Clipboard Formats *)

CONST CF_TEXT           =  1;
      CF_BITMAP         =  2;
      CF_METAFILEPICT   =  3;
      CF_SYLK           =  4;
      CF_DIF            =  5;
      CF_TIFF           =  6;
      CF_OEMTEXT        =  7;
      CF_DIB            =  8;
      CF_PALETTE        =  9;
      CF_PENDATA        = 10;
      CF_RIFF           = 11;
      CF_WAVE           = 12;
      CF_UNICODETEXT    = 13;
      CF_ENHMETAFILE    = 14;
      CF_HDROP          = 15;
      CF_LOCALE         = 16;
      CF_MAX            = 17;

      CF_OWNERDISPLAY   =  0080h;
      CF_DSPTEXT        =  0081h;
      CF_DSPBITMAP      =  0082h;
      CF_DSPMETAFILEPICT=  0083h;
      CF_DSPENHMETAFILE =  008Eh;

(* "Private" formats don't get GlobalFree()'d *)

      CF_PRIVATEFIRST   =  0200h;
      CF_PRIVATELAST    =  02FFh;

(* "GDIOBJ" formats do get DeleteObject()'d *)

      CF_GDIOBJFIRST    =  0300h;
      CF_GDIOBJLAST     =  03FFh;

(* Values of the fVirt field of the Accelerator table structure *)

<* PUSH *> <* SETSIZE = "1" *>

TYPE FVIRT_ENUM = (FVIRT__FVIRTKEY,  (* 0 *)
                   FVIRT__FNOINVERT, (* 1 *)
                   FVIRT__FSHIFT,    (* 2 *)
                   FVIRT__FCONTROL,  (* 3 *)
                   FVIRT__FALT);     (* 4 *)

TYPE FVIRT_SET = SET OF FVIRT_ENUM;

CONST FVIRTKEY   =  FVIRT_SET {FVIRT__FVIRTKEY};  (* 1 *)
      FNOINVERT  =  FVIRT_SET {FVIRT__FNOINVERT}; (* 2 *)
      FSHIFT     =  FVIRT_SET {FVIRT__FSHIFT};    (* 4 *)
      FCONTROL   =  FVIRT_SET {FVIRT__FCONTROL};  (* 8 *)
      FALT       =  FVIRT_SET {FVIRT__FALT};      (* 16 *)

<* POP *>

TYPE ACCEL = RECORD
                  fVirt   : BYTE;
                  key     : WORD;
                  cmd     : WORD;
             END;

TYPE PAINTSTRUCT = RECORD
                          hdc         : HDC;
                          fErase      : BOOL;
                          rcPaint     : RECT;
                          fRestore    : BOOL;
                          fIncUpdate  : BOOL;
                          rgbReserved : ARRAY [0..31] OF BYTE;
                   END;

TYPE CREATESTRUCTA = RECORD
                            lpCreateParams : PBYTE;
                            hInstance  : HINSTANCE;
                            hMenu      : HMENU;
                            hwndParent : HWND;
                            cy, cx     : INTEGER;
                            y, x       : INTEGER;
                            style      : WS_SET;
                            lpszName   : PSTR;
                            lpszClass  : PSTR;
                            dwExStyle  : WS_EX_SET;
                     END;

     CREATESTRUCTW = RECORD
                            lpCreateParams : PBYTE;
                            hInstance  : HINSTANCE;
                            hMenu      : HMENU;
                            hwndParent : HWND;
                            cy, cx     : INTEGER;
                            y, x       : INTEGER;
                            style      : WS_SET;
                            lpszName   : PWSTR;
                            lpszClass  : PWSTR;
                            dwExStyle  : WS_EX_SET;
                     END;

<* IF DEFINED (UNICODE) THEN *>
      CREATESTRUCT  = CREATESTRUCTW;
      PCREATESTRUCT = PCREATESTRUCTW;
<* ELSE *>
      CREATESTRUCT  = CREATESTRUCTA;
      PCREATESTRUCT = PCREATESTRUCTA;
<* END *>

TYPE WPF_ENUM = (WPF__SETMINPOSITION, WPF__RESTORETOMAXINIZED);
     WPF_SET = SET OF WPF_ENUM;

CONST WPF_SETMINPOSITION     = WPF_SET {WPF__SETMINPOSITION};     (* 0x0001 *)
      WPF_RESTORETOMAXIMIZED = WPF_SET {WPF__RESTORETOMAXINIZED}; (* 0x0002 *)

TYPE WINDOWPLACEMENT = RECORD
                            length  : UINT;
                            flags   : WPF_SET;
                            showCmd : SW_ENUM;
                            ptMinPosition : POINT;
                            ptMaxPosition : POINT;
                            rcNormalPosition : RECT;
                       END;
    PWINDOWPLACEMENT= POINTER TO WINDOWPLACEMENT;

TYPE NM_CODE = UINT;
     NMHDR = RECORD
                    hwndFrom : HWND;
                    idFrom   : UINT;
                    code     : NM_CODE;  (* codes are defined in commctrl.h *)
             END;
    PNMHDR = POINTER TO NMHDR;

TYPE STYLESTRUCT = RECORD
                          styleOld : DWORD; (* both WS_SET and WS_EX_SET can be here *)
                          styleNew : DWORD;
                   END;
    PSTYLESTRUCT = POINTER TO STYLESTRUCT;

(*
 * Owner draw control types
 *)

TYPE ODT_ENUM = (ODT_0,
                 ODT_MENU,
                 ODT_LISTBOX,
                 ODT_COMBOBOX,
                 ODT_BUTTON,
                 ODT_STATIC);

(*
 * Owner draw actions
 *)

TYPE ODA_ENUM = (ODA__DRAWENTIRE, (* 0 *)
                 ODA__SELECT,     (* 1 *)
                 ODA__FOCUS);     (* 2 *)
     ODA_SET = SET OF ODA_ENUM;

CONST ODA_DRAWENTIRE = ODA_SET {ODA__DRAWENTIRE};  (* 0001h *)
      ODA_SELECT     = ODA_SET {ODA__SELECT};      (* 0002h *)
      ODA_FOCUS      = ODA_SET {ODA__FOCUS};       (* 0004h *)

(*
 * Owner draw state
 *)

TYPE ODS_ENUM = (ODS__SELECTED,      (*  0 *)
                 ODS__GRAYED,        (*  1 *)
                 ODS__DISABLED,      (*  2 *)
                 ODS__CHECKED,       (*  3 *)
                 ODS__FOCUS,         (*  4 *)
                 ODS__DEFAULT,       (*  5 *)
                 ODS__6, ODS__7,
                 ODS__8, ODS__9,
                 ODS__10,ODS__11,
                 ODS__COMBOBOXEDIT); (* 12 *)

     ODS_SET = SET OF ODS_ENUM;

CONST ODS_SELECTED     = ODS_SET {ODS__SELECTED};     (* 0x0001 *)
      ODS_GRAYED       = ODS_SET {ODS__GRAYED};       (* 0x0002 *)
      ODS_DISABLED     = ODS_SET {ODS__DISABLED};     (* 0x0004 *)
      ODS_CHECKED      = ODS_SET {ODS__CHECKED};      (* 0x0008 *)
      ODS_FOCUS        = ODS_SET {ODS__FOCUS};        (* 0x0010 *)
      ODS_DEFAULT      = ODS_SET {ODS__DEFAULT};      (* 0x0020 *)
      ODS_COMBOBOXEDIT = ODS_SET {ODS__COMBOBOXEDIT}; (* 0x1000 *)

(*
 * MEASUREITEMSTRUCT for ownerdraw
 *)

TYPE MEASUREITEMSTRUCT = RECORD
                                CtlType    : ODT_ENUM;
                                CtlID      : UINT;
                                itemID     : UINT;
                                itemWidth  : UINT;
                                itemHeight : UINT;
                                itemData   : DWORD;
                         END;

    PMEASUREITEMSTRUCT = POINTER TO MEASUREITEMSTRUCT;

(*
 * DRAWITEMSTRUCT for ownerdraw
 *)

TYPE DRAWITEMSTRUCT = RECORD
                             CtlType    : ODT_ENUM;
                             CtlID      : UINT;
                             itemID     : UINT;
                             itemAction : ODA_SET;
                             itemState  : ODS_SET;
                             hwndItem   : HWND;
                             hDC        : HDC;
                             rcItem     : RECT;
                             itemData   : DWORD;
                      END;
    PDRAWITEMSTRUCT = POINTER TO DRAWITEMSTRUCT;

(*
 * DELETEITEMSTRUCT for ownerdraw
 *)

TYPE DELETEITEMSTRUCT = RECORD
                               CtlType  : ODT_ENUM;
                               CtlID    : UINT;
                               itemID   : UINT;
                               hwndItem : HWND;
                               itemData : UINT;
                        END;
    PDELETEITEMSTRUCT = POINTER TO DELETEITEMSTRUCT;

(*
 * COMPAREITEMSTUCT for ownerdraw sorting
 *)

TYPE COMPAREITEMSTRUCT = RECORD
                                CtlType    : ODT_ENUM;
                                CtlID      : UINT;
                                hwndItem   : HWND;
                                itemID1    : UINT;
                                itemData1  : DWORD;
                                itemID2    : UINT;
                                itemData2  : DWORD;
                                dwLocaleId : DWORD;
                         END;
    PCOMPAREITEMSTRUCT = POINTER TO COMPAREITEMSTRUCT;

PROCEDURE GetMessageA (VAR msg : MSG; hWnd : HWND;
                       MsgFilterMin, MsgFilterMax : UINT) : BOOL;
PROCEDURE GetMessageW (VAR msg : MSG; hWnd : HWND;
                       MsgFilterMin, MsgFilterMax : UINT) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetMessage      = GetMessageW;
<* ELSE *>
      CONST GetMessage      = GetMessageA;
<* END *>

PROCEDURE TranslateMessage (VAR msg : MSG) : BOOL;

PROCEDURE DispatchMessageA (VAR msg : MSG) : LONG;
PROCEDURE DispatchMessageW (VAR msg : MSG) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST DispatchMessage = DispatchMessageW;
<* ELSE *>
      CONST DispatchMessage = DispatchMessageA;
<* END *>

PROCEDURE SetMessageQueue  (MessagesMax : INTEGER) : BOOL;

(* constants for parameter RemoveMsg of PeekMessage *)

TYPE PM_ENUM = (PM_NOREMOVE,    (* 0 *)
                PM_REMOVE,      (* 1 *)
                PM_NOYIELD);    (* 2 *)

PROCEDURE PeekMessageW (VAR msg : MSG; hWnd : HWND;
                        MsgFilterMin, MsgFilterMax : UINT;
                        RemoveMsg : PM_ENUM) : BOOL;
PROCEDURE PeekMessageA (VAR msg : MSG; hWnd : HWND;
                        MsgFilterMin, MsgFilterMax : UINT;
                        RemoveMsg : PM_ENUM) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST PeekMessage     = PeekMessageW;
<* ELSE *>
      CONST PeekMessage     = PeekMessageA;
<* END *>

TYPE MOD_ENUM = (MOD__ALT,     (* 0 *)
                 MOD__CONTROL, (* 1 *)
                 MOD__SHIFT,   (* 2 *)
                 MOD__WIN,     (* 3 *)
                 MOD__4, MOD__5,
                 MOD__6, MOD__7,
                 MOD__8, MOD__9,
                 MOD__IGNORE_ALL_MODIFIER, (* 10 *)
                 MOD__ON_KEYUP,            (* 11 *)
                 MOD__12, MOD__13,
                 MOD__RIGHT,               (* 14 *)
                 MOD__LEFT);               (* 15 *)

     MOD_SET = SET OF MOD_ENUM;

CONST MOD_ALT                 = MOD_SET {MOD__ALT};     (* 0x0001 *)
      MOD_CONTROL             = MOD_SET {MOD__CONTROL}; (* 0x0002 *)
      MOD_SHIFT               = MOD_SET {MOD__SHIFT};   (* 0x0004 *)
      MOD_WIN                 = MOD_SET {MOD__WIN};     (* 0x0008 *)

(* These following originally come from imm.h *)

      MOD_LEFT                = MOD_SET {MOD__LEFT};                (* 0x8000 *)
      MOD_RIGHT               = MOD_SET {MOD__RIGHT};               (* 0x4000 *)

      MOD_ON_KEYUP            = MOD_SET {MOD__ON_KEYUP};            (* 0x0800 *)
      MOD_IGNORE_ALL_MODIFIER = MOD_SET {MOD__IGNORE_ALL_MODIFIER}; (* 0x0400 *)

PROCEDURE RegisterHotKey   (hWnd        : HWND;
                            id          : INTEGER;
                            fsModifiers : MOD_SET;
                            vk          : UINT) : BOOL;

PROCEDURE UnregisterHotKey (hWnd : HWND; id : INTEGER) : BOOL;

CONST IDHOT_SNAPWINDOW  = -1;    (* SHIFT-PRINTSCRN  *)
      IDHOT_SNAPDESKTOP = -2;    (* PRINTSCRN        *)

CONST EW_RESTARTWINDOWS = 0042h;
      EW_REBOOTSYSTEM   = 0043h;
      EW_EXITANDEXECAPP = 0044h;

      ENDSESSION_LOGOFF = 80000000h;


TYPE EWX_ENUM = (EWX__SHUTDOWN,  (* 0 *)
                 EWX__REBOOT,    (* 1 *)
                 EWX__FORCE,     (* 2 *)
                 EWX__POWEROFF); (* 3 *)
     EWX_SET = SET OF EWX_ENUM;

CONST EWX_LOGOFF   = EWX_SET {};              (* 0 *)
      EWX_SHUTDOWN = EWX_SET {EWX__SHUTDOWN}; (* 1 *)
      EWX_REBOOT   = EWX_SET {EWX__REBOOT};   (* 2 *)
      EWX_FORCE    = EWX_SET {EWX__FORCE};    (* 4 *)
      EWX_POWEROFF = EWX_SET {EWX__POWEROFF}; (* 8 *)

(* implemented in RTL because it was macro *)
PROCEDURE ExitWindows (dwReserved : DWORD; Code : INTEGER) : BOOL;

PROCEDURE ExitWindowsEx (uFlags : EWX_SET;
                         dwReserved : DWORD) : BOOL;

PROCEDURE SwapMouseButton (Swap : BOOL) : BOOL;

PROCEDURE GetMessagePos  () : DWORD; (* actually coordinates pair *)
PROCEDURE GetMessageTime () : DWORD; (* actually a time *)
PROCEDURE GetMessageExtraInfo () : DWORD;
PROCEDURE SetMessageExtraInfo (lParam : LPARAM) : LPARAM;

PROCEDURE SendMessageA (hWnd : HWND; Msg : UINT;
                        wParam : WPARAM; lParam : LPARAM) : LRESULT;
PROCEDURE SendMessageW (hWnd : HWND; Msg : UINT;
                        wParam : WPARAM; lParam : LPARAM) : LRESULT;

PROCEDURE SendMessageTimeoutA (hWnd : HWND; Msg : UINT;
                               wParam : WPARAM; lParam : LPARAM;
                               fuFlags : SMTO_SET; TimeOut : UINT;
                               VAR Result : DWORD)
                                                   : LRESULT;
PROCEDURE SendMessageTimeoutW (hWnd : HWND; Msg : UINT;
                               wParam : WPARAM; lParam : LPARAM;
                               fuFlags : SMTO_SET; TimeOut : UINT;
                               VAR Result : DWORD);

PROCEDURE SendNotifyMessageA (hWnd : HWND; Msg : UINT;
                              wParam : WPARAM; lParam : LPARAM) : BOOL;
PROCEDURE SendNotifyMessageW (hWnd : HWND; Msg : UINT;
                              wParam : WPARAM; lParam : LPARAM) : BOOL;

PROCEDURE SendMessageCallbackA (hWnd : HWND; Msg : UINT;
                                wParam : WPARAM; lParam : LPARAM;
                                ResultCallBack : SENDASYNCPROC;
                                Data : DWORD)
                                              : BOOL;
PROCEDURE SendMessageCallbackW (hWnd : HWND; Msg : UINT;
                                wParam : WPARAM; lParam : LPARAM;
                                ResultCallBack : SENDASYNCPROC;
                                Data : DWORD)
                                              : BOOL;


<* IF DEFINED (UNICODE) THEN *>
      CONST SendMessage         = SendMessageW;
            SendMessageTimeOut  = SendMessageTimeoutW;
            SendNotifyMessage   = SendNotifyMessageW;
            SendMessageCallback = SendMessageCallbackW;
<* ELSE *>
      CONST SendMessage         = SendMessageA;
            SendMessageTimeOut  = SendMessageTimeoutA;
            SendNotifyMessage   = SendNotifyMessageA;
            SendMessageCallback = SendMessageCallbackA;
<* END *>

(* Broadcast Special Message Recipient list *)

TYPE BSM_ENUM = (BSM__VXDS,               (* 0 *)
                 BSM__NETDRIVER,          (* 1 *)
                 BSM__INSTALLABLEDRIVERS, (* 2 *)
                 BSM__APPLICATIONS,       (* 3 *)
                 BSM__ALLDESKTOPS);       (* 4 *)
     BSM_SET = SET OF BSM_ENUM;
    PBSM_SET = POINTER TO BSM_SET;

CONST BSM_ALLCOMPONENTS      = BSM_SET {};                        (* 0x00000000 *)
      BSM_VXDS               = BSM_SET {BSM__VXDS};               (* 0x00000001 *)
      BSM_NETDRIVER          = BSM_SET {BSM__NETDRIVER};          (* 0x00000002 *)
      BSM_INSTALLABLEDRIVERS = BSM_SET {BSM__INSTALLABLEDRIVERS}; (* 0x00000004 *)
      BSM_APPLICATIONS       = BSM_SET {BSM__APPLICATIONS};       (* 0x00000008 *)
      BSM_ALLDESKTOPS        = BSM_SET {BSM__ALLDESKTOPS};        (* 0x00000010 *)

(* Broadcast Special Message Flags *)

TYPE BSF_ENUM = (BSF__QUERY,               (* 0 *)
                 BSF__IGNORECURRENTTASK,   (* 1 *)
                 BSF__FLUSHDISK,           (* 2 *)
                 BSF__NOHANG,              (* 3 *)
                 BSF__POSTMESSAGE,         (* 4 *)
                 BSF__FORCEIFHUNG,         (* 5 *)
                 BSF__NOTIMEOUTIFNOTHUNG); (* 6 *)
     BSF_SET = SET OF BSF_ENUM;

CONST BSF_QUERY              = BSF_SET {BSF__QUERY};             (* 0x00000001 *)
      BSF_IGNORECURRENTTASK  = BSF_SET {BSF__IGNORECURRENTTASK}; (* 0x00000002 *)
      BSF_FLUSHDISK          = BSF_SET {BSF__FLUSHDISK};         (* 0x00000004 *)
      BSF_NOHANG             = BSF_SET {BSF__NOHANG};            (* 0x00000008 *)
      BSF_POSTMESSAGE        = BSF_SET {BSF__POSTMESSAGE};       (* 0x00000010 *)
      BSF_FORCEIFHUNG        = BSF_SET {BSF__FORCEIFHUNG};       (* 0x00000020 *)
      BSF_NOTIMEOUTIFNOTHUNG = BSF_SET {BSF__NOTIMEOUTIFNOTHUNG};(* 0x00000040 *)

PROCEDURE BroadcastSystemMessage (dwFlags        : BSF_SET;
                                  lpdwRecipients : PBSM_SET;
                                  uiMessage      : UINT;
                                  wParam         : WPARAM;
                                  lParam         : LPARAM) : LONG;

TYPE BROADCASTSYSMSG = RECORD
                              uiMessage : UINT;
                              wParam : WPARAM;
                              lParam : LPARAM;
                       END;

    PBROADCASTSYSMSG = POINTER TO BROADCASTSYSMSG;

CONST DBWF_LPARAMPOINTER   = 8000h;
CONST BROADCAST_QUERY_DENY = 424D5144h; (* Return this value to deny a query *)

PROCEDURE PostMessageA (hWnd : HWND; Msg : UINT;
                        wParam : WPARAM; lParam : LPARAM) : BOOL;
PROCEDURE PostMessageW (hWnd : HWND; Msg : UINT;
                        wParam : WPARAM; lParam : LPARAM) : BOOL;

PROCEDURE PostThreadMessageA (Thread : DWORD; Msg : UINT;
                              wParam : WPARAM; lParam : LPARAM) : BOOL;
PROCEDURE PostThreadMessageW (Thread : DWORD; Msg : UINT;
                              wParam : WPARAM; lParam : LPARAM) : BOOL;
<* IF DEFINED (UNICODE) THEN *>
      CONST PostMessage       = PostMessageW;
            PostThreadMessage = PostThreadMessageW;
<* ELSE *>
      CONST PostMessage       = PostMessageA;
            PostThreadMessage = PostThreadMessageA;
<* END *>

(*
 * Special HWND value for use with PostMessage() and SendMessage()
 *)

CONST HWND_BROADCAST = SYSTEM.CAST (HWND, 0ffffh);

PROCEDURE AttachThreadInput (idAttach : DWORD;
                             idAttachTo : DWORD; fAttach : BOOL) : BOOL;

PROCEDURE ReplyMessage (lResult : LRESULT) : BOOL;
PROCEDURE WaitMessage  () : BOOL;
PROCEDURE WaitForInputIdle (hProcess : HANDLE; Milliseconds : DWORD) : DWORD;

PROCEDURE DefWindowProcA (hWnd : HWND; Msg : UINT;
                          wParam : WPARAM; lParam : LPARAM) : LRESULT;
PROCEDURE DefWindowProcW (hWnd : HWND; Msg : UINT;
                          wParam : WPARAM; lParam : LPARAM) : LRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST DefWindowProc   = DefWindowProcW;
<* ELSE *>
      CONST DefWindowProc   = DefWindowProcA;
<* END *>

PROCEDURE PostQuitMessage (ExitCode : INTEGER);

PROCEDURE CallWindowProcA (PrevWindowFunc : WNDPROC;
                           hWnd : HWND;
                           Msg : UINT;
                           wParam : WPARAM;
                           lParam : LPARAM) : LRESULT;
PROCEDURE CallWindowProcW (PrevWindowFunc : WNDPROC;
                           hWnd : HWND;
                           Msg : UINT;
                           wParam : WPARAM;
                           lParam : LPARAM) : LRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST CallWindowProc  = CallWindowProcW;
<* ELSE *>
      CONST CallWindowProc  = CallWindowProcA;
<* END *>

PROCEDURE InSendMessage () : BOOL;

PROCEDURE GetDoubleClickTime () : UINT;
PROCEDURE SetDoubleClickTime (t : UINT) : BOOL;

PROCEDURE RegisterClassA (VAR WndClass : WNDCLASSA) : ATOM;
PROCEDURE RegisterClassW (VAR WndClass : WNDCLASSW) : ATOM;
PROCEDURE UnregisterClassA (ClassName : ATOMSTR;
                            hInstance : HINSTANCE)       : BOOL;
PROCEDURE UnregisterClassW (ClassName : ATOMWSTR;
                            hInstance : HINSTANCE)       : BOOL;

PROCEDURE GetClassInfoA (hInstance : HINSTANCE;
                         ClassName : ATOMSTR;
                         VAR WndClass : WNDCLASSA)     : BOOL;
PROCEDURE GetClassInfoW (hInstance : HINSTANCE;
                         ClassName : ATOMWSTR;
                         VAR WndClass : WNDCLASSW)     : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegisterClass = RegisterClassW;
            UnregisterClass = UnregisterClassW;
            GetClassInfo = GetClassInfoW;
<* ELSE *>
      CONST RegisterClass = RegisterClassA;
            UnregisterClass = UnregisterClassA;
            GetClassInfo = GetClassInfoA;
<* END *>

PROCEDURE RegisterClassExA (VAR WndClass : WNDCLASSEXA) : ATOM;
PROCEDURE RegisterClassExW (VAR WndClass : WNDCLASSEXW) : ATOM;

PROCEDURE GetClassInfoExA (hInstance : HINSTANCE;
                         ClassName : ATOMSTR;
                         VAR WndClass : WNDCLASSEXA)     : BOOL;
PROCEDURE GetClassInfoExW (hInstance : HINSTANCE;
                         ClassName : ATOMWSTR;
                         VAR WndClass : WNDCLASSEXW)     : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegisterClassEx = RegisterClassExW;
            GetClassInfoEx = GetClassInfoW;
<* ELSE *>
      CONST RegisterClassEx = RegisterClassExA;
            GetClassInfoEx = GetClassInfoExA;
<* END *>

CONST  CW_USEDEFAULT = MIN(INTEGER); (* to be used as X and Y *)

(*
 * Special value for CreateWindow, et al.
 *)

CONST HWND_DESKTOP = NIL;

(* CreateWindowA and CreateWindowW were macroes, now in RTL *)

PROCEDURE CreateWindowA (ClassName  : ATOMSTR;
                         WindowName : PCSTR;
                         Style : WS_SET;
                         X, Y, Width, Height : INTEGER;
                         hWndParent : HWND;
                         hNenu : HMENU;
                         hInstance : HINSTANCE;
                         Param : PBYTE
                        )
                           : HWND;

PROCEDURE CreateWindowW (ClassName  : ATOMWSTR;
                         WindowName : PCWSTR;
                         Style : WS_SET;
                         X, Y, Width, Height : INTEGER;
                         hWndParent : HWND;
                         hNenu : HMENU;
                         hInstance : HINSTANCE;
                         Param : PBYTE
                        )
                           : HWND;
<* IF DEFINED (UNICODE) THEN *>
      CONST CreateWindow = CreateWindowW;
<* ELSE *>
      CONST CreateWindow = CreateWindowA;
<* END *>

PROCEDURE CreateWindowExA (ExStyle : WS_EX_SET;
                           ClassName  : ATOMSTR;
                           WindowName : PCSTR;
                           Style : WS_SET;
                           X, Y, Width, Height : INTEGER;
                           hWndParent : HWND;
                           hNenu : HMENU;
                           hInstance : HINSTANCE;
                           Param : PBYTE
                          )
                           : HWND;

PROCEDURE CreateWindowExW (ExStyle : WS_EX_SET;
                           ClassName  : ATOMWSTR;
                           WindowName : PCWSTR;
                           Style : WS_SET;
                           X, Y, Width, Height : INTEGER;
                           hWndParent : HWND;
                           hNenu : HMENU;
                           hInstance : HINSTANCE;
                           Param : PBYTE
                          )
                           : HWND;
<* IF DEFINED (UNICODE) THEN *>
      CONST CreateWindowEx = CreateWindowExW;
<* ELSE *>
      CONST CreateWindowEx = CreateWindowExA;
<* END *>

PROCEDURE IsWindow        (hWnd  : HWND)                    : BOOL;
PROCEDURE IsMenu          (hMenu : HMENU)                   : BOOL;
PROCEDURE IsChild         (hWndParent, hWnd : HWND)         : BOOL;
PROCEDURE DestroyWindow   (hWnd : HWND)                     : BOOL;
PROCEDURE ShowWindow      (hWnd : HWND; CmdShow : SW_ENUM)  : BOOL;
PROCEDURE ShowWindowAsync (hWnd : HWND; CmdShow : SW_ENUM)  : BOOL;
PROCEDURE FlashWindow     (hWnd : HWND; Invert : BOOL)      : BOOL;
PROCEDURE ShowOwnedPopups (hWnd : HWND; fShow  : BOOL)      : BOOL;
PROCEDURE OpenIcon        (hWnd : HWND)                     : BOOL;
PROCEDURE CloseWindow     (hWnd : HWND)                     : BOOL;
PROCEDURE MoveWindow      (hWnd : HWND;
                           X, Y, Width, Height : INTEGER;
                           Repaint : BOOL)                  : BOOL;

PROCEDURE SetWindowPos (hWnd : HWND; hWndInsertAfter : HWND;
                        X, Y, cx, cy : INTEGER;
                        Flags : SWP_SET) : BOOL;

PROCEDURE GetWindowPlacement (hWnd : HWND; VAR wndpl : WINDOWPLACEMENT) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE SetWindowPlacement (hWnd : HWND; wndpl : WINDOWPLACEMENT (*!*) ) : BOOL;
<* ELSE *>
PROCEDURE SetWindowPlacement (hWnd : HWND; wndpl : PWINDOWPLACEMENT (*!*) ) : BOOL;
<* END *>

PROCEDURE BeginDeferWindowPos (NumWindows : INTEGER) : HDWP;
PROCEDURE DeferWindowPos (hWinPosInfo : HDWP;
                          hWnd : HWND;
                          hWndInsertAfter : HWND;
                          x, y, cx, cy : INTEGER;
                          Flags : SWP_SET) : HDWP;

PROCEDURE EndDeferWindowPos (hWinPosInfo : HDWP) : BOOL;

PROCEDURE IsWindowVisible (hWnd : HWND) : BOOL;
PROCEDURE IsIconic (hWnd : HWND) : BOOL;
PROCEDURE AnyPopup () : BOOL;
PROCEDURE BringWindowToTop (hWnd : HWND) : BOOL;
PROCEDURE IsZoomed (hWnd : HWND) : BOOL;

(* SetWindowPos flags defined earlier near WINDOWPOS structure *)

(* Special values for HWND *)

CONST HWND_TOP       = SYSTEM.CAST (HWND, VAL (LONG,  0));
      HWND_BOTTOM    = SYSTEM.CAST (HWND, VAL (LONG,  1));
      HWND_TOPMOST   = SYSTEM.CAST (HWND, VAL (LONG, -1));
      HWND_NOTOPMOST = SYSTEM.CAST (HWND, VAL (LONG, -2));

<* PUSH *> <* ALIGNMENT = "2" *>

(*
 * WARNING:
 * The following structures must NOT be DWORD padded because they are
 * followed by strings, etc that do not have to be DWORD aligned.
 *)

(*
 * original NT 32 bit dialog template:
 *)

TYPE DLGTEMPLATE = RECORD
                        style : WS_SET;
                        dwExtendedStyle : WS_EX_SET;
                        cdit : USHORT;
                        x, y, cx, cy : SHORT;
                   END;
    PDLGTEMPLATE = POINTER TO DLGTEMPLATE;

(* Dialog item template (dit) *)

TYPE DLGITEMTEMPLATE = RECORD
                            style : WS_SET;
                            ExtendedStyle : WS_EX_SET;
                            x, y, cx, cy : SHORT;
                            id : WORD;
                       END;

<* POP *> (* Resume normal (8 byte) alignment *)

PROCEDURE CreateDialogParamA (hInstance : HINSTANCE;
                              TemplateName : RESOURCESTRA;
                              Parent : HWND;
                              lpDialogFunc : DLGPROC;
                              InitParam : LPARAM) : HWND;

PROCEDURE CreateDialogParamW (hInstance : HINSTANCE;
                              TemplateName : RESOURCESTRW;
                              Parent : HWND;
                              lpDialogFunc : DLGPROC;
                              InitParam : LPARAM) : HWND;

(* following two procedures are implemented in RTL *)

PROCEDURE CreateDialogA (hInstance : HINSTANCE;
                         TemplateName : RESOURCESTRA;
                         Parent : HWND;
                         lpDialogFunc : DLGPROC) : HWND;

PROCEDURE CreateDialogW (hInstance : HINSTANCE;
                         TemplateName : RESOURCESTRW;
                         Parent : HWND;
                         lpDialogFunc : DLGPROC) : HWND;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateDialogParam    = CreateDialogParamW;
            CreateDialog         = CreateDialogW;
<* ELSE *>
      CONST CreateDialogParam    = CreateDialogParamA;
            CreateDialog         = CreateDialogA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateDialogIndirectParamA (hInstance : HINSTANCE;
                                      Template : DLGTEMPLATE; (*!*)
                                      Parent : HWND;
                                      DialogFunc : DLGPROC;
                                      InitParam : LPARAM) : HWND;
<* ELSE *>
PROCEDURE CreateDialogIndirectParamA (hInstance : HINSTANCE;
                                      Template : PDLGTEMPLATE; (*!*)
                                      Parent : HWND;
                                      DialogFunc : DLGPROC;
                                      InitParam : LPARAM) : HWND;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateDialogIndirectParamW (hInstance : HINSTANCE;
                                      Template : DLGTEMPLATE; (*!*)
                                      Parent : HWND;
                                      DialogFunc : DLGPROC;
                                      InitParam : LPARAM) : HWND;
<* ELSE *>
PROCEDURE CreateDialogIndirectParamW (hInstance : HINSTANCE;
                                      Template : PDLGTEMPLATE; (*!*)
                                      Parent : HWND;
                                      DialogFunc : DLGPROC;
                                      InitParam : LPARAM) : HWND;
<* END *>

(* following two procedures are implemented in RTL *)

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateDialogIndirectA (hInstance : HINSTANCE;
                                 Template : DLGTEMPLATE; (*!*)
                                 Parent : HWND;
                                 DialogFunc : DLGPROC) : HWND;
<* ELSE *>
PROCEDURE CreateDialogIndirectA (hInstance : HINSTANCE;
                                 Template : PDLGTEMPLATE; (*!*)
                                 Parent : HWND;
                                 DialogFunc : DLGPROC) : HWND;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateDialogIndirectW (hInstance : HINSTANCE;
                                 Template : DLGTEMPLATE; (*!*)
                                 Parent : HWND;
                                 DialogFunc : DLGPROC) : HWND;
<* ELSE *>
PROCEDURE CreateDialogIndirectW (hInstance : HINSTANCE;
                                 Template : PDLGTEMPLATE; (*!*)
                                 Parent : HWND;
                                 DialogFunc : DLGPROC) : HWND;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateDialogIndirectParam = CreateDialogIndirectParamW;
            CreateDialogIndirect      = CreateDialogIndirectW;
<* ELSE *>
      CONST CreateDialogIndirectParam = CreateDialogIndirectParamA;
            CreateDialogIndirect      = CreateDialogIndirectA;
<* END *>

PROCEDURE DialogBoxParamA (hInstance : HINSTANCE;
                           TemplateName : RESOURCESTRA;
                           Parent : HWND;
                           lpDialogFunc : DLGPROC;
                           InitParam : LPARAM) : INTEGER;
PROCEDURE DialogBoxParamW (hInstance : HINSTANCE;
                           TemplateName : RESOURCESTRW;
                           Parent : HWND;
                           lpDialogFunc : DLGPROC;
                           InitParam : LPARAM) : INTEGER;

(* following two procedures are implemented in RTL *)

PROCEDURE DialogBoxA (hInstance : HINSTANCE;
                      TemplateName : RESOURCESTRA;
                      Parent : HWND;
                      lpDialogFunc : DLGPROC) : INTEGER;
PROCEDURE DialogBoxW (hInstance : HINSTANCE;
                      TemplateName : RESOURCESTRW;
                      Parent : HWND;
                      lpDialogFunc : DLGPROC) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST DialogBoxParam = DialogBoxParamW;
            DialogBox      = DialogBoxW;
<* ELSE *>
      CONST DialogBoxParam = DialogBoxParamA;
            DialogBox      = DialogBoxA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE DialogBoxIndirectParamA (hInstance : HINSTANCE;
                                   Template : DLGTEMPLATE; (*!*)
                                   Parent : HWND;
                                   DialogFunc : DLGPROC;
                                   InitParam : LPARAM) : INTEGER;
<* ELSE *>
PROCEDURE DialogBoxIndirectParamA (hInstance : HINSTANCE;
                                   Template : PDLGTEMPLATE; (*!*)
                                   Parent : HWND;
                                   DialogFunc : DLGPROC;
                                   InitParam : LPARAM) : INTEGER;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE DialogBoxIndirectParamW (hInstance : HINSTANCE;
                                   Template : DLGTEMPLATE; (*!*)
                                   Parent : HWND;
                                   DialogFunc : DLGPROC;
                                   InitParam : LPARAM) : INTEGER;
<* ELSE *>
PROCEDURE DialogBoxIndirectParamW (hInstance : HINSTANCE;
                                   Template : PDLGTEMPLATE; (*!*)
                                   Parent : HWND;
                                   DialogFunc : DLGPROC;
                                   InitParam : LPARAM) : INTEGER;
<* END *>

(* following two procedures are implemented in RTL *)

<* IF BACKEND # "C" THEN *>
PROCEDURE DialogBoxIndirectA (hInstance : HINSTANCE;
                              Template : DLGTEMPLATE; (*!*)
                              Parent : HWND;
                              DialogFunc : DLGPROC) : INTEGER;
<* ELSE *>
PROCEDURE DialogBoxIndirectA (hInstance : HINSTANCE;
                              Template : PDLGTEMPLATE; (*!*)
                              Parent : HWND;
                              DialogFunc : DLGPROC) : INTEGER;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE DialogBoxIndirectW (hInstance : HINSTANCE;
                              Template : DLGTEMPLATE; (*!*)
                              Parent : HWND;
                              DialogFunc : DLGPROC) : INTEGER;
<* ELSE *>
PROCEDURE DialogBoxIndirectW (hInstance : HINSTANCE;
                              Template : PDLGTEMPLATE; (*!*)
                              Parent : HWND;
                              DialogFunc : DLGPROC) : INTEGER;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST DialogBoxIndirectParam = DialogBoxIndirectParamW;
            DialogBoxIndirect      = DialogBoxIndirectW;
<* ELSE *>
      CONST DialogBoxIndirectParam = DialogBoxIndirectParamA;
            DialogBoxIndirect      = DialogBoxIndirectA;
<* END *>

PROCEDURE EndDialog (hDlg : HWND; Result : INTEGER) : BOOL;
PROCEDURE GetDlgItem (hDlg : HWND; IDDlgItem : INTEGER) : HWND;
PROCEDURE SetDlgItemInt (hDlg : HWND; IDDlgItem : INTEGER;
                         Value : UINT; Signed : BOOL) : BOOL;
PROCEDURE GetDlgItemInt (hDlg : HWND; IDDlgItem : INTEGER;
                         VAR Translated : BOOL; Signed : BOOL) : UINT;
PROCEDURE SetDlgItemTextA (hDlg : HWND; IDDlgItem : INTEGER;
                           String : ARRAY OF CHAR) : BOOL;
PROCEDURE SetDlgItemTextW (hDlg : HWND; IDDlgItem : INTEGER;
                           String : ARRAY OF WCHAR) : BOOL;

PROCEDURE GetDlgItemTextA (hDlg : HWND; IDDlgItem : INTEGER;
                           VAR String : ARRAY OF CHAR;
                           MaxCount : INTEGER) : BOOL;
PROCEDURE GetDlgItemTextW (hDlg : HWND; IDDlgItem : INTEGER;
                           VAR String : ARRAY OF WCHAR;
                           MaxCount : INTEGER) : BOOL;
<* IF DEFINED (UNICODE) THEN *>
      CONST SetDlgItemText = SetDlgItemTextW;
            GetDlgItemText = GetDlgItemTextW;
<* ELSE *>
      CONST SetDlgItemText = SetDlgItemTextA;
            GetDlgItemText = GetDlgItemTextA;
<* END *>

PROCEDURE CheckDlgButton (hDlg : HWND; IDButton : INTEGER; Check : UINT) : BOOL;
PROCEDURE CheckRadioButton (hDlg : HWND;
                            IDFirstButton : INTEGER;
                            IDLastButton  : INTEGER;
                            IDCheckButton : INTEGER) : BOOL;

PROCEDURE IsDlgButtonChecked (hDlg : HWND; IDButton : INTEGER) : UINT;
PROCEDURE SendDlgItemMessageA (hDlg : HWND; IDDlgItem : INTEGER;
                               Msg : UINT; wParam : WPARAM;
                               lParam : LPARAM) : LONG;
PROCEDURE SendDlgItemMessageW (hDlg : HWND; IDDlgItem : INTEGER;
                               Msg : UINT; wParam : WPARAM;
                               lParam : LPARAM) : LONG;
<* IF DEFINED (UNICODE) THEN *>
      CONST SendDlgItemMessage = SendDlgItemMessageW;
<* ELSE *>
      CONST SendDlgItemMessage = SendDlgItemMessageA;
<* END *>

PROCEDURE GetNextDlgGroupItem (hDlg : HWND; hCtl : HWND; Previous : BOOL) : HWND;
PROCEDURE GetNextDlgTabItem   (hDlg : HWND; hCtl : HWND; Previous : BOOL) : HWND;
PROCEDURE GetDlgCtrlID (hWnd : HWND) : INTEGER;
PROCEDURE GetDialogBaseUnits () : LONG;

PROCEDURE DefDlgProcA (hDlg : HWND; Msg : UINT;
                       wParam : WPARAM; lParam : LPARAM) : LRESULT;
PROCEDURE DefDlgProcW (hDlg : HWND; Msg : UINT;
                       wParam : WPARAM; lParam : LPARAM) : LRESULT;
<* IF DEFINED (UNICODE) THEN *>
      CONST DefDlgProc = DefDlgProcW;
<* ELSE *>
      CONST DefDlgProc = DefDlgProcA;
<* END *>

(* Window extra bytes needed for private dialog classes. *)

CONST DLGWINDOWEXTRA = 30;

PROCEDURE CallMsgFilterA (VAR msg : MSG; Code : INTEGER) : BOOL;
PROCEDURE CallMsgFilterW (VAR msg : MSG; Code : INTEGER) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CallMsgFilter = CallMsgFilterW;
<* ELSE *>
      CONST CallMsgFilter = CallMsgFilterA;
<* END *>

(* Clipboard Manager Functions *)

PROCEDURE OpenClipboard (NewOwner : HWND) : BOOL;
PROCEDURE CloseClipboard () : BOOL;
PROCEDURE GetClipboardOwner () : HWND;
PROCEDURE SetClipboardViewer (NewViewer : HWND) : HWND;
PROCEDURE GetClipboardViewer () : HWND;
PROCEDURE ChangeClipboardChain (Remove, NewNext : HWND) : BOOL;

PROCEDURE SetClipboardData (Format : CF_TYPE; Mem : HANDLE) : HANDLE;
PROCEDURE GetClipboardData (Format : CF_TYPE) : HANDLE;

PROCEDURE RegisterClipboardFormatA (Format : ARRAY OF CHAR) : UINT;
PROCEDURE RegisterClipboardFormatW (Format : ARRAY OF WCHAR) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegisterClipboardFormat = RegisterClipboardFormatW;
<* ELSE *>
      CONST RegisterClipboardFormat = RegisterClipboardFormatA;
<* END *>

PROCEDURE CountClipboardFormats () : INTEGER;
PROCEDURE EnumClipboardFormats (format : CF_TYPE) : CF_TYPE;

PROCEDURE GetClipboardFormatNameA (format : CF_TYPE;
                                   VAR FormatName : ARRAY OF CHAR;
                                   MaxCount : INTEGER) : INTEGER;
PROCEDURE GetClipboardFormatNameW (format : CF_TYPE;
                                   VAR FormatName : ARRAY OF WCHAR;
                                   MaxCount : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetClipboardFormatName  = GetClipboardFormatNameW;
<* ELSE *>
      CONST GetClipboardFormatName  = GetClipboardFormatNameA;
<* END *>

PROCEDURE EmptyClipboard () : BOOL;
PROCEDURE IsClipboardFormatAvailable (format : CF_TYPE) : BOOL;
PROCEDURE GetPriorityClipboardFormat (VAR FormatPriorityList : ARRAY OF UINT;
                                      NFormats : INTEGER) : INTEGER;
PROCEDURE GetOpenClipboardWindow () : HWND;

(* Character Translation Routines *)

PROCEDURE CharToOemA     (Src : ARRAY OF CHAR;  VAR Dst : ARRAY OF CHAR) : BOOL;
PROCEDURE CharToOemW     (Src : ARRAY OF WCHAR; VAR Dst : ARRAY OF CHAR) : BOOL;
PROCEDURE OemToCharA     (Src : ARRAY OF CHAR;  VAR Dst : ARRAY OF CHAR) : BOOL;
PROCEDURE OemToCharW     (Src : ARRAY OF CHAR;  VAR Dst : ARRAY OF WCHAR): BOOL;
PROCEDURE CharToOemBuffA (Src : ARRAY OF CHAR;  VAR Dst : ARRAY OF CHAR;
                          DstLength : DWORD) : BOOL;
PROCEDURE CharToOemBuffW (Src : ARRAY OF WCHAR; VAR Dst : ARRAY OF CHAR; DstLength : DWORD) : BOOL;
PROCEDURE OemToCharBuffA (Src : ARRAY OF CHAR; Dst : ARRAY OF CHAR; DstLength : DWORD) : BOOL;
PROCEDURE OemToCharBuffW (Src : ARRAY OF CHAR; Dst : ARRAY OF WCHAR; DstLength : DWORD) : BOOL;
<* IF DEFINED (UNICODE) THEN *>
      CONST CharToOem = CharToOemW;
            OemToChar = OemToCharW;
            CharToOemBuff = CharToOemBuffW;
            OemToCharBuff = OemToCharBuffW;
<* ELSE *>
      CONST CharToOem = CharToOemA;
            OemToChar = OemToCharA;
            CharToOemBuff = CharToOemBuffA;
            OemToCharBuff = OemToCharBuffA;
<* END *>

PROCEDURE CharUpperA (VAR s : ARRAY OF CHAR)  : PSTR;
PROCEDURE CharUpperW (VAR s : ARRAY OF WCHAR) : PWSTR;
PROCEDURE CharLowerA (VAR s : ARRAY OF CHAR)  : PSTR;
PROCEDURE CharLowerW (VAR s : ARRAY OF WCHAR) : PWSTR;

(* following four procedures are declared in RTL library.
   In original winuser.h there were no those procedures.
   CharUpper and Lower were polymorphic, that is, thay could
   accept both string pointer and single CHAR. Since Modula-2 does not
   allow this, we had to create new functions *)

PROCEDURE CharUpper1A (s : CHAR)  : CHAR;
PROCEDURE CharUpper1W (s : WCHAR) : WCHAR;
PROCEDURE CharLower1A (s : CHAR)  : CHAR;
PROCEDURE CharLower1W (s : WCHAR) : WCHAR;

PROCEDURE CharUpperBuffA (VAR s : ARRAY OF CHAR;  Length : DWORD) : DWORD;
PROCEDURE CharUpperBuffW (VAR s : ARRAY OF WCHAR; Length : DWORD) : DWORD;
PROCEDURE CharLowerBuffA (VAR s : ARRAY OF CHAR;  Length : DWORD) : DWORD;
PROCEDURE CharLowerBuffW (VAR s : ARRAY OF WCHAR; Length : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST CharUpper  = CharUpperW;
            CharUpper1 = CharUpper1W;
            CharLower  = CharLowerW;
            CharLower1 = CharLower1W;
            CharUpperBuff = CharUpperBuffW;
            CharLowerBuff = CharLowerBuffW;
<* ELSE *>
      CONST CharUpper  = CharUpperA;
            CharUpper1 = CharUpper1A;
            CharLower  = CharLowerA;
            CharLower1 = CharLower1A;
            CharUpperBuff = CharUpperBuffA;
            CharLowerBuff = CharLowerBuffA;
<* END *>

PROCEDURE CharNextA (cur : PSTR) : PSTR;
PROCEDURE CharNextW (cur : PWSTR) : PWSTR;
PROCEDURE CharPrevA (start, cur : PSTR) : PSTR;
PROCEDURE CharPrevW (start, cur : PWSTR) : PWSTR;
<* IF DEFINED (UNICODE) THEN *>
      CONST CharPrev = CharPrevW;
<* ELSE *>
      CONST CharPrev = CharPrevA;
<* END *>


PROCEDURE CharNextExA (CodePage : WORD;
                       lpCurrentChar : PCSTR;
                       dwFlags : DWORD) : PSTR;

PROCEDURE CharPrevExA (CodePage : WORD;
                       lpStart : PCSTR;
                       lpCurrentChar : PCSTR;
                       dwFlags : DWORD) : PSTR;

CONST AnsiToOem     = CharToOemA;
      OemToAnsi     = OemToCharA;
      AnsiToOemBuff = CharToOemBuffA;
      OemToAnsiBuff = OemToCharBuffA;
      AnsiUpper     = CharUpperA;
      AnsiUpperBuff = CharUpperBuffA;
      AnsiLower     = CharLowerA;
      AnsiLowerBuff = CharLowerBuffA;
      AnsiNext      = CharNextA;
      AnsiPrev      = CharPrevA;

PROCEDURE IsCharAlphaA (ch :  CHAR) : BOOL;
PROCEDURE IsCharAlphaW (ch : WCHAR) : BOOL;
PROCEDURE IsCharAlphaNumericA (ch : CHAR) : BOOL;
PROCEDURE IsCharAlphaNumericW (ch : WCHAR) : BOOL;
PROCEDURE IsCharUpperA (ch : CHAR) : BOOL;
PROCEDURE IsCharUpperW (ch : CHAR) : BOOL;
PROCEDURE IsCharLowerA (ch : CHAR) : BOOL;
PROCEDURE IsCharLowerW (ch : CHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST IsCharAlpha        = IsCharAlphaW;
            IsCharAlphaNumeric = IsCharAlphaNumericW;
            IsCharUpper        = IsCharUpperW;
            IsCharLower        = IsCharLowerW;
<* ELSE *>
      CONST IsCharAlpha        = IsCharAlphaA;
            IsCharAlphaNumeric = IsCharAlphaNumericA;
            IsCharUpper        = IsCharUpperA;
            IsCharLower        = IsCharLowerA;
<* END *>

PROCEDURE SetFocus (hWnd : HWND) : HWND;
PROCEDURE GetActiveWindow ()     : HWND;
PROCEDURE GetFocus ()            : HWND;
PROCEDURE GetKBCodePage () : UINT;
PROCEDURE GetKeyState (VirtKey : INTEGER) : SHORT;
PROCEDURE GetAsyncKeyState(Key : INTEGER) : SHORT;

TYPE KEYBOARDSTATE = ARRAY [0..255] OF BYTE;

PROCEDURE GetKeyboardState (VAR KeyState : KEYBOARDSTATE) : BOOL;
PROCEDURE SetKeyboardState (KeyState : KEYBOARDSTATE) : BOOL;

PROCEDURE GetKeyNameTextA (lParam : LPARAM; VAR String : ARRAY OF CHAR;
                           size : INTEGER) : INTEGER;
PROCEDURE GetKeyNameTextW (lParam : LPARAM; VAR String : ARRAY OF WCHAR;
                           size : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetKeyNameText = GetKeyNameTextW;
<* ELSE *>
      CONST GetKeyNameText = GetKeyNameTextA;
<* END *>

PROCEDURE GetKeyboardType (TypeFlag : INTEGER) : INTEGER;
PROCEDURE ToAscii (VirtKey, ScanCode : UINT;
                   KeyState : KEYBOARDSTATE;
                   Buff : PWORD; Flags : UINT) : INTEGER;
PROCEDURE ToAsciiEx (VirtKey, ScanCode : UINT;
                     KeyState : KEYBOARDSTATE;
                     Buff : PWORD; Flags : UINT; hkl : HKL) : INTEGER;

PROCEDURE ToUnicode (VirtKey, ScanCode : UINT;
                     KeyState : KEYBOARDSTATE;
                     VAR Buff : ARRAY OF WCHAR;
                     BufSize : INTEGER; Flags : UINT) : INTEGER;

PROCEDURE OemKeyScan (OemChar : WORD) : DWORD;

PROCEDURE VkKeyScanA (ch : CHAR) : SHORT;
PROCEDURE VkKeyScanW (ch : WCHAR) : SHORT;

<* IF DEFINED (UNICODE) THEN *>
      CONST VkKeyScan = VkKeyScanW;
<* ELSE *>
      CONST VkKeyScan = VkKeyScanA;
<* END *>

PROCEDURE VkKeyScanExA (ch : CHAR;  hkl : HKL) : SHORT;
PROCEDURE VkKeyScanExW (ch : WCHAR; hkl : HKL) : SHORT;

<* IF DEFINED (UNICODE) THEN *>
      CONST VkKeyScanEx = VkKeyScanExW;
<* ELSE *>
      CONST VkKeyScanEx = VkKeyScanExA;
<* END *>


TYPE KEYEVENTF_ENUM = (KEYEVENTF__EXTENDEDKEY, (* 0 *)
                       KEYEVENTF__KEYUP);      (* 1 *)
     KEYEVENTF_SET = SET OF KEYEVENTF_ENUM;

CONST KEYEVENTF_EXTENDEDKEY = KEYEVENTF_SET {KEYEVENTF__EXTENDEDKEY}; (* 1 *)
      KEYEVENTF_KEYUP       = KEYEVENTF_SET {KEYEVENTF__KEYUP};       (* 2 *)


PROCEDURE keybd_event (Vk, Scan : BYTE;
                       Flags : KEYEVENTF_SET;
                       ExtraInfo : DWORD);

TYPE MOUSEEVENTF_ENUM = (MOUSEEVENTF__MOVE,       (*  0 - mouse move         *)
                         MOUSEEVENTF__LEFTDOWN,   (*  1 - left button down   *)
                         MOUSEEVENTF__LEFTUP,     (*  2 - left button up     *)
                         MOUSEEVENTF__RIGHTDOWN,  (*  3 - right button down  *)
                         MOUSEEVENTF__RIGHTUP,    (*  4 - right button up    *)
                         MOUSEEVENTF__MIDDLEDOWN, (*  5 - middle button down *)
                         MOUSEEVENTF__MIDDLEUP,   (*  6 - middle button up   *)
                         MOUSEEVENTF__7,
                         MOUSEEVENTF__8,
                         MOUSEEVENTF__9,
                         MOUSEEVENTF__10,
                         MOUSEEVENTF__WHEEL,
                         MOUSEEVENTF__12,
                         MOUSEEVENTF__13,
                         MOUSEEVENTF__14,
                         MOUSEEVENTF__ABSOLUTE);  (* 15 - absolute move      *)

     MOUSEEVENTF_SET = SET OF MOUSEEVENTF_ENUM;

CONST MOUSEEVENTF_MOVE       = MOUSEEVENTF_SET {MOUSEEVENTF__MOVE};       (* 0x0001 *)
      MOUSEEVENTF_LEFTDOWN   = MOUSEEVENTF_SET {MOUSEEVENTF__LEFTDOWN};   (* 0x0002 *)
      MOUSEEVENTF_LEFTUP     = MOUSEEVENTF_SET {MOUSEEVENTF__LEFTUP};     (* 0x0004 *)
      MOUSEEVENTF_RIGHTDOWN  = MOUSEEVENTF_SET {MOUSEEVENTF__RIGHTDOWN};  (* 0x0008 *)
      MOUSEEVENTF_RIGHTUP    = MOUSEEVENTF_SET {MOUSEEVENTF__RIGHTUP};    (* 0x0010 *)
      MOUSEEVENTF_MIDDLEDOWN = MOUSEEVENTF_SET {MOUSEEVENTF__MIDDLEDOWN}; (* 0x0020 *)
      MOUSEEVENTF_MIDDLEUP   = MOUSEEVENTF_SET {MOUSEEVENTF__MIDDLEUP};   (* 0x0040 *)
      MOUSEEVENTF_WHEEL      = MOUSEEVENTF_SET {MOUSEEVENTF__WHEEL};      (* 0x0800 *)
      MOUSEEVENTF_ABSOLUTE   = MOUSEEVENTF_SET {MOUSEEVENTF__ABSOLUTE};   (* 0x8000 *)

PROCEDURE mouse_event (dwFlags : MOUSEEVENTF_SET;
                       dx, dy : DWORD;
                       cButtons, dwExtraInfo : DWORD);

PROCEDURE MapVirtualKeyA (Code : UINT; MapType : UINT) : UINT;
PROCEDURE MapVirtualKeyW (Code : UINT; MapType : UINT) : UINT;

PROCEDURE MapVirtualKeyExA (Code : UINT; MapType : UINT; hkl : HKL) : UINT;
PROCEDURE MapVirtualKeyExW (Code : UINT; MapType : UINT; hkl : HKL) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST MapVirtualKey   = MapVirtualKeyW;
            MapVirtualKeyEx = MapVirtualKeyExW;
<* ELSE *>
      CONST MapVirtualKey   = MapVirtualKeyA;
            MapVirtualKeyEx = MapVirtualKeyExA;
<* END *>

PROCEDURE GetInputState () : BOOL;

(*
 * Queue status flags for GetQueueStatus() and MsgWaitForMultipleObjects()
 *)

TYPE QS_ENUM = (QS__KEY,             (* 0 *)
                QS__MOUSEMOVE,       (* 1 *)
                QS__MOUSEBUTTON,     (* 2 *)
                QS__POSTMESSAGE,     (* 3 *)
                QS__TIMER,           (* 4 *)
                QS__PAINT,           (* 5 *)
                QS__SENDMESSAGE,     (* 6 *)
                QS__HOTKEY,          (* 7 *)
                QS__ALLPOSTMESSAGE); (* 8 *)

      QS_SET = SET OF QS_ENUM;

CONST QS_KEY            = QS_SET {QS__KEY};           (* 0x01 *)
      QS_MOUSEMOVE      = QS_SET {QS__MOUSEMOVE};     (* 0x02 *)
      QS_MOUSEBUTTON    = QS_SET {QS__MOUSEBUTTON};   (* 0x04 *)
      QS_POSTMESSAGE    = QS_SET {QS__POSTMESSAGE};   (* 0x08 *)
      QS_TIMER          = QS_SET {QS__TIMER};         (* 0x10 *)
      QS_PAINT          = QS_SET {QS__PAINT};         (* 0x20 *)
      QS_SENDMESSAGE    = QS_SET {QS__SENDMESSAGE};   (* 0x40 *)
      QS_HOTKEY         = QS_SET {QS__HOTKEY};        (* 0x80 *)
      QS_ALLPOSTMESSAGE = QS_SET {QS__ALLPOSTMESSAGE};(* 0x100 *)

      QS_MOUSE        = QS_MOUSEMOVE + QS_MOUSEBUTTON;

      QS_INPUT        = QS_MOUSE + QS_KEY;

      QS_ALLEVENTS    = QS_INPUT + QS_POSTMESSAGE + QS_TIMER +
                        QS_PAINT + QS_HOTKEY;

      QS_ALLINPUT     = QS_SENDMESSAGE + QS_PAINT + QS_TIMER +
                        QS_POSTMESSAGE + QS_MOUSEBUTTON + QS_MOUSEMOVE +
                        QS_HOTKEY + QS_KEY;


PROCEDURE GetQueueStatus (flags : QS_SET) : QS_SET;
PROCEDURE GetCapture () : HWND;
PROCEDURE SetCapture (hwnd : HWND) : HWND;
PROCEDURE ReleaseCapture () : BOOL;

PROCEDURE MsgWaitForMultipleObjects (Count        : DWORD;
                                     Handles      : ARRAY OF HANDLE;
                                     WaitAll      : BOOL;
                                     MilliSeconds : DWORD;
                                     WakeMask     : QS_SET) : DWORD;

TYPE MWMO_ENUM = (MWMO__WAITALL, MWMO__ALERTABLE);
     MWMO_SET = SET OF MWMO_ENUM;

CONST MWMO_WAITALL   = MWMO_SET {MWMO__WAITALL}; (* 0x0001 *)
      MWMO_ALERTABLE = MWMO_SET {MWMO__ALERTABLE}; (* 0x0002 *)

PROCEDURE MsgWaitForMultipleObjectsEx (Count        : DWORD;
                                       Handles      : ARRAY OF HANDLE;
                                       WaitAll      : BOOL;
                                       MilliSeconds : DWORD;
                                       WakeMask     : QS_SET;
                                       Flags        : MWMO_SET) : DWORD;

(*
 * Windows Functions
 *)


PROCEDURE SetTimer (hWnd : HWND; IDEvent : UINT;
                    Elapse : UINT; TimerProc : TIMERPROC) : UINT;

PROCEDURE KillTimer (hWnd : HWND; IdEvent : UINT) : BOOL;

PROCEDURE IsWindowUnicode (hWnd : HWND) : BOOL;
PROCEDURE EnableWindow (jWnd : HWND; Enable : BOOL) : BOOL;
PROCEDURE IsWindowEnabled (hWnd : HWND) : BOOL;

PROCEDURE LoadAcceleratorsA (hInstance : HINSTANCE; TableName : RESOURCESTRA) : HACCEL;
PROCEDURE LoadAcceleratorsW (hInstance : HINSTANCE; TableName : RESOURCESTRW) : HACCEL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadAccelerators = LoadAcceleratorsW;
<* ELSE *>
      CONST LoadAccelerators = LoadAcceleratorsA;
<* END *>

PROCEDURE CreateAcceleratorTableA (accel : ARRAY OF ACCEL;
                                   nEntries : INTEGER)       : HACCEL;
PROCEDURE CreateAcceleratorTableW (accel : ARRAY OF ACCEL;
                                   nEntries : INTEGER)       : HACCEL;

PROCEDURE DestroyAcceleratorTable (hAccel : HACCEL) : BOOL;

PROCEDURE CopyAcceleratorTableA (hAccelSrc : HACCEL;
                                 VAR AccelDst : ARRAY OF ACCEL;
                                 AccelEntries : INTEGER) : INTEGER;
PROCEDURE CopyAcceleratorTableW (hAccelSrc : HACCEL;
                                 VAR AccelDst : ARRAY OF ACCEL;
                                 AccelEntries : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateAcceleratorTable = CreateAcceleratorTableW;
            CopyAcceleratorTable = CopyAcceleratorTableW;
<* ELSE *>
      CONST CreateAcceleratorTable = CreateAcceleratorTableA;
            CopyAcceleratorTable = CopyAcceleratorTableA;
<* END *>

PROCEDURE TranslateAcceleratorA (hWnd : HWND; hAccTable : HACCEL;
                                 VAR msg : MSG)                   : BOOL;
PROCEDURE TranslateAcceleratorW (hWnd : HWND; hAccTable : HACCEL;
                                 VAR msg : MSG)                   : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST TranslateAccelerator = TranslateAcceleratorW;
<* ELSE *>
      CONST TranslateAccelerator = TranslateAcceleratorA;
<* END *>

(*
 * GetSystemMetrics() codes
 *)

TYPE SM_ENUM = (SM_CXSCREEN,          (*  0 *)
                SM_CYSCREEN,          (*  1 *)
                SM_CXVSCROLL,         (*  2 *)
                SM_CYHSCROLL,         (*  3 *)
                SM_CYCAPTION,         (*  4 *)
                SM_CXBORDER,          (*  5 *)
                SM_CYBORDER,          (*  6 *)
                SM_CXDLGFRAME,        (*  7 *)
                SM_CYDLGFRAME,        (*  8 *)
                SM_CYVTHUMB,          (*  9 *)
                SM_CXHTHUMB,          (* 10 *)
                SM_CXICON,            (* 11 *)
                SM_CYICON,            (* 12 *)
                SM_CXCURSOR,          (* 13 *)
                SM_CYCURSOR,          (* 14 *)
                SM_CYMENU,            (* 15 *)
                SM_CXFULLSCREEN,      (* 16 *)
                SM_CYFULLSCREEN,      (* 17 *)
                SM_CYKANJIWINDOW,     (* 18 *)
                SM_MOUSEPRESENT,      (* 19 *)
                SM_CYVSCROLL,         (* 20 *)
                SM_CXHSCROLL,         (* 21 *)
                SM_DEBUG,             (* 22 *)
                SM_SWAPBUTTON,        (* 23 *)
                SM_RESERVED1,         (* 24 *)
                SM_RESERVED2,         (* 25 *)
                SM_RESERVED3,         (* 26 *)
                SM_RESERVED4,         (* 27 *)
                SM_CXMIN,             (* 28 *)
                SM_CYMIN,             (* 29 *)
                SM_CXSIZE,            (* 30 *)
                SM_CYSIZE,            (* 31 *)
                SM_CXFRAME,           (* 32 *)
                SM_CYFRAME,           (* 33 *)
                SM_CXMINTRACK,        (* 34 *)
                SM_CYMINTRACK,        (* 35 *)
                SM_CXDOUBLECLK,       (* 36 *)
                SM_CYDOUBLECLK,       (* 37 *)
                SM_CXICONSPACING,     (* 38 *)
                SM_CYICONSPACING,     (* 39 *)
                SM_MENUDROPALIGNMENT, (* 40 *)
                SM_PENWINDOWS,        (* 41 *)
                SM_DBCSENABLED,       (* 42 *)
                SM_CMOUSEBUTTONS,     (* 43 *)
                SM_SECURE,            (* 44 *)
                SM_CXEDGE,            (* 45 *)
                SM_CYEDGE,            (* 46 *)
                SM_CXMINSPACING,      (* 47 *)
                SM_CYMINSPACING,      (* 48 *)
                SM_CXSMICON,          (* 49 *)
                SM_CYSMICON,          (* 50 *)
                SM_CYSMCAPTION,       (* 51 *)
                SM_CXSMSIZE,          (* 52 *)
                SM_CYSMSIZE,          (* 53 *)
                SM_CXMENUSIZE,        (* 54 *)
                SM_CYMENUSIZE,        (* 55 *)
                SM_ARRANGE,           (* 56 *)
                SM_CXMINIMIZED,       (* 57 *)
                SM_CYMINIMIZED,       (* 58 *)
                SM_CXMAXTRACK,        (* 59 *)
                SM_CYMAXTRACK,        (* 60 *)
                SM_CXMAXIMIZED,       (* 61 *)
                SM_CYMAXIMIZED,       (* 62 *)
                SM_NETWORK,           (* 63 *)
                SM_64,
                SM_65,
                SM_66,
                SM_CLEANBOOT,         (* 67 *)
                SM_CXDRAG,            (* 68 *)
                SM_CYDRAG,            (* 69 *)
                SM_SHOWSOUNDS,        (* 70 *)
                SM_CXMENUCHECK,       (* 71 Use instead of GetMenuCheckMarkDimensions()! *)
                SM_CYMENUCHECK,       (* 72 *)
                SM_SLOWMACHINE,       (* 73 *)
                SM_MIDEASTENABLED,    (* 74 *)
                SM_MOUSEWHEELPRESENT, (* 75 *)
                SM_CMETRICS);         (* 76 *)

CONST SM_CXFIXEDFRAME = SM_CXDLGFRAME;  (* win40 name change *)
      SM_CYFIXEDFRAME = SM_CYDLGFRAME;  (* win40 name change *)
      SM_CXSIZEFRAME  = SM_CXFRAME;     (* win40 name change *)
      SM_CYSIZEFRAME  = SM_CYFRAME;     (* win40 name change *)

PROCEDURE GetSystemMetrics (Index : SM_ENUM) : INTEGER;

(* win40  -- A lot of MF_* flags have been renamed as MFT_* and MFS_* flags *)

(* Menu flags for Add/Check/EnableMenuItem *)

TYPE MF_ENUM = (MF__0, MF__1, MF__2, MF__3, MF__4, MF__5, MF__6, MF__7,
                MF__8, MF__9, MF__10, MF__11, MF__12, MF__13, MF__14, MF__15);
     MF_SET = SET OF MF_ENUM;

CONST MF_INSERT          = MF_SET {};           (* 0x00000000L *)
      MF_CHANGE          = MF_SET {MF__7};      (* 0x00000080L *)
      MF_APPEND          = MF_SET {MF__8};      (* 0x00000100L *)
      MF_DELETE          = MF_SET {MF__9};      (* 0x00000200L *)
      MF_REMOVE          = MF_SET {MF__12};     (* 0x00001000L *)

      MF_BYCOMMAND       = MF_SET {};           (* 0x00000000L *)
      MF_BYPOSITION      = MF_SET {MF__10};     (* 0x00000400L *)

      MF_SEPARATOR       = MF_SET {MF__11};     (* 0x00000800L *)

      MF_ENABLED         = MF_SET {};           (* 0x00000000L *)
      MF_GRAYED          = MF_SET {MF__0};      (* 0x00000001L *)
      MF_DISABLED        = MF_SET {MF__1};      (* 0x00000002L *)

      MF_UNCHECKED       = MF_SET {};           (* 0x00000000L *)
      MF_CHECKED         = MF_SET {MF__3};      (* 0x00000008L *)
      MF_USECHECKBITMAPS = MF_SET {MF__9};      (* 0x00000200L *)

      MF_STRING          = MF_SET {};           (* 0x00000000L *)
      MF_BITMAP          = MF_SET {MF__2};      (* 0x00000004L *)
      MF_OWNERDRAW       = MF_SET {MF__8};      (* 0x00000100L *)

      MF_POPUP           = MF_SET {MF__4};      (* 0x00000010L *)
      MF_MENUBARBREAK    = MF_SET {MF__5};      (* 0x00000020L *)
      MF_MENUBREAK       = MF_SET {MF__6};      (* 0x00000040L *)

      MF_UNHILITE        = MF_SET {};           (* 0x00000000L *)
      MF_HILITE          = MF_SET {MF__7};      (* 0x00000080L *)

      MF_DEFAULT         = MF_SET {MF__12};     (* 0x00001000L *)

      MF_SYSMENU         = MF_SET {MF__13};     (* 0x00002000L *)
      MF_HELP            = MF_SET {MF__14};     (* 0x00004000L *)

      MF_RIGHTJUSTIFY    = MF_SET {MF__14};     (* 0x00004000L *)

      MF_MOUSESELECT     = MF_SET {MF__15};     (* 0x00008000L *)

      MF_END             = MF_SET {MF__7};      (* 0x00000080L Obsolete -- only used by old RES files *)

CONST MFT_STRING         = MF_STRING;
      MFT_BITMAP         = MF_BITMAP;
      MFT_MENUBARBREAK   = MF_MENUBARBREAK;
      MFT_MENUBREAK      = MF_MENUBREAK;
      MFT_OWNERDRAW      = MF_OWNERDRAW;
      MFT_RADIOCHECK     = MF_SET {MF__9};      (* 0x00000200L *)
      MFT_SEPARATOR      = MF_SEPARATOR;
      MFT_RIGHTORDER     = MF_SET {MF__13};     (* 0x00002000L *)
      MFT_RIGHTJUSTIFY   = MF_RIGHTJUSTIFY;

(* Menu flags for Add/Check/EnableMenuItem() *)

CONST MFS_GRAYED         = MF_GRAYED + MF_DISABLED; (* 0x00000003L *)
      MFS_DISABLED       = MFS_GRAYED;
      MFS_CHECKED        = MF_CHECKED;
      MFS_HILITE         = MF_HILITE;
      MFS_ENABLED        = MF_ENABLED;
      MFS_UNCHECKED      = MF_UNCHECKED;
      MFS_UNHILITE       = MF_UNHILITE;
      MFS_DEFAULT        = MF_DEFAULT;

PROCEDURE LoadMenuA (hInstance : HINSTANCE; MenuName : RESOURCESTRA) : HMENU;
PROCEDURE LoadMenuW (hInstance : HINSTANCE; MenuName : RESOURCESTRW) : HMENU;
PROCEDURE LoadMenuIndirectA (MenuTemplate : PMENUTEMPLATEA (*!*)) : HMENU;
PROCEDURE LoadMenuIndirectW (MenuTemplate : PMENUTEMPLATEW (*!*)) : HMENU;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadMenu = LoadMenuW;
            LoadMenuIndirect = LoadMenuIndirectW;
<* ELSE *>
      CONST LoadMenu = LoadMenuA;
            LoadMenuIndirect = LoadMenuIndirectA;
<* END *>


PROCEDURE GetMenu (hWnd : HWND) : HMENU;
PROCEDURE SetMenu (hWnd : HWND; hMenu : HMENU) : BOOL;

PROCEDURE ChangeMenuA (hMenu : HMENU; cmd : UINT;
                       NewItem : PCSTR; (* NIL *)
                       cmdInsert : UINT;
                       flags : MF_SET) : BOOL;
PROCEDURE ChangeMenuW (hMenu : HMENU; cmd : UINT;
                       NewItem : PCWSTR; (* NIL *)
                       cmdInsert : UINT;
                       flags : MF_SET) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ChangeMenu = ChangeMenuW;

<* ELSE *>
      CONST ChangeMenu = ChangeMenuA;
<* END *>

PROCEDURE HiliteMenuItem (hWnd : HWND; hMenu : HMENU;
                          HiliteItem : UINT; flags : MF_SET) : BOOL;

PROCEDURE GetMenuStringA (hMenu : HMENU; IDItem : UINT;
                          VAR [NIL] String : ARRAY OF CHAR;
                          MaxCount : INTEGER;
                          flags : MF_SET) : INTEGER;
PROCEDURE GetMenuStringW (hMenu : HMENU; IDItem : UINT;
                          VAR [NIL] String : ARRAY OF WCHAR;
                          MaxCount : INTEGER;
                          flags : MF_SET) : INTEGER;
<* IF DEFINED (UNICODE) THEN *>
      CONST GetMenuString = GetMenuStringW;
<* ELSE *>
      CONST GetMenuString = GetMenuStringA;
<* END *>

PROCEDURE GetMenuState (hMenu : HMENU; Id : UINT; Flags : MF_SET) : MF_SET;
PROCEDURE DrawMenuBar (hWnd : HWND) : BOOL;
PROCEDURE GetSystemMenu (hWnd : HWND; Reset : BOOL) : HMENU;
PROCEDURE CreateMenu () : HMENU;
PROCEDURE CreatePopupMenu () : HMENU;
PROCEDURE DestroyMenu (hMenu : HMENU) : BOOL;
PROCEDURE CheckMenuItem (hMenu : HMENU; IDCheckItem : UINT;
                         Check : MF_SET) : MF_SET;
PROCEDURE EnableMenuItem (hMenu : HMENU; IDEnableItem : UINT;
                          Enable : MF_SET) : BOOL;
PROCEDURE GetSubMenu (hMenu : HMENU; Pos : INTEGER) : HMENU;
PROCEDURE GetMenuItemID (hMenu : HMENU; Pos : INTEGER) : UINT;
PROCEDURE GetMenuItemCount (hMenu : HMENU) : INTEGER;

PROCEDURE InsertMenuA (hMenu : HMENU; Position : UINT; Flags : MF_SET;
                       IDNewItem : UINT; NewItem : PCSTR (* NIL *)) : BOOL;
PROCEDURE InsertMenuW (hMenu : HMENU; Position : UINT; Flags : MF_SET;
                       IDNewItem : UINT; NewItem : PCWSTR (* NIL *)) : BOOL;

PROCEDURE AppendMenuA (hMenu : HMENU; Flags : MF_SET; IDNewItem : UINT;
                       lpNewItem : PCSTR (* NIL *)) : BOOL;
PROCEDURE AppendMenuW (hMenu : HMENU; Flags : MF_SET; IDNewItem : UINT;
                       lpNewItem : PCWSTR (* NIL *)) : BOOL;

PROCEDURE ModifyMenuA (hMenu : HMENU; Position : UINT; Flags : UINT;
                       IDNewItem : UINT; NewItem : PCSTR (* NIL*)) : BOOL;
PROCEDURE ModifyMenuW (hMenu : HMENU; Position : UINT; Flags : UINT;
                       IDNewItem : UINT; NewItem : PCWSTR (* NIL *)) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST InsertMenu = InsertMenuW;
            AppendMenu = AppendMenuW;
            ModifyMenu = ModifyMenuW;
<* ELSE *>
      CONST InsertMenu = InsertMenuA;
            AppendMenu = AppendMenuA;
            ModifyMenu = ModifyMenuA;
<* END *>

PROCEDURE RemoveMenu (hMenu : HMENU; Position : UINT; Flags : MF_SET) : BOOL;
PROCEDURE DeleteMenu (hMenu : HMENU; Position : UINT; Flags : MF_SET) : BOOL;

PROCEDURE SetMenuItemBitmaps (hMenu : HMENU; Position : UINT;
                              Flags : MF_SET;
                              BitmapUnchecked, BitmapChecked : HBITMAP) : BOOL;

PROCEDURE GetMenuCheckMarkDimensions () : DWORD;

(* Flags for TrackPopupMenu *)

TYPE TPM_ENUM = (TPM__0,            (* 0 *)
                 TPM__RIGHTBUTTON,  (* 1 *)
                 TPM__CENTERALIGN,  (* 2 *)
                 TPM__RIGHTALIGN,   (* 3 *)
                 TPM__VCENTERALIGN, (* 4 *)
                 TPM__BOTTOMALIGN,  (* 5 *)
                 TPM__VERTICAL,     (* 6 - Vert alignment matters more *)
                 TPM__NONOTIFY,     (* 7 - Don't send any notification msgs *)
                 TPM__RETURNCMD);   (* 8 *)

      TPM_SET = SET OF TPM_ENUM;

CONST TPM_LEFTBUTTON   = TPM_SET {};                  (* 0x0000 *)
      TPM_RIGHTBUTTON  = TPM_SET {TPM__RIGHTBUTTON};  (* 0x0002 *)
      TPM_LEFTALIGN    = TPM_SET {};                  (* 0x0000 *)
      TPM_CENTERALIGN  = TPM_SET {TPM__CENTERALIGN};  (* 0x0004 *)
      TPM_RIGHTALIGN   = TPM_SET {TPM__RIGHTALIGN};   (* 0x0008 *)
      TPM_TOPALIGN     = TPM_SET {};                  (* 0x0000 *)
      TPM_VCENTERALIGN = TPM_SET {TPM__VCENTERALIGN}; (* 0x0010 *)
      TPM_BOTTOMALIGN  = TPM_SET {TPM__BOTTOMALIGN};  (* 0x0020 *)
      TPM_HORIZONTAL   = TPM_SET {};                  (* 0x0000 *)
      TPM_VERTICAL     = TPM_SET {TPM__VERTICAL};     (* 0x0040 *)
      TPM_NONOTIFY     = TPM_SET {TPM__NONOTIFY};     (* 0x0080 *)
      TPM_RETURNCMD    = TPM_SET {TPM__RETURNCMD};    (* 0x0100 *)

(* Rect can be NIL *)

PROCEDURE TrackPopupMenu (hMenu : HMENU; Flags : TPM_SET;
                          x, y : INTEGER; Reserved : INTEGER;
                          hWnd : HWND; Rect : PRECT (* IN NIL *)) : BOOL;

(* return codes for WM_MENUCHAR *)

TYPE MNC_ENUM = (MNC_IGNORE,   (* 0 *)
                 MNC_CLOSE,    (* 1 *)
                 MNC_EXECUTE,  (* 2 *)
                 MNC_SELECT);  (* 3 *)

TYPE TPMPARAMS = RECORD
                        cbSize : UINT;     (* Size of structure *)
                        rcExclude : RECT;  (* Screen coordinates of rectangle to exclude when positioning *)
                 END;
    PTPMPARAMS = POINTER TO TPMPARAMS;


PROCEDURE TrackPopupMenuEx (hmenu : HMENU;
                            flags : TPM_SET;
                            x, y  : INTEGER;
                            owner : HWND;
                            ptpm  : PTPMPARAMS (* IN NIL *)) : BOOL;

TYPE MIIM_ENUM = (MIIM__STATE,      (* 0 *)
                  MIIM__ID,         (* 1 *)
                  MIIM__SUBMENU,    (* 2 *)
                  MIIM__CHECKMARKS, (* 3 *)
                  MIIM__TYPE,       (* 4 *)
                  MIIM__DATA);      (* 5 *)

     MIIM_SET = SET OF MIIM_ENUM;

CONST MIIM_STATE       = MIIM_SET {MIIM__STATE     }; (* 0x00000001 *)
      MIIM_ID          = MIIM_SET {MIIM__ID        }; (* 0x00000002 *)
      MIIM_SUBMENU     = MIIM_SET {MIIM__SUBMENU   }; (* 0x00000004 *)
      MIIM_CHECKMARKS  = MIIM_SET {MIIM__CHECKMARKS}; (* 0x00000008 *)
      MIIM_TYPE        = MIIM_SET {MIIM__TYPE      }; (* 0x00000010 *)
      MIIM_DATA        = MIIM_SET {MIIM__DATA      }; (* 0x00000020 *)


TYPE MENUITEMINFOA = RECORD
                            cbSize        : UINT;
                            fMask         : MIIM_SET;
                            fType         : MF_SET;   (* used if MIIM_TYPE *)
                            fState        : MF_SET;   (* used if MIIM_STATE *)
                            wID           : UINT;     (* used if MIIM_ID *)
                            hSubMenu      : HMENU;    (* used if MIIM_SUBMENU *)
                            hbmpChecked   : HBITMAP;  (* used if MIIM_CHECKMARKS *)
                            hbmpUnchecked : HBITMAP;  (* used if MIIM_CHECKMARKS *)
                            dwItemData    : DWORD;    (* used if MIIM_DATA *)
                            dwTypeData    : PSTR;     (* used if MIIM_TYPE *)
                            cch           : UINT;     (* used if MIIM_TYPE *)
                     END;
    PMENUITEMINFOA = POINTER TO MENUITEMINFOA;

    MENUITEMINFOW = RECORD
                            cbSize        : UINT;
                            fMask         : MIIM_SET;
                            fType         : MF_SET;   (* used if MIIM_TYPE *)
                            fState        : MF_SET;   (* used if MIIM_STATE *)
                            wID           : UINT;     (* used if MIIM_ID *)
                            hSubMenu      : HMENU;    (* used if MIIM_SUBMENU *)
                            hbmpChecked   : HBITMAP;  (* used if MIIM_CHECKMARKS *)
                            hbmpUnchecked : HBITMAP;  (* used if MIIM_CHECKMARKS *)
                            dwItemData    : DWORD;    (* used if MIIM_DATA *)
                            dwTypeData    : PWSTR;    (* used if MIIM_TYPE *)
                            cch           : UINT;     (* used if MIIM_TYPE *)
                     END;
    PMENUITEMINFOW = POINTER TO MENUITEMINFOW;

<* IF DEFINED (UNICODE) THEN *>
   TYPE  MENUITEMINFO =   MENUITEMINFOW;
        PMENUITEMINFO =  PMENUITEMINFOW;
<* ELSE *>
   TYPE  MENUITEMINFO =   MENUITEMINFOA;
        PMENUITEMINFO =  PMENUITEMINFOA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE InsertMenuItemA (hmenu      : HMENU;
                           uitem      : UINT;
                           ByPotition : BOOL;
                           info       : MENUITEMINFOA (*!*)) : BOOL;
<* ELSE *>
PROCEDURE InsertMenuItemA (hmenu      : HMENU;
                           uitem      : UINT;
                           ByPotition : BOOL;
                           info       : PMENUITEMINFOA (*!*)) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE InsertMenuItemW (hmenu      : HMENU;
                           uitem      : UINT;
                           ByPotition : BOOL;
                           info       : MENUITEMINFOW (*!*)) : BOOL;
<* ELSE *>
PROCEDURE InsertMenuItemW (hmenu      : HMENU;
                           uitem      : UINT;
                           ByPotition : BOOL;
                           info       : PMENUITEMINFOW (*!*)) : BOOL;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST InsertMenuItem = InsertMenuItemW;
<* ELSE *>
      CONST InsertMenuItem = InsertMenuItemA;
<* END *>

PROCEDURE GetMenuItemInfoA (hmenu      : HMENU;
                            uItem      : UINT;
                            ByPosition : BOOL;
                            VAR info   : MENUITEMINFOA) : BOOL;

PROCEDURE GetMenuItemInfoW (hmenu      : HMENU;
                            uItem      : UINT;
                            ByPosition : BOOL;
                            VAR info   : MENUITEMINFOW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetMenuItemInfo = GetMenuItemInfoW;
<* ELSE *>
      CONST GetMenuItemInfo = GetMenuItemInfoA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE SetMenuItemInfoA (hmenu      : HMENU;
                            uItem      : UINT;
                            ByPosition : BOOL;
                            info       : MENUITEMINFOA (*!*)) : BOOL;
<* ELSE *>
PROCEDURE SetMenuItemInfoA (hmenu      : HMENU;
                            uItem      : UINT;
                            ByPosition : BOOL;
                            info       : PMENUITEMINFOA (*!*)) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE SetMenuItemInfoW (hmenu      : HMENU;
                            uItem      : UINT;
                            ByPosition : BOOL;
                            info       : MENUITEMINFOW (*!*)) : BOOL;
<* ELSE *>
PROCEDURE SetMenuItemInfoW (hmenu      : HMENU;
                            uItem      : UINT;
                            ByPosition : BOOL;
                            info       : PMENUITEMINFOW (*!*)) : BOOL;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST SetMenuItemInfo = SetMenuItemInfoW;
<* ELSE *>
      CONST SetMenuItemInfo = SetMenuItemInfoA;
<* END *>


TYPE GMDI_ENUM = (GMDI__USEDISABLED,   (* 0 *)
                  GMDI__GOINTOPOPUPS); (* 1 *)

     GMDI_SET = SET OF GMDI_ENUM;

CONST GMDI_USEDISABLED  = GMDI_SET {GMDI__USEDISABLED};  (* 0x0001L *)
      GMDI_GOINTOPOPUPS = GMDI_SET {GMDI__GOINTOPOPUPS}; (* 0x0002L *)

PROCEDURE GetMenuDefaultItem (hMenu : HMENU; fByPos : UINT; gmdiFlags : GMDI_SET) : UINT;
PROCEDURE SetMenuDefaultItem (hMenu : HMENU; uItem  : UINT; fByPos : UINT) : BOOL;

PROCEDURE GetMenuItemRect (hWnd : HWND; hMenu : HMENU; uItem : UINT; VAR rcItem : RECT);

(* MenuItemFromPoint has parameter of structure type POINT which is passed
   by value. It had to be implemented in RTL.
*)

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlMenuItemFromPoint (hWnd : HWND; hMenu : HMENU; pt : POINT) : INTEGER;
CONST MenuItemFromPoint = rtlMenuItemFromPoint;
<* ELSE *>
PROCEDURE MenuItemFromPoint (hWnd : HWND; hMenu : HMENU; pt : POINT) : INTEGER;
<* END *>

(*
 * Drag-and-drop support
*)

TYPE DROPSTRUCT = RECORD
                         hwndSource : HWND;
                         hwndSink : HWND;
                         wFmt : DWORD;
                         dwData : DWORD;
                         ptDrop : POINT;
                         dwControlData : DWORD;
                  END;
    PDROPSTRUCT = POINTER TO DROPSTRUCT;

CONST DOF_EXECUTABLE = 8001h;
      DOF_DOCUMENT   = 8002h;
      DOF_DIRECTORY  = 8003h;
      DOF_MULTIPLE   = 8004h;
      DOF_PROGMAN    = 0001h;
      DOF_SHELLDATA  = 0002h;

      DO_DROPFILE    = 454C4946h;
      DO_PRINTFILE   = 544E5250h;

PROCEDURE DragObject (hwndSource : HWND;
                      hwndSink   : HWND;
                      Fmt        : UINT;
                      Data       : DWORD;
                      cursor     : HCURSOR) : DWORD;

(* DragDetect has parameter of structure type POINT which is passed
   by value. It had to be implemented in RTL. *)

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlDragDetect (hwnd : HWND; pt : POINT) : BOOL;
CONST DragDetect = rtlDragDetect;
<* ELSE *>
PROCEDURE DragDetect (hwnd : HWND; pt : POINT) : BOOL;
<* END *>

PROCEDURE DrawIcon (hDC : HDC; X : INTEGER; Y : INTEGER; hIcon : HICON) : BOOL;

(* DrawText Format Flags *)

TYPE DTX_ENUM = (DT__CENTER,           (* 0 *)
                 DT__RIGHT,            (* 1 *)
                 DT__VCENTER,          (* 2 *)
                 DT__BOTTOM,           (* 3 *)
                 DT__WORDBREAK,        (* 4 *)
                 DT__SINGLELINE,       (* 5 *)
                 DT__EXPANDTABS,       (* 6 *)
                 DT__TABSTOP,          (* 7 *)
                 DT__NOCLIP,           (* 8 *)
                 DT__EXTERNALLEADING,  (* 9 *)
                 DT__CALCRECT,         (*10 *)
                 DT__NOPREFIX,         (*11 *)
                 DT__INTERNAL,         (*12 *)
                 DT__EDITCONTROL,      (*13 *)
                 DT__PATH_ELLIPSIS,    (*14 *)
                 DT__END_ELLIPSIS,     (*15 *)
                 DT__MODIFYSTRING,     (*16 *)
                 DT__RTLREADING,       (*17 *)
                 DT__WORD_ELLIPSIS);   (*18 *)

      DT_SET = SET OF DTX_ENUM;

CONST DT_TOP              = DT_SET {};                    (* 0x00000000 *)
      DT_LEFT             = DT_SET {};                    (* 0x00000000 *)
      DT_CENTER           = DT_SET {DT__CENTER};          (* 0x00000001 *)
      DT_RIGHT            = DT_SET {DT__RIGHT};           (* 0x00000002 *)
      DT_VCENTER          = DT_SET {DT__VCENTER};         (* 0x00000004 *)
      DT_BOTTOM           = DT_SET {DT__BOTTOM};          (* 0x00000008 *)
      DT_WORDBREAK        = DT_SET {DT__WORDBREAK};       (* 0x00000010 *)
      DT_SINGLELINE       = DT_SET {DT__SINGLELINE};      (* 0x00000020 *)
      DT_EXPANDTABS       = DT_SET {DT__EXPANDTABS};      (* 0x00000040 *)
      DT_TABSTOP          = DT_SET {DT__TABSTOP};         (* 0x00000080 *)
      DT_NOCLIP           = DT_SET {DT__NOCLIP};          (* 0x00000100 *)
      DT_EXTERNALLEADING  = DT_SET {DT__EXTERNALLEADING}; (* 0x00000200 *)
      DT_CALCRECT         = DT_SET {DT__CALCRECT};        (* 0x00000400 *)
      DT_NOPREFIX         = DT_SET {DT__NOPREFIX};        (* 0x00000800 *)
      DT_INTERNAL         = DT_SET {DT__INTERNAL};        (* 0x00001000 *)
      DT_EDITCONTROL      = DT_SET {DT__EDITCONTROL  };   (* 0x00002000 *)
      DT_PATH_ELLIPSIS    = DT_SET {DT__PATH_ELLIPSIS};   (* 0x00004000 *)
      DT_END_ELLIPSIS     = DT_SET {DT__END_ELLIPSIS };   (* 0x00008000 *)
      DT_MODIFYSTRING     = DT_SET {DT__MODIFYSTRING };   (* 0x00010000 *)
      DT_RTLREADING       = DT_SET {DT__RTLREADING   };   (* 0x00020000 *)
      DT_WORD_ELLIPSIS    = DT_SET {DT__WORD_ELLIPSIS};   (* 0x00040000 *)

TYPE DRAWTEXTPARAMS = RECORD
                              cbSize    : UINT;
                              iTabLength : INTEGER;
                              iLeftMargin : INTEGER;
                              iRightMargin : INTEGER;
                              uiLengthDrawn : UINT;
                      END;
    PDRAWTEXTPARAMS = POINTER TO DRAWTEXTPARAMS;

(* DrawText and DrawTextEx have String declared as PSTR not ARRAY OF CHAR
   because the functions can modify the string in case DT_MODIFYSTRING
   is specified *)

PROCEDURE DrawTextA (hDC : HDC; String : PSTR; Count : INTEGER;
                     VAR Rect : RECT; Format : DT_SET) : INTEGER;

PROCEDURE DrawTextW (hDC : HDC; String : PWSTR; Count : INTEGER;
                     VAR Rect : RECT; Format : DT_SET) : INTEGER;

PROCEDURE DrawTextExA (hDC : HDC; String : PSTR; Count : INTEGER;
                       VAR Rect : RECT; Format : DT_SET;
                       VAR params : DRAWTEXTPARAMS);

PROCEDURE DrawTextExW (hDC : HDC; String : PWSTR; Count : INTEGER;
                       VAR Rect : RECT; Format : DT_SET;
                       VAR params : DRAWTEXTPARAMS);

<* IF DEFINED (UNICODE) THEN *>
      CONST DrawText   = DrawTextW;
            DrawTextEx = DrawTextExW;
<* ELSE *>
      CONST DrawText   = DrawTextA;
            DrawTextEx = DrawTextExA;
<* END *>

PROCEDURE GrayStringA (hDC : HDC; Brush : HBRUSH;
                       OutputFunc : GRAYSTRINGPROC;
                       Data : LPARAM; X, Y : INTEGER;
                       Width, Height : INTEGER) : BOOL;

PROCEDURE GrayStringW (hDC : HDC; Brush : HBRUSH;
                       OutputFunc : GRAYSTRINGPROC;
                       Data : LPARAM; X, Y : INTEGER;
                       Width, Height : INTEGER) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GrayString = GrayStringW;
<* ELSE *>
      CONST GrayString = GrayStringA;
<* END *>


(* Monolithic state-drawing routine *)

(* State type *)

TYPE DSS_ENUM = (DSS__0, DSS__1,
                 DSS__2, DSS__3,
                 DSS__UNION,       (* 4 *) (* Gray string appearance *)
                 DSS__DISABLED,    (* 5 *)
                 DSS__6,
                 DSS__MONO,        (* 7 *)
                 DSS__8, DSS__9,
                 DSS__10,DSS__11,
                 DSS__12,DSS__13,
                 DSS__14,
                 DSS__RIGHT);      (* 15 *)

     DSS_SET = SET OF DSS_ENUM;

CONST DSS_NORMAL   = DSS_SET {};                   (* 0x0000 *)
      DSS_UNION    = DSS_SET {DSS__UNION};         (* 0x0010 *)
      DSS_DISABLED = DSS_SET {DSS__DISABLED};      (* 0x0020 *)
      DSS_MONO     = DSS_SET {DSS__MONO};          (* 0x0080 *)
      DSS_RIGHT    = DSS_SET {DSS__RIGHT};         (* 0x8000 *)

(* Image type *)

CONST DST_COMPLEX     = DSS_SET {};                (* 0x0000 *)
      DST_TEXT        = DSS_SET {DSS__0};          (* 0x0001 *)
      DST_PREFIXTEXT  = DSS_SET {DSS__1};          (* 0x0002 *)
      DST_ICON        = DSS_SET {DSS__0, DSS__1};  (* 0x0003 *)
      DST_BITMAP      = DSS_SET {DSS__2};          (* 0x0004 *)


PROCEDURE DrawStateA (hDC : HDC; hBrush : HBRUSH;
                     outputFunc : DRAWSTATEPROC;
                     lData : LPARAM;
                     wData : WPARAM;
                     x, y, cx, cy : INTEGER;
                     flags : DSS_SET);

PROCEDURE DrawStateW (hDC : HDC; hBrush : HBRUSH;
                     outputFunc : DRAWSTATEPROC;
                     lData : LPARAM;
                     wData : WPARAM;
                     x, y, cx, cy : INTEGER;
                     flags : DSS_SET);


<* IF DEFINED (UNICODE) THEN *>
      CONST DrawState = DrawStateW;
<* ELSE *>
      CONST DrawState = DrawStateA;
<* END *>


PROCEDURE TabbedTextOutA (hDC : HDC; X, Y : INTEGER;
                          String : ARRAY OF CHAR;
                          Count : INTEGER;
                          TabPositions : INTEGER;
                          TabStopPositions : ARRAY OF INTEGER;
                          TabOrigin : INTEGER) : LONG;

PROCEDURE TabbedTextOutW (hDC : HDC; X, Y : INTEGER;
                          String : ARRAY OF WCHAR;
                          Count : INTEGER;
                          TabPositions : INTEGER;
                          TabStopPositions : ARRAY OF INTEGER;
                          TabOrigin : INTEGER) : LONG;

PROCEDURE GetTabbedTextExtentA (hDC : HDC; String : ARRAY OF CHAR;
                                 Count : INTEGER; TabPositions : INTEGER;
                                 TabStopPositions : ARRAY OF INTEGER) : DWORD;
PROCEDURE GetTabbedTextExtentW (hDC : HDC; String : ARRAY OF WCHAR;
                                 Count : INTEGER; TabPositions : INTEGER;
                                 TabStopPositions : ARRAY OF INTEGER) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST TabbedTextOut = TabbedTextOutW;
            GetTabbedTextExtent = GetTabbedTextExtentW;
<* ELSE *>
      CONST TabbedTextOut = TabbedTextOutA;
            GetTabbedTextExtent = GetTabbedTextExtentA;
<* END *>

PROCEDURE UpdateWindow    (hWnd : HWND) : BOOL;
PROCEDURE SetActiveWindow (hwnd : HWND) : HWND;
PROCEDURE GetForegroundWindow () : HWND;
PROCEDURE PaintDesktop (hdc : HDC) : BOOL;
PROCEDURE SetForegroundWindow (hwnd : HWND) : BOOL;
PROCEDURE WindowFromDC (hDC : HDC) : HWND;
PROCEDURE GetDC (hWnd : HWND) : HDC;

(* GetDCEx flags *)

TYPE DCX_ENUM = (DCX__WINDOW,            (* 0*)
                 DCX__CACHE,             (* 1*)
                 DCX__NORESETATTRS,      (* 2*)
                 DCX__CLIPCHILDREN,      (* 3*)
                 DCX__CLIPSIBLINGS,      (* 4*)
                 DCX__PARENTCLIP,        (* 5*)

                 DCX__EXCLUDERGN,        (* 6*)
                 DCX__INTERSECTRGN,      (* 7*)

                 DCX__EXCLUDEUPDATE,     (* 8*)
                 DCX__INTERSECTUPDATE,   (* 9*)

                 DCX__LOCKWINDOWUPDATE,  (*10*)
                 DCX__11, DCX__12, DCX__13, DCX__14, DCX__15,
                 DCX__16, DCX__17, DCX__18, DCX__19, DCX__20,
                 DCX__VALIDATE);         (*21*)
     DCX_SET = SET OF DCX_ENUM;

CONST DCX_WINDOW           = DCX_SET {DCX__WINDOW};           (* 0x00000001L *)
      DCX_CACHE            = DCX_SET {DCX__CACHE};            (* 0x00000002L *)
      DCX_NORESETATTRS     = DCX_SET {DCX__NORESETATTRS};     (* 0x00000004L *)
      DCX_CLIPCHILDREN     = DCX_SET {DCX__CLIPCHILDREN};     (* 0x00000008L *)
      DCX_CLIPSIBLINGS     = DCX_SET {DCX__CLIPSIBLINGS};     (* 0x00000010L *)
      DCX_PARENTCLIP       = DCX_SET {DCX__PARENTCLIP};       (* 0x00000020L *)

      DCX_EXCLUDERGN       = DCX_SET {DCX__EXCLUDERGN};       (* 0x00000040L *)
      DCX_INTERSECTRGN     = DCX_SET {DCX__INTERSECTRGN};     (* 0x00000080L *)

      DCX_EXCLUDEUPDATE    = DCX_SET {DCX__EXCLUDEUPDATE};    (* 0x00000100L *)
      DCX_INTERSECTUPDATE  = DCX_SET {DCX__INTERSECTUPDATE};  (* 0x00000200L *)

      DCX_LOCKWINDOWUPDATE = DCX_SET {DCX__LOCKWINDOWUPDATE}; (* 0x00000400L *)

      DCX_VALIDATE         = DCX_SET {DCX__VALIDATE};         (* 0x00200000L *)


PROCEDURE GetDCEx (hWnd : HWND; RgnClip : HRGN; flags : DCX_SET) : HDC;

PROCEDURE GetWindowDC (hWnd : HWND) : HDC;
PROCEDURE ReleaseDC (hWnd : HWND; hDC : HDC) : BOOL;

PROCEDURE BeginPaint (hWnd : HWND; VAR Paint : PAINTSTRUCT) : HDC;
PROCEDURE EndPaint   (hWnd : HWND; VAR Paint : PAINTSTRUCT) : BOOL;

PROCEDURE GetUpdateRect (hWnd : HWND; VAR [NIL] Rect : RECT; bErase : BOOL) : BOOL;

PROCEDURE GetUpdateRgn (hWnd : HWND; hRgn : HRGN; Erase : BOOL) : INTEGER;
         (* in fact, returns region flag, defined in GDI *)

PROCEDURE SetWindowRgn (hWnd : HWND; hRgn : HRGN; bRedraw : BOOL) : INTEGER;
PROCEDURE GetWindowRgn (hWnd : HWND; hRgn : HRGN) : INTEGER;

PROCEDURE ExcludeUpdateRgn (hDC : HDC; hWnd : HWND) : INTEGER;
PROCEDURE InvalidateRect (hWnd : HWND; Rect : PRECT (* IN NIL *); Erase : BOOL) : BOOL;
PROCEDURE   ValidateRect (hWnd : HWND; Rect : PRECT (* IN NIL *)) : BOOL;
PROCEDURE InvalidateRgn (hWnd : HWND; hRgn : HRGN; Erase : BOOL) : BOOL;
PROCEDURE   ValidateRgn (hWnd : HWND; hRgn : HRGN; Erase : BOOL) : BOOL;

(* RedrawWindow flags *)

TYPE RDW_ENUM = (RDW__INVALIDATE,        (* 0 *)
                 RDW__INTERNALPAINT,     (* 1 *)
                 RDW__ERASE,             (* 2 *)

                 RDW__VALIDATE,          (* 3 *)
                 RDW__NOINTERNALPAINT,   (* 4 *)
                 RDW__NOERASE,           (* 5 *)

                 RDW__NOCHILDREN,        (* 6 *)
                 RDW__ALLCHILDREN,       (* 7 *)

                 RDW__UPDATENOW,         (* 8 *)
                 RDW__ERASENOW,          (* 9 *)

                 RDW__FRAME,             (*10 *)
                 RDW__NOFRAME);          (*11 *)
     RDW_SET = SET OF RDW_ENUM;

CONST RDW_INVALIDATE      = RDW_SET {RDW__INVALIDATE};      (* 0x0001 *)
      RDW_INTERNALPAINT   = RDW_SET {RDW__INTERNALPAINT};   (* 0x0002 *)
      RDW_ERASE           = RDW_SET {RDW__ERASE};           (* 0x0004 *)

      RDW_VALIDATE        = RDW_SET {RDW__VALIDATE};        (* 0x0008 *)
      RDW_NOINTERNALPAINT = RDW_SET {RDW__NOINTERNALPAINT}; (* 0x0010 *)
      RDW_NOERASE         = RDW_SET {RDW__NOERASE};         (* 0x0020 *)

      RDW_NOCHILDREN      = RDW_SET {RDW__NOCHILDREN};      (* 0x0040 *)
      RDW_ALLCHILDREN     = RDW_SET {RDW__ALLCHILDREN};     (* 0x0080 *)

      RDW_UPDATENOW       = RDW_SET {RDW__UPDATENOW};       (* 0x0100 *)
      RDW_ERASENOW        = RDW_SET {RDW__ERASENOW};        (* 0x0200 *)

      RDW_FRAME           = RDW_SET {RDW__FRAME};           (* 0x0400 *)
      RDW_NOFRAME         = RDW_SET {RDW__NOFRAME};         (* 0x0800 *)

PROCEDURE RedrawWindow (hWnd : HWND; RectUpdate : PRECT; (* IN NIL *)
                        RgnUpdate : HRGN; flags : RDW_SET) : BOOL;


PROCEDURE LockWindowUpdate (hWndLock : HWND) : BOOL;

PROCEDURE ScrollWindow (hWnd : HWND;
                        XAmount, YAmount : INTEGER;
                        Rect, ClipRect : PRECT (* IN NIL *)) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE ScrollDC (hDC : HDC;
                    dx, dy : INTEGER;
                    Scroll : RECT;
                    Clip : PRECT; (* IN NIL *)
                    RgnUpdate : HRGN;
                    VAR [NIL] RectUpdate : RECT) : BOOL;
<* ELSE *>
PROCEDURE ScrollDC (hDC : HDC;
                    dx, dy : INTEGER;
                    Scroll : PRECT;
                    Clip : PRECT; (* IN NIL *)
                    RgnUpdate : HRGN;
                    VAR [NIL] RectUpdate : RECT) : BOOL;
<* END *>


TYPE SCRW_ENUM = (SCRW__SCROLLCHILDREN,  (* 0 *)
                  SCRW__INVALIDATE,      (* 1 *)
                  SCRW__ERASE);          (* 2 *)

     SCRW_SET = SET OF SCRW_ENUM;

     (* type is called SCRW for not mixing it with SW_ENUM that is
        ShowWindow parameter type; SW_ constants leaved as they were for
        compatibility
     *)

CONST SW_SCROLLCHILDREN = SCRW_SET {SCRW__SCROLLCHILDREN}; (* 0x0001 - Scroll children within *lprcScroll. *)
      SW_INVALIDATE     = SCRW_SET {SCRW__INVALIDATE};     (* 0x0002 - Invalidate after scrolling *)
      SW_ERASE          = SCRW_SET {SCRW__ERASE};          (* 0x0004 - If SW_INVALIDATE, don't send WM_ERASEBACKGROUND *)

PROCEDURE ScrollWindowEx (hWnd : HWND;
                          dx, dy : INTEGER;
                          Scroll, Clip : PRECT; (* IN NIL *)
                          RgnUpdate : HRGN;
                          VAR [NIL] RectUpdate : RECT;
                          flags : SCRW_SET)
                                            : INTEGER;

PROCEDURE SetScrollPos (hWnd : HWND; Bar : SB_TYPE;
                        Pos : INTEGER; Redraw : BOOL) : INTEGER;
PROCEDURE GetScrollPos   (hWnd : HWND; Bar : SB_TYPE) : INTEGER;
PROCEDURE SetScrollRange (hWnd : HWND; Bar : SB_TYPE;
                          MinPos, MaxPos : INTEGER; Redraw : BOOL) : BOOL;
PROCEDURE GetScrollRange (hWnd : HWND; Bar : SB_TYPE;
                          VAR MinPos, MaxPos : INTEGER) : BOOL;
PROCEDURE ShowScrollBar   (hWnd : HWND; Bar : SB_TYPE; Show : BOOL) : BOOL;


(*
 * EnableScrollBar() flags
 *)

TYPE ESB_ENUM = (ESB__DISABLE_LEFT,   (* 0 *)
                 ESB__DISABLE_RIGHT); (* 1 *)

     ESB_SET = SET OF ESB_ENUM;

CONST ESB_ENABLE_BOTH   = ESB_SET {};                    (* 0x0000 *)
      ESB_DISABLE_LEFT  = ESB_SET {ESB__DISABLE_LEFT};   (* 0x0001 *)
      ESB_DISABLE_RIGHT = ESB_SET {ESB__DISABLE_RIGHT};  (* 0x0002 *)
      ESB_DISABLE_BOTH  = ESB_SET {ESB__DISABLE_LEFT,
                                   ESB__DISABLE_RIGHT};  (* 0x0003 *)

      ESB_DISABLE_UP   = ESB_DISABLE_LEFT;  (* 0x0001 *)
      ESB_DISABLE_DOWN = ESB_DISABLE_RIGHT; (* 0x0002 *)

      ESB_DISABLE_LTUP = ESB_DISABLE_LEFT;
      ESB_DISABLE_RTDN = ESB_DISABLE_RIGHT;


PROCEDURE EnableScrollBar (hWnd   : HWND;
                           Bar    : SB_TYPE;
                           Arrpws : ESB_SET) : BOOL;


PROCEDURE SetPropA (hWnd : HWND; String : ATOMSTR; Data : HANDLE) : BOOL;
PROCEDURE SetPropW (hWnd : HWND; String : ATOMWSTR; Data : HANDLE) : BOOL;
PROCEDURE GetPropA (hWnd : HWND; String : ATOMSTR) : HANDLE;
PROCEDURE GetPropW (hWnd : HWND; String : ATOMWSTR) : HANDLE;
PROCEDURE RemovePropA (hWnd : HWND; String : ATOMSTR) : HANDLE;
PROCEDURE RemovePropW (hWnd : HWND; String : ATOMWSTR) : HANDLE;
PROCEDURE EnumPropExA (hWnd : HWND; EnumFunc : PROPENUMPROCEXA; lParam : LPARAM) : INTEGER;
PROCEDURE EnumPropExW (hWnd : HWND; EnumFunc : PROPENUMPROCEXW; lParam : LPARAM) : INTEGER;
PROCEDURE EnumPropsA (hWnd : HWND; EnumFunc : PROPENUMPROCA) : INTEGER;
PROCEDURE EnumPropsW (hWnd : HWND; EnumFunc : PROPENUMPROCW) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetProp = SetPropW;
            GetProp = GetPropW;
            RemoveProp = RemovePropW;
            EnumPropEx = EnumPropExW;
            EnumProps  = EnumPropsW;
<* ELSE *>
      CONST SetProp = SetPropA;
            GetProp = GetPropA;
            RemoveProp = RemovePropA;
            EnumPropEx = EnumPropExA;
            EnumProps  = EnumPropsA;
<* END *>

PROCEDURE SetWindowTextA (hWnd : HWND; String : ARRAY OF CHAR) : BOOL;
PROCEDURE SetWindowTextW (hWnd : HWND; String : ARRAY OF WCHAR) : BOOL;

PROCEDURE GetWindowTextA (hWnd : HWND;
                          VAR String : ARRAY OF CHAR;
                          MaxCount : INTEGER) : INTEGER;
PROCEDURE GetWindowTextW (hWnd : HWND;
                          VAR String : ARRAY OF WCHAR;
                          MaxCount : INTEGER) : INTEGER;

PROCEDURE GetWindowTextLengthA (hWnd : HWND) : INTEGER;
PROCEDURE GetWindowTextLengthW (hWnd : HWND) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetWindowText = SetWindowTextW;
            GetWindowText = GetWindowTextW;
            GetWindowTextLength = GetWindowTextLengthW;
<* ELSE *>
      CONST SetWindowText = SetWindowTextA;
            GetWindowText = GetWindowTextA;
            GetWindowTextLength = GetWindowTextLengthA;
<* END *>

PROCEDURE GetClientRect (hWnd : HWND; VAR Rect : RECT) : BOOL;
PROCEDURE GetWindowRect (hWnd : HWND; VAR Rect : RECT) : BOOL;
PROCEDURE AdjustWindowRect   (VAR Rect : RECT; Style : WS_SET; Menu : BOOL) : BOOL;
PROCEDURE AdjustWindowRectEx (VAR Rect : RECT; Style : WS_SET; Menu : BOOL;
                              ExStyle : WS_EX_SET) : BOOL;

TYPE HELPINFO_ENUM = (HELPINFO_0,
                      HELPINFO_WINDOW,    (* 0x0001 *)
                      HELPINFO_MENUITEM); (* 0x0002 *)

(* Structure pointed to by lParam of WM_HELP *)

TYPE HELPINFO =
     RECORD
            cbSize       : UINT;          (* Size in bytes of this struct  *)
            iContextType : HELPINFO_ENUM; (* Either HELPINFO_WINDOW or HELPINFO_MENUITEM *)
            iCtrlId      : INTEGER;       (* Control Id or a Menu item Id. *)
            hItemHandle  : HANDLE;        (* hWnd of control or hMenu.     *)
            dwContextId  : DWORD;         (* Context Id associated with this item  *)
            MousePos     : POINT;         (* Mouse Position in screen co-ordinates *)
     END;
     PHELPINFO = POINTER TO HELPINFO;

PROCEDURE SetWindowContextHelpId (hwnd  : HWND; id : DWORD) : BOOL;
PROCEDURE GetWindowContextHelpId (hwnd  : HWND) : DWORD;
PROCEDURE SetMenuContextHelpId   (hmenu : HMENU; id : DWORD) : BOOL;
PROCEDURE GetMenuContextHelpId   (hmenu : HMENU) : DWORD;

(* MessageBox Flags *)

TYPE MB_ENUM = (MB__0,  MB__1,  MB__2,  MB__3,  MB__4,  MB__5,  MB__6,  MB__7,
                MB__8,  MB__9,  MB__10, MB__11, MB__12, MB__13, MB__14, MB__15,
                MB__16, MB__17, MB__18, MB__19, MB__20, MB__21, MB__22, MB__23,
                MB__24, MB__25, MB__26, MB__27, MB__28, MB__29, MB__30, MB__31);
     MB_SET = SET OF MB_ENUM;

CONST MB_OK                  = MB_SET {};               (* 0x00000000L *)
      MB_OKCANCEL            = MB_SET {MB__0};          (* 0x00000001L *)
      MB_ABORTRETRYIGNORE    = MB_SET {MB__1};          (* 0x00000002L *)
      MB_YESNOCANCEL         = MB_SET {MB__1,MB__0};    (* 0x00000003L *)
      MB_YESNO               = MB_SET {MB__2};          (* 0x00000004L *)
      MB_RETRYCANCEL         = MB_SET {MB__2,MB__0};    (* 0x00000005L *)

      MB_ICONHAND            = MB_SET {MB__4};          (* 0x00000010L *)
      MB_ICONQUESTION        = MB_SET {MB__5};          (* 0x00000020L *)
      MB_ICONEXCLAMATION     = MB_SET {MB__4,MB__5};    (* 0x00000030L *)
      MB_ICONASTERISK        = MB_SET {MB__6};          (* 0x00000040L *)

      MB_USERICON            = MB_SET {MB__7};          (* 0x00000080L *)

      MB_ICONWARNING         = MB_ICONEXCLAMATION;
      MB_ICONERROR           = MB_ICONHAND;

      MB_ICONINFORMATION     = MB_ICONASTERISK;
      MB_ICONSTOP            = MB_ICONHAND;

      MB_DEFBUTTON1          = MB_SET {};               (* 0x00000000L *)
      MB_DEFBUTTON2          = MB_SET {MB__8};          (* 0x00000100L *)
      MB_DEFBUTTON3          = MB_SET {MB__9};          (* 0x00000200L *)
      MB_DEFBUTTON4          = MB_SET {MB__8,MB__9};    (* 0x00000300L *)

      MB_APPLMODAL           = MB_SET {};               (* 0x00000000L *)
      MB_SYSTEMMODAL         = MB_SET {MB__12};         (* 0x00001000L *)
      MB_TASKMODAL           = MB_SET {MB__13};         (* 0x00002000L *)
      MB_HELP                = MB_SET {MB__14};         (* 0x00004000L *)

      MB_NOFOCUS             = MB_SET {MB__15};         (* 0x00008000L *)
      MB_SETFOREGROUND       = MB_SET {MB__16};         (* 0x00010000L *)
      MB_DEFAULT_DESKTOP_ONLY= MB_SET {MB__17};         (* 0x00020000L *)

      MB_TOPMOST             = MB_SET {MB__18};         (* 0x00040000L *)
      MB_RIGHT               = MB_SET {MB__19};         (* 0x00080000L *)
      MB_RTLREADING          = MB_SET {MB__20};         (* 0x00100000L *)

      MB_SERVICE_NOTIFICATION= MB_SET {MB__21};         (* 0x00200000L *)
      MB_SERVICE_NOTIFICATION_NT3X = MB_SET {MB__18};   (* 0x00040000L *)

      MB_TYPEMASK            = MB_SET {MB__0..MB__3};   (* 0x0000000FL *)
      MB_ICONMASK            = MB_SET {MB__4..MB__7};   (* 0x000000F0L *)
      MB_DEFMASK             = MB_SET {MB__8..MB__11};  (* 0x00000F00L *)
      MB_MODEMASK            = MB_SET {MB__12,MB__13};  (* 0x00003000L *)
      MB_MISCMASK            = MB_SET {MB__14,MB__15};  (* 0x0000C000L *)

PROCEDURE MessageBoxA (hWnd : HWND;
                       Text : ARRAY OF CHAR;
                       Caption : PCSTR; (* NIL *)
                       Type : MB_SET) : INTEGER;
PROCEDURE MessageBoxW (hWnd : HWND;
                       Text : ARRAY OF WCHAR;
                       Caption : PCWSTR; (* NIL *)
                       Type : MB_SET) : INTEGER;

PROCEDURE MessageBoxExA (hWnd : HWND;
                         Text : ARRAY OF CHAR;
                         Caption : PCSTR; (* NIL *)
                         Type : MB_SET;
                         LanguageId : WORD) : INTEGER;
PROCEDURE MessageBoxExW (hWnd : HWND;
                         Text : ARRAY OF CHAR;
                         Caption : PCWSTR; (* NIL *)
                         Type : MB_SET;
                         LanguageId : WORD) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST  MessageBox   = MessageBoxW;
             MessageBoxEx = MessageBoxExW;
<* ELSE *>
      CONST  MessageBox   = MessageBoxA;
             MessageBoxEx = MessageBoxExA;
<* END *>

TYPE MSGBOXCALLBACK = PROCEDURE (VAR HELPINFO);

TYPE MSGBOXPARAMSA = RECORD
                            cbSize             : UINT;
                            hwndOwner          : HWND;
                            hInstance          : HINSTANCE;
                            lpszText           : PCSTR;
                            lpszCaption        : PCSTR;
                            dwStyle            : MB_SET;
                            lpszIcon           : RESOURCESTRA;
                            dwContextHelpId    : DWORD;
                            lpfnMsgBoxCallback : MSGBOXCALLBACK;
                            dwLanguageId       : DWORD;
                     END;
    PMSGBOXPARAMSA = POINTER TO MSGBOXPARAMSA;

TYPE MSGBOXPARAMSW = RECORD
                            cbSize             : UINT;
                            hwndOwner          : HWND;
                            hInstance          : HINSTANCE;
                            lpszText           : PCWSTR;
                            lpszCaption        : PCWSTR;
                            dwStyle            : MB_SET;
                            lpszIcon           : RESOURCESTRW;
                            dwContextHelpId    : DWORD;
                            lpfnMsgBoxCallback : MSGBOXCALLBACK;
                            dwLanguageId       : DWORD;
                     END;
    PMSGBOXPARAMSW = POINTER TO MSGBOXPARAMSA;

PROCEDURE MessageBoxIndirectA (VAR param : MSGBOXPARAMSA) : INTEGER;
PROCEDURE MessageBoxIndirectW (VAR param : MSGBOXPARAMSW) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      TYPE    MSGBOXPARAMS =  MSGBOXPARAMSW;
             PMSGBOXPARAMS = PMSGBOXPARAMSW;
      CONST  MessageBoxIndirect = MessageBoxIndirectW;
<* ELSE *>
      TYPE    MSGBOXPARAMS =  MSGBOXPARAMSA;
             PMSGBOXPARAMS = PMSGBOXPARAMSA;
      CONST  MessageBoxIndirect = MessageBoxIndirectA;
<* END *>


PROCEDURE MessageBeep (Type : MB_SET) : BOOL;

 (* MB_ICONASTERISK, MB_ICONEXCLAMATION, MB_ICONHAND,
    MB_ICONQUESTION, MB_OK, MB_SPEAKER allowed
 *)

CONST MB_SPEAKER = - MB_SET {};


PROCEDURE ShowCursor (Show : BOOL) : INTEGER;
PROCEDURE SetCursorPos (X, Y : INTEGER) : BOOL;
PROCEDURE SetCursor (Cursor : HCURSOR) : HCURSOR;
PROCEDURE GetCursorPos (VAR Point : POINT) : BOOL;
PROCEDURE ClipCursor (Rect : PRECT (* IN NIL *)) : BOOL;
PROCEDURE GetClipCursor (VAR Rect : RECT) : BOOL;
PROCEDURE GetCursor () : HCURSOR;

PROCEDURE CreateCaret (hWnd : HWND; Bitmap : HBITMAP;
                       Width, Height : INTEGER) : BOOL;
PROCEDURE GetCaretBlinkTime() : UINT;
PROCEDURE SetCaretBlinkTime(MSeconds : UINT) : BOOL;
PROCEDURE DestroyCaret () : BOOL;
PROCEDURE HideCaret (Hwnd : HWND) : BOOL;
PROCEDURE ShowCaret (Hwnd : HWND) : BOOL;
PROCEDURE SetCaretPos (X, Y : INTEGER) : BOOL;
PROCEDURE GetCaretPos (VAR Point : POINT) : BOOL;

PROCEDURE ClientToScreen (hWnd : HWND; VAR Point : POINT) : BOOL;
PROCEDURE ScreenToClient (hWnd : HWND; VAR Point : POINT) : BOOL;
PROCEDURE MapWindowPoints (From, To : HWND;
                           VAR Points : ARRAY OF POINT;
                           NPoints : UINT) : INTEGER;

(* These two procedures had parameter of structure type POINT which is passed
   by value. It had to be implemented in RTL.
*)

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlWindowFromPoint (pt : POINT) : HWND;
CONST WindowFromPoint = rtlWindowFromPoint;
<* ELSE *>
PROCEDURE WindowFromPoint (pt : POINT) : HWND;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlChildWindowFromPoint (Parent: HWND; pt : POINT) : HWND;
CONST ChildWindowFromPoint = rtlChildWindowFromPoint;
<* ELSE *>
PROCEDURE ChildWindowFromPoint (Parent: HWND; pt : POINT) : HWND;
<* END *>

TYPE CWP_ENUM = (CWP__SKIPINVISIBLE,    (* 0 *)
                 CWP__SKIPDISABLED,     (* 1 *)
                 CWP__SKIPTRANSPARENT); (* 2 *)
     CWP_SET = SET OF CWP_ENUM;

CONST CWP_ALL             = CWP_SET {};                     (* 0x0000 *)
      CWP_SKIPINVISIBLE   = CWP_SET {CWP__SKIPINVISIBLE};   (* 0x0001 *)
      CWP_SKIPDISABLED    = CWP_SET {CWP__SKIPDISABLED};    (* 0x0002 *)
      CWP_SKIPTRANSPARENT = CWP_SET {CWP__SKIPTRANSPARENT}; (* 0x0004 *)

(* ChildWindowFromPointEx had parameter of structure type POINT which is passed
   by value. It had to be implemented in RTL. *)

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlChildWindowFromPointEx (Parent  : HWND; pt : POINT; flags : CWP_SET) : HWND;
CONST ChildWindowFromPointEx = rtlChildWindowFromPointEx;
<* ELSE *>
PROCEDURE ChildWindowFromPointEx (Parent  : HWND; pt : POINT; flags : CWP_SET) : HWND;
<* END *>

TYPE CTLCOLOR_ENUM = (CTLCOLOR_MSGBOX,        (* 0 *)
                      CTLCOLOR_EDIT,          (* 1 *)
                      CTLCOLOR_LISTBOX,       (* 2 *)
                      CTLCOLOR_BTN,           (* 3 *)
                      CTLCOLOR_DLG,           (* 4 *)
                      CTLCOLOR_SCROLLBAR,     (* 5 *)
                      CTLCOLOR_STATIC,        (* 6 *)
                      CTLCOLOR_MAX);          (* 7 *)

TYPE COLOR_TYPE = (COLOR_SCROLLBAR,           (*  0 *)
                   COLOR_BACKGROUND,          (*  1 *)
                   COLOR_ACTIVECAPTION,       (*  2 *)
                   COLOR_INACTIVECAPTION,     (*  3 *)
                   COLOR_MENU,                (*  4 *)
                   COLOR_WINDOW,              (*  5 *)
                   COLOR_WINDOWFRAME,         (*  6 *)
                   COLOR_MENUTEXT,            (*  7 *)
                   COLOR_WINDOWTEXT,          (*  8 *)
                   COLOR_CAPTIONTEXT,         (*  9 *)
                   COLOR_ACTIVEBORDER,        (* 10 *)
                   COLOR_INACTIVEBORDER,      (* 11 *)
                   COLOR_APPWORKSPACE,        (* 12 *)
                   COLOR_HIGHLIGHT,           (* 13 *)
                   COLOR_HIGHLIGHTTEXT,       (* 14 *)
                   COLOR_BTNFACE,             (* 15 *)
                   COLOR_BTNSHADOW,           (* 16 *)
                   COLOR_GRAYTEXT,            (* 17 *)
                   COLOR_BTNTEXT,             (* 18 *)
                   COLOR_INACTIVECAPTIONTEXT, (* 19 *)
                   COLOR_BTNHIGHLIGHT,        (* 20 *)
                   COLOR_3DDKSHADOW,          (* 21 *)
                   COLOR_3DLIGHT,             (* 22 *)
                   COLOR_INFOTEXT,            (* 23 *)
                   COLOR_INFOBK               (* 24 *)
     );

CONST COLOR_DESKTOP     = COLOR_BACKGROUND;
      COLOR_3DFACE      = COLOR_BTNFACE;
      COLOR_3DSHADOW    = COLOR_BTNSHADOW;
      COLOR_3DHIGHLIGHT = COLOR_BTNHIGHLIGHT;
      COLOR_3DHILIGHT   = COLOR_BTNHIGHLIGHT;
      COLOR_BTNHILIGHT  = COLOR_BTNHIGHLIGHT;

PROCEDURE GetSysColor (Index : COLOR_TYPE) : COLORREF;
PROCEDURE GetSysColorBrush (Index : COLOR_TYPE) : HBRUSH;

PROCEDURE SetSysColors (NElements : INTEGER;
                        Elements  : ARRAY OF COLOR_TYPE;
                        RgbValues : ARRAY OF COLORREF) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE DrawFocusRect (hDC : HDC; Rect : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE DrawFocusRect (hDC : HDC; Rect : PRECT (*!*)) : BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE FillRect      (hDC : HDC; Rect : RECT (*!*); Brush : HBRUSH) : BOOL;
<* ELSE *>
PROCEDURE FillRect      (hDC : HDC; Rect : PRECT (*!*); Brush : HBRUSH) : BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE FrameRect     (hDC : HDC; Rect : RECT (*!*); Brush : HBRUSH) : BOOL;
<* ELSE *>
PROCEDURE FrameRect     (hDC : HDC; Rect : PRECT (*!*); Brush : HBRUSH) : BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE InvertRect    (hDC : HDC; Rect : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE InvertRect    (hDC : HDC; Rect : PRECT (*!*)) : BOOL;
<* END *>
PROCEDURE SetRect       (VAR Rect : RECT; Left, Top, Right, Bottom : INTEGER) : BOOL;
PROCEDURE SetRectEmpty  (VAR Dst  : RECT) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE CopyRect      (VAR Dst  : RECT; Src : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE CopyRect      (VAR Dst  : RECT; Src : PRECT (*!*)) : BOOL;
<* END *>
PROCEDURE InflateRect   (VAR Rect : RECT; dx, dy : INTEGER) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE IntersectRect (VAR Dst  : RECT; Src1, Src2 : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE IntersectRect (VAR Dst  : RECT; Src1, Src2 : PRECT (*!*)) : BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE UnionRect     (VAR Dst  : RECT; Src1, Src2 : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE UnionRect     (VAR Dst  : RECT; Src1, Src2 : PRECT (*!*)) : BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE SubtractRect  (VAR Dst  : RECT; Src1, Src2 : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE SubtractRect  (VAR Dst  : RECT; Src1, Src2 : PRECT (*!*)) : BOOL;
<* END *>
PROCEDURE OffsetRect (VAR Dst : RECT; dx, dy : INTEGER) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE IsRectEmpty (Rect : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE IsRectEmpty (Rect : PRECT (*!*)) : BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE EqualRect (Rect1, Rect2 : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE EqualRect (Rect1, Rect2 : PRECT (*!*)) : BOOL;
<* END *>

(* PtInRect had parameter of structure type POINT which is passed
   by value. It had to be implemented in RTL.
*)

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlPtInRect (Rect : RECT; pt : POINT) : BOOL;
CONST PtInRect = rtlPtInRect;
<* ELSE *>
PROCEDURE PtInRect (Rect : PRECT; pt : POINT) : BOOL;
<* END *>

PROCEDURE GetWindowWord (hWnd : HWND; Index : INTEGER) : WORD;
PROCEDURE SetWindowWord (hWnd : HWND; Index : INTEGER; NewWord : WORD) : WORD;

PROCEDURE GetWindowLongA (hWnd : HWND; Index : INTEGER) : DWORD;
PROCEDURE GetWindowLongW (hWnd : HWND; Index : INTEGER) : DWORD;

(* These two in RTL; included specially for Modula-2 *)
PROCEDURE GetWindowPtrA (hWnd : HWND; Index : INTEGER) : SYSTEM.ADDRESS;
PROCEDURE GetWindowPtrW (hWnd : HWND; Index : INTEGER) : SYSTEM.ADDRESS;

PROCEDURE SetWindowLongA (hWnd : HWND; Index : INTEGER; NewLong : DWORD) : DWORD;
PROCEDURE SetWindowLongW (hWnd : HWND; Index : INTEGER; NewLong : DWORD) : DWORD;

(* These two in RTL; included specially for Modula-2 *)
PROCEDURE SetWindowPtrA (hWnd : HWND; Index : INTEGER; NewLong : SYSTEM.ADDRESS) : SYSTEM.ADDRESS;
PROCEDURE SetWindowPtrW (hWnd : HWND; Index : INTEGER; NewLong : SYSTEM.ADDRESS) : SYSTEM.ADDRESS;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetWindowLong = SetWindowLongW;
            GetWindowLong = GetWindowLongW;
            SetWindowPtr  = SetWindowPtrW;
            GetWindowPtr  = GetWindowPtrW;
<* ELSE *>
      CONST SetWindowLong = SetWindowLongA;
            GetWindowLong = GetWindowLongA;
            SetWindowPtr  = SetWindowPtrA;
            GetWindowPtr  = GetWindowPtrA;
<* END *>

PROCEDURE GetClassWord  (hWnd : HWND; Index : INTEGER) : WORD;
PROCEDURE SetClassWord  (hWnd : HWND; Index : INTEGER; NewWord : WORD) : WORD;
PROCEDURE GetClassLongA (hWnd : HWND; Index : INTEGER) : DWORD;
PROCEDURE GetClassLongW (hWnd : HWND; Index : INTEGER) : DWORD;
PROCEDURE SetClassLongA (hWnd : HWND; Index : INTEGER; NewLong : DWORD) : DWORD;
PROCEDURE SetClassLongW (hWnd : HWND; Index : INTEGER; NewLong : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetClassLong = GetClassLongW;
            SetClassLong = SetClassLongW;
<* ELSE *>
      CONST GetClassLong = GetClassLongA;
            SetClassLong = SetClassLongA;
<* END *>

PROCEDURE GetDesktopWindow () : HWND;
PROCEDURE GetParent (hWnd : HWND) : HWND;
PROCEDURE SetParent (hWndChild : HWND; hWndNewParent : HWND) : HWND;


PROCEDURE EnumChildWindows (Parent : HWND; EnumProc : WNDENUMPROC;
                            lParam : LPARAM) : BOOL;

PROCEDURE FindWindowA (ClassName : ATOMSTR;  WindowName : PCSTR  (* NIL *)) : HWND;
PROCEDURE FindWindowW (ClassName : ATOMWSTR; WindowName : PCWSTR (* NIL *)) : HWND;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindWindow = FindWindowW;
<* ELSE *>
      CONST FindWindow = FindWindowA;
<* END *>

PROCEDURE FindWindowExA (parent : HWND; ChildAfter : HWND;
                         Class : ATOMSTR; WindowName : PCSTR (* NIL *)) : HWND;

PROCEDURE FindWindowExW (parent : HWND; ChildAfter : HWND;
                         Class : ATOMWSTR; WindowName : PCSTR (* NIL *)) : HWND;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindWindowEx = FindWindowExW;
<* ELSE *>
      CONST FindWindowEx = FindWindowExA;
<* END *>

PROCEDURE EnumWindows (EnumProc : WNDENUMPROC; lParam : LPARAM) : BOOL;
PROCEDURE EnumThreadWindows (ThreadId : DWORD; EnumProc : WNDENUMPROC;
                             lParam : LPARAM) : BOOL;

PROCEDURE GetClassNameA (hWnd : HWND; VAR ClassName : ARRAY OF CHAR;
                         MaxCount : INTEGER) : INTEGER;
PROCEDURE GetClassNameW (hWnd : HWND; VAR ClassName : ARRAY OF WCHAR;
                         MaxCount : INTEGER) : INTEGER;
<* IF DEFINED (UNICODE) THEN *>
      CONST GetClassName = GetClassNameW;
<* ELSE *>
      CONST GetClassName = GetClassNameA;
<* END *>

PROCEDURE GetTopWindow (hWnd : HWND) : HWND;
PROCEDURE GetWindowThreadProcessId (hWnd : HWND;
                                    VAR [NIL] ProcessId : DWORD) : DWORD;

PROCEDURE GetLastActivePopup (hWnd : HWND) : HWND;

(* GetWindow() Constants *)

TYPE GW_ENUM = (GW_HWNDFIRST, (* 0 *)
                GW_HWNDLAST,  (* 1 *)
                GW_HWNDNEXT,  (* 2 *)
                GW_HWNDPREV,  (* 3 *)
                GW_OWNER,     (* 4 *)
                GW_CHILD);    (* 5 *)

CONST GW_MAX = GW_CHILD;

PROCEDURE GetWindow     (hWnd : HWND; Cmd : GW_ENUM) : HWND;
(*
PROCEDURE GetNextWindow (hWnd : HWND; Cmd : GW_ENUM) : HWND;
*)
CONST GetNextWindow = GetWindow;

PROCEDURE SetWindowsHookA (FilterType : INTEGER; pfnFilterProc : HOOKPROC) : HHOOK;
PROCEDURE SetWindowsHookW (FilterType : INTEGER; pfnFilterProc : HOOKPROC) : HHOOK;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetWindowsHook = SetWindowsHookW;
<* ELSE *>
      CONST SetWindowsHook = SetWindowsHookA;
<* END *>

PROCEDURE UnhookWindowsHook (Code : INTEGER; pfnFilterProc : HOOKPROC) : BOOL;

PROCEDURE SetWindowsHookExA (idHook     : INTEGER;
                             lpfn       : HOOKPROC;
                             hmod       : HINSTANCE;
                             dwThreadId : DWORD) : HHOOK;

PROCEDURE SetWindowsHookExW (idHook     : INTEGER;
                             lpfn       : HOOKPROC;
                             hmod       : HINSTANCE;
                             dwThreadId : DWORD) : HHOOK;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetWindowsHookEx = SetWindowsHookExW;
<* ELSE *>
      CONST SetWindowsHookEx = SetWindowsHookExA;
<* END *>

PROCEDURE UnhookWindowsHookEx (hhk : HHOOK) : BOOL;
PROCEDURE CallNextHookEx (hhk    : HHOOK;
                          Code   : INTEGER;
                          wParam : WPARAM;
                          lParam : LPARAM) : LRESULT;

PROCEDURE CheckMenuRadioItem (hmenu   : HMENU;
                              idFirst : UINT;
                              idLast  : UINT;
                              idCheck : UINT;
                              flags : MF_SET) : BOOL;

(* Menu item resource format *)

TYPE MENUITEMTEMPLATEHEADER = RECORD
                                     versionNumber : WORD;
                                     offset : WORD;
                              END;

TYPE MENUITEMTEMPLATE = RECORD
                               mtOption : WORD;
                               mtID     : WORD;
                               mtString : ARRAY [0..0] OF WCHAR;
                        END;

(*
 * System Menu Command Values
 *)

CONST SC_SIZE         = 0F000h;
      SC_MOVE         = 0F010h;
      SC_MINIMIZE     = 0F020h;
      SC_MAXIMIZE     = 0F030h;
      SC_NEXTWINDOW   = 0F040h;
      SC_PREVWINDOW   = 0F050h;
      SC_CLOSE        = 0F060h;
      SC_VSCROLL      = 0F070h;
      SC_HSCROLL      = 0F080h;
      SC_MOUSEMENU    = 0F090h;
      SC_KEYMENU      = 0F100h;
      SC_ARRANGE      = 0F110h;
      SC_RESTORE      = 0F120h;
      SC_TASKLIST     = 0F130h;
      SC_SCREENSAVE   = 0F140h;
      SC_HOTKEY       = 0F150h;
      SC_DEFAULT      = 0F160h;
      SC_MONITORPOWER = 0F170h;
      SC_CONTEXTHELP  = 0F180h;
      SC_SEPARATOR    = 0F00Fh;
(*
 * Obsolete names
 *)
      SC_ICON         = SC_MINIMIZE;
      SC_ZOOM         = SC_MAXIMIZE;

(*
 * Resource Loading Routines
 *)

PROCEDURE LoadBitmapA (hInstance : HINSTANCE; BitmapName : RESOURCESTRA)  : HBITMAP;
PROCEDURE LoadBitmapW (hInstance : HINSTANCE; BitmapName : RESOURCESTRW) : HBITMAP;

PROCEDURE LoadCursorA (hInstance : HINSTANCE; CursorName : RESOURCESTRA)  : HCURSOR;
PROCEDURE LoadCursorW (hInstance : HINSTANCE; CursorName : RESOURCESTRW) : HCURSOR;

PROCEDURE LoadCursorFromFileA (FileName : ARRAY OF CHAR)  : HCURSOR;
PROCEDURE LoadCursorFromFileW (FileName : ARRAY OF WCHAR) : HCURSOR;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadBitmap         = LoadBitmapW;
            LoadCursor         = LoadCursorW;
            LoadCursorFromFile = LoadCursorFromFileW;
<* ELSE *>
      CONST LoadBitmap         = LoadBitmapA;
            LoadCursor         = LoadCursorA;
            LoadCursorFromFile = LoadCursorFromFileA;
<* END *>

PROCEDURE CreateCursor (hInst : HINSTANCE;
                        xHotSpot, yHotSpot,
                        Width, Height : INTEGER;
                        ANDPlane : PBYTE;
                        XORPlane : PBYTE) : HCURSOR;

PROCEDURE DestroyCursor (hCursor : HCURSOR) : BOOL;

(* defined in RTL *)

PROCEDURE CopyCursor (hCursor : HCURSOR) : HCURSOR;

(* Standard Cursor IDs *)

CONST IDC_ARROW       = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32512));
      IDC_IBEAM       = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32513));
      IDC_WAIT        = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32514));
      IDC_CROSS       = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32515));
      IDC_UPARROW     = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32516));
      IDC_SIZE        = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32640)); (* OBSOLETE: use IDC_SIZEALL *)
      IDC_ICON        = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32641)); (* OBSOLETE: use IDC_ARROW *)
      IDC_SIZENWSE    = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32642));
      IDC_SIZENESW    = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32643));
      IDC_SIZEWE      = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32644));
      IDC_SIZENS      = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32645));
      IDC_SIZEALL     = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32646));
      IDC_NO          = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32648));
      IDC_HAND        = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32649));
      IDC_APPSTARTING = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32650));
      IDC_HELP        = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32651));

PROCEDURE SetSystemCursor (hcur : HCURSOR; id : DWORD) : BOOL;

TYPE ICONINFO = RECORD
                      fIcon : BOOL;
                      xHotspot,
                      yHotspot : DWORD;
                      Mask,
                      Color : HBITMAP;
                END;
    PICONINFO = ICONINFO;

PROCEDURE LoadIconA (hInstance : HINSTANCE; IconName : RESOURCESTRA) : HICON;
PROCEDURE LoadIconW (hInstance : HINSTANCE; IconName : RESOURCESTRW) : HICON;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadIcon = LoadIconW;
<* ELSE *>
      CONST LoadIcon = LoadIconA;
<* END *>

PROCEDURE CreateIcon (hInstance : HINSTANCE; Width, Height : INTEGER;
                      Planes, BitsPixel : BYTE;
                      ANDbits : ARRAY OF SYSTEM.BYTE;
                      XORbits : ARRAY OF SYSTEM.BYTE) : HICON;

PROCEDURE DestroyIcon (hIcon : HICON) : BOOL;

PROCEDURE LookupIconIdFromDirectory   (presbits : PBYTE; fIcon : BOOL) : INTEGER;

TYPE LR_ENUM = (LR__MONOCHROME,       (*  0 *)
                LR__COLOR,            (*  1 *)
                LR__COPYRETURNORG,    (*  2 *)
                LR__COPYDELETEORG,    (*  3 *)
                LR__LOADFROMFILE,     (*  4 *)
                LR__LOADTRANSPARENT,  (*  5 *)
                LR__DEFAULTSIZE,      (*  6 *)
                LR__VGACOLOR,
                LR__8, LR__9,
                LR__10, LR__11,
                LR__LOADMAP3DCOLORS,  (* 12 *)
                LR__CREATEDIBSECTION, (* 13 *)
                LR__COPYFROMRESOURCE, (* 14 *)
                LR__SHARED);          (* 15 *)

     LR_SET = SET OF LR_ENUM;

CONST LR_DEFAULTCOLOR     = LR_SET {};                      (* 0x0000 *)
      LR_MONOCHROME       = LR_SET {LR__MONOCHROME       }; (* 0x0001 *)
      LR_COLOR            = LR_SET {LR__COLOR            }; (* 0x0002 *)
      LR_COPYRETURNORG    = LR_SET {LR__COPYRETURNORG    }; (* 0x0004 *)
      LR_COPYDELETEORG    = LR_SET {LR__COPYDELETEORG    }; (* 0x0008 *)
      LR_LOADFROMFILE     = LR_SET {LR__LOADFROMFILE     }; (* 0x0010 *)
      LR_LOADTRANSPARENT  = LR_SET {LR__LOADTRANSPARENT  }; (* 0x0020 *)
      LR_DEFAULTSIZE      = LR_SET {LR__DEFAULTSIZE      }; (* 0x0040 *)
      LR_VGACOLOR         = LR_SET {LR__VGACOLOR         }; (* 0x0080 *)
      LR_LOADMAP3DCOLORS  = LR_SET {LR__LOADMAP3DCOLORS  }; (* 0x1000 *)
      LR_CREATEDIBSECTION = LR_SET {LR__CREATEDIBSECTION }; (* 0x2000 *)
      LR_COPYFROMRESOURCE = LR_SET {LR__COPYFROMRESOURCE }; (* 0x4000 *)
      LR_SHARED           = LR_SET {LR__SHARED           }; (* 0x8000 *)


PROCEDURE LookupIconIdFromDirectoryEx (presbits : PBYTE; fIcon : BOOL;
                                       cxDesired, cyDesired : INTEGER;
                                       Flags : LR_SET) : INTEGER;
PROCEDURE CreateIconFromResource (presbits : PBYTE; ResSize : DWORD;
                                  fIcon : BOOL; Ver : DWORD) : HICON;
PROCEDURE CreateIconFromResourceEx (presbits : PBYTE; ResSize : DWORD;
                                    fIcon : BOOL; Ver : DWORD;
                                    cxDesired, cyDesired : INTEGER;
                                    Flags : LR_SET) : HICON;

(* Icon/Cursor header *)

TYPE CURSORSHAPE = RECORD
                          xHotSpot  : INTEGER;
                          yHotSpot  : INTEGER;
                          cx        : INTEGER;
                          cy        : INTEGER;
                          cbWidth   : INTEGER;
                          Planes    : BYTE;
                          BitsPixel : BYTE;
                   END;
    PCURSORSHAPE = POINTER TO CURSORSHAPE;

TYPE IMAGE_TYPE = (IMAGE_BITMAP,       (* 0 *)
                   IMAGE_ICON,         (* 1 *)
                   IMAGE_CURSOR,       (* 2 *)
                   IMAGE_ENHMETAFILE); (* 3 *)

PROCEDURE LoadImageA (instance  : HINSTANCE;
                      name      : RESOURCESTRA;
                      type      : IMAGE_TYPE;
                      cxDesired,
                      cyDesired : INTEGER;
                      flags     : LR_SET) : HANDLE;

PROCEDURE LoadImageW (instance  : HINSTANCE;
                      name      : RESOURCESTRW;
                      type      : IMAGE_TYPE;
                      cxDesired,
                      cyDesired : INTEGER;
                      flags     : LR_SET) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadImage = LoadImageW;
<* ELSE *>
      CONST LoadImage = LoadImageA;
<* END *>

PROCEDURE CopyImage (hImage : HANDLE;
                     type   : IMAGE_TYPE;
                     cxDesired,
                     cyDesired : INTEGER;
                     flags     : LR_SET) : HANDLE;

TYPE DI_ENUM = (DI__MASK,         (* 0 *)
                DI__IMAGE,        (* 1 *)
                DI__COMPAT,       (* 2 *)
                DI__DEFAULTSIZE); (* 3 *)
     DI_SET = SET OF DI_ENUM;

CONST DI_MASK        = DI_SET {DI__MASK};        (* 0x0001 *)
      DI_IMAGE       = DI_SET {DI__IMAGE};       (* 0x0002 *)
      DI_COMPAT      = DI_SET {DI__COMPAT};      (* 0x0004 *)
      DI_DEFAULTSIZE = DI_SET {DI__DEFAULTSIZE}; (* 0x0008 *)

      DI_NORMAL      = DI_MASK + DI_IMAGE;

PROCEDURE DrawIconEx (hDC                : HDC;
                      x, y               : INTEGER;
                      hIcon              : HICON;
                      cx, cy             : INTEGER;
                      istepIfAniCur      : UINT;
                      hbrFlickerFreeDraw : HBRUSH;
                      diFlags            : DI_SET) : BOOL;


<* IF BACKEND # "C" THEN *>
PROCEDURE CreateIconIndirect (iconinfo : ICONINFO (*!*)) : HICON;
<* ELSE *>
PROCEDURE CreateIconIndirect (iconinfo : PICONINFO (*!*)) : HICON;
<* END *>
PROCEDURE CopyIcon           (hIcon : HICON) : HICON;
PROCEDURE GetIconInfo        (hIcon : HICON; VAR iconinfo : ICONINFO) : BOOL;

CONST RES_ICON    = 1;
      RES_CURSOR  = 2;

(* OEM Resource Ordinal Numbers *)

CONST OBM_CLOSE         =  32754;
      OBM_UPARROW       =  32753;
      OBM_DNARROW       =  32752;
      OBM_RGARROW       =  32751;
      OBM_LFARROW       =  32750;
      OBM_REDUCE        =  32749;
      OBM_ZOOM          =  32748;
      OBM_RESTORE       =  32747;
      OBM_REDUCED       =  32746;
      OBM_ZOOMD         =  32745;
      OBM_RESTORED      =  32744;
      OBM_UPARROWD      =  32743;
      OBM_DNARROWD      =  32742;
      OBM_RGARROWD      =  32741;
      OBM_LFARROWD      =  32740;
      OBM_MNARROW       =  32739;
      OBM_COMBO         =  32738;
      OBM_UPARROWI      =  32737;
      OBM_DNARROWI      =  32736;
      OBM_RGARROWI      =  32735;
      OBM_LFARROWI      =  32734;

      OBM_OLD_CLOSE     =  32767;
      OBM_SIZE          =  32766;
      OBM_OLD_UPARROW   =  32765;
      OBM_OLD_DNARROW   =  32764;
      OBM_OLD_RGARROW   =  32763;
      OBM_OLD_LFARROW   =  32762;
      OBM_BTSIZE        =  32761;
      OBM_CHECK         =  32760;
      OBM_CHECKBOXES    =  32759;
      OBM_BTNCORNERS    =  32758;
      OBM_OLD_REDUCE    =  32757;
      OBM_OLD_ZOOM      =  32756;
      OBM_OLD_RESTORE   =  32755;

      OCR_NORMAL        =  32512;
      OCR_IBEAM         =  32513;
      OCR_WAIT          =  32514;
      OCR_CROSS         =  32515;
      OCR_UP            =  32516;
      OCR_SIZE          =  32640;   (* OBSOLETE: use OCR_SIZEALL *)
      OCR_ICON          =  32641;   (* OBSOLETE: use OCR_NORMAL  *)
      OCR_SIZENWSE      =  32642;
      OCR_SIZENESW      =  32643;
      OCR_SIZEWE        =  32644;
      OCR_SIZENS        =  32645;
      OCR_SIZEALL       =  32646;
      OCR_ICOCUR        =  32647;
      OCR_NO            =  32648; (* not in win3.1 *)
      OCR_APPSTARTING   =  32650;

      OIC_SAMPLE        =  32512;
      OIC_HAND          =  32513;
      OIC_QUES          =  32514;
      OIC_BANG          =  32515;
      OIC_NOTE          =  32516;
      OIC_WINLOGO       =  32517;
      OIC_WARNING       =  OIC_BANG;
      OIC_ERROR         =  OIC_HAND;
      OIC_INFORMATION   =  OIC_NOTE;

CONST ORD_LANGDRIVER = 1;  (* The ordinal number for the entry point of
                           ** language drivers.
                           *)

(* Standard Icon IDs *)

CONST IDI_APPLICATION   = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32512));
      IDI_HAND          = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32513));
      IDI_QUESTION      = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32514));
      IDI_EXCLAMATION   = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32515));
      IDI_ASTERISK      = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32516));
      IDI_WINLOGO       = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32517));
      IDI_WARNING       = IDI_EXCLAMATION;
      IDI_ERROR         = IDI_HAND;
      IDI_INFORMATION   = IDI_ASTERISK;

PROCEDURE LoadStringA (hInstance  : HINSTANCE;
                       uID        : UINT;
                       VAR Buffer : ARRAY OF CHAR;
                       nBufferMax : INTEGER) : INTEGER;

PROCEDURE LoadStringW (hInstance  : HINSTANCE;
                       uID        : UINT;
                       VAR Buffer : ARRAY OF WCHAR;
                       nBufferMax : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadString = LoadStringW;
<* ELSE *>
      CONST LoadString = LoadStringA;
<* END *>


(* Dialog Box Command IDs *)

CONST IDOK      = 1;
      IDCANCEL  = 2;
      IDABORT   = 3;
      IDRETRY   = 4;
      IDIGNORE  = 5;
      IDYES     = 6;
      IDNO      = 7;
      IDCLOSE   = 8;
      IDHELP    = 9;


(*
 * Control Manager Structures and Definitions
 *)

(* Edit Control Styles *)

CONST ES_LEFT             = WS_SET { };       (* 0x0000L *)
      ES_CENTER           = WS_SET {WS__0};   (* 0x0001L *)
      ES_RIGHT            = WS_SET {WS__1};   (* 0x0002L *)
      ES_MULTILINE        = WS_SET {WS__2};   (* 0x0004L *)
      ES_UPPERCASE        = WS_SET {WS__3};   (* 0x0008L *)
      ES_LOWERCASE        = WS_SET {WS__4};   (* 0x0010L *)
      ES_PASSWORD         = WS_SET {WS__5};   (* 0x0020L *)
      ES_AUTOVSCROLL      = WS_SET {WS__6};   (* 0x0040L *)
      ES_AUTOHSCROLL      = WS_SET {WS__7};   (* 0x0080L *)
      ES_NOHIDESEL        = WS_SET {WS__8};   (* 0x0100L *)
      ES_OEMCONVERT       = WS_SET {WS__10};  (* 0x0400L *)
      ES_READONLY         = WS_SET {WS__11};  (* 0x0800L *)
      ES_WANTRETURN       = WS_SET {WS__12};  (* 0x1000L *)
      ES_NUMBER           = WS_SET {WS__13};  (* 0x2000L *)

(* Edit Control Notification Codes *)

CONST EN_SETFOCUS         = 0100h;
      EN_KILLFOCUS        = 0200h;
      EN_CHANGE           = 0300h;
      EN_UPDATE           = 0400h;
      EN_ERRSPACE         = 0500h;
      EN_MAXTEXT          = 0501h;
      EN_HSCROLL          = 0601h;
      EN_VSCROLL          = 0602h;

(* Edit control EM_SETMARGIN parameters *)

CONST EC_LEFTMARGIN       = 00001h;
      EC_RIGHTMARGIN      = 00002h;
      EC_USEFONTINFO      = 0ffffh;

(*
 * Edit Control Messages
 *)

CONST EM_GETSEL               = 00B0h;
      EM_SETSEL               = 00B1h;
      EM_GETRECT              = 00B2h;
      EM_SETRECT              = 00B3h;
      EM_SETRECTNP            = 00B4h;
      EM_SCROLL               = 00B5h;
      EM_LINESCROLL           = 00B6h;
      EM_SCROLLCARET          = 00B7h;
      EM_GETMODIFY            = 00B8h;
      EM_SETMODIFY            = 00B9h;
      EM_GETLINECOUNT         = 00BAh;
      EM_LINEINDEX            = 00BBh;
      EM_SETHANDLE            = 00BCh;
      EM_GETHANDLE            = 00BDh;
      EM_GETTHUMB             = 00BEh;
      EM_LINELENGTH           = 00C1h;
      EM_REPLACESEL           = 00C2h;
      EM_GETLINE              = 00C4h;
      EM_LIMITTEXT            = 00C5h;
      EM_CANUNDO              = 00C6h;
      EM_UNDO                 = 00C7h;
      EM_FMTLINES             = 00C8h;
      EM_LINEFROMCHAR         = 00C9h;
      EM_SETTABSTOPS          = 00CBh;
      EM_SETPASSWORDCHAR      = 00CCh;
      EM_EMPTYUNDOBUFFER      = 00CDh;
      EM_GETFIRSTVISIBLELINE  = 00CEh;
      EM_SETREADONLY          = 00CFh;
      EM_SETWORDBREAKPROC     = 00D0h;
      EM_GETWORDBREAKPROC     = 00D1h;
      EM_GETPASSWORDCHAR      = 00D2h;
      EM_SETMARGINS           = 00D3h;
      EM_GETMARGINS           = 00D4h;
      EM_SETLIMITTEXT         = EM_LIMITTEXT; (* win40 Name change *)
      EM_GETLIMITTEXT         = 00D5h;
      EM_POSFROMCHAR          = 00D6h;
      EM_CHARFROMPOS          = 00D7h;

(* EM_SETWORDBREAKPROC sends in LPARAM and EM_GETWORDBREAKPROC returns as
   LRESULT pointer to WORDBREAKPROC
*)

(* WB_ constants defined earlier near EDITWORDBREAKPROC *)

(* Button Control Styles *)

CONST BS_PUSHBUTTON      = WS_SET {                       };  (* 0x00L *)
      BS_DEFPUSHBUTTON   = WS_SET {                  WS__0};  (* 0x01L *)
      BS_CHECKBOX        = WS_SET {            WS__1      };  (* 0x02L *)
      BS_AUTOCHECKBOX    = WS_SET {            WS__1,WS__0};  (* 0x03L *)
      BS_RADIOBUTTON     = WS_SET {      WS__2            };  (* 0x04L *)
      BS_3STATE          = WS_SET {      WS__2,      WS__0};  (* 0x05L *)
      BS_AUTO3STATE      = WS_SET {      WS__2,WS__1      };  (* 0x06L *)
      BS_GROUPBOX        = WS_SET {      WS__2,WS__1,WS__0};  (* 0x07L *)
      BS_USERBUTTON      = WS_SET {WS__3                  };  (* 0x08L *)
      BS_AUTORADIOBUTTON = WS_SET {WS__3,            WS__0};  (* 0x09L *)
      BS_OWNERDRAW       = WS_SET {WS__3,      WS__1,WS__0};  (* 0x0BL *)
      BS_LEFTTEXT        = WS_SET {WS__5};                    (* 0x20L *)
      BS_TEXT            = WS_SET {};                         (* 0x00000000L *)
      BS_ICON            = WS_SET {WS__6};                    (* 0x00000040L *)
      BS_BITMAP          = WS_SET {WS__7};                    (* 0x00000080L *)
      BS_LEFT            = WS_SET {WS__8};                    (* 0x00000100L *)
      BS_RIGHT           = WS_SET {WS__9};                    (* 0x00000200L *)
      BS_CENTER          = WS_SET {WS__8, WS__9};             (* 0x00000300L *)
      BS_TOP             = WS_SET {WS__10};                   (* 0x00000400L *)
      BS_BOTTOM          = WS_SET {WS__11};                   (* 0x00000800L *)
      BS_VCENTER         = WS_SET {WS__22, WS__10};           (* 0x00000C00L *)
      BS_PUSHLIKE        = WS_SET {WS__12};                   (* 0x00001000L *)
      BS_MULTILINE       = WS_SET {WS__13};                   (* 0x00002000L *)
      BS_NOTIFY          = WS_SET {WS__14};                   (* 0x00004000L *)
      BS_FLAT            = WS_SET {WS__15};                   (* 0x00008000L *)
      BS_RIGHTBUTTON     = BS_LEFTTEXT;

(* User Button Notification Codes *)

CONST BN_CLICKED         = 0;
      BN_PAINT           = 1;
      BN_HILITE          = 2;
      BN_UNHILITE        = 3;
      BN_DISABLE         = 4;
      BN_DOUBLECLICKED   = 5;
      BN_PUSHED          = BN_HILITE;
      BN_UNPUSHED        = BN_UNHILITE;
      BN_DBLLCLK         = BN_DOUBLECLICKED;
      BN_SETFOCUS        = 6;
      BN_KILLFOCUS       = 7;


(*
 * Button Control Messages
 *)

CONST BM_GETCHECK        = 00F0h;
      BM_SETCHECK        = 00F1h;
      BM_GETSTATE        = 00F2h;
      BM_SETSTATE        = 00F3h;
      BM_SETSTYLE        = 00F4h;
      BM_CLICK           = 00F5h;
      BM_GETIMAGE        = 00F6h;
      BM_SETIMAGE        = 00F7h;

TYPE  BST_ENUM = (BST__CHECKED,       (* 0 *)
                  BST__INDETERMINATE, (* 1 *)
                  BST__PUSHED,        (* 2 *)
                  BST__FOCUS);        (* 3 *)
      BST_SET = SET OF BST_ENUM;

CONST BST_UNCHECKED      = BST_SET {};                   (* 0x0000 *)
      BST_CHECKED        = BST_SET {BST__CHECKED};       (* 0x0001 *)
      BST_INDETERMINATE  = BST_SET {BST__INDETERMINATE}; (* 0x0002 *)
      BST_PUSHED         = BST_SET {BST__PUSHED};        (* 0x0004 *)
      BST_FOCUS          = BST_SET {BST__FOCUS};         (* 0x0008 *)

(* Static Control Constants *)

CONST SS_LEFT           = WS_SET {                             }; (* 0x00000000L *)
      SS_CENTER         = WS_SET {                        WS__0}; (* 0x00000001L *)
      SS_RIGHT          = WS_SET {                  WS__1      }; (* 0x00000002L *)
      SS_ICON           = WS_SET {                  WS__1,WS__0}; (* 0x00000003L *)
      SS_BLACKRECT      = WS_SET {            WS__2            }; (* 0x00000004L *)
      SS_GRAYRECT       = WS_SET {            WS__2,      WS__0}; (* 0x00000005L *)
      SS_WHITERECT      = WS_SET {            WS__2,WS__1      }; (* 0x00000006L *)
      SS_BLACKFRAME     = WS_SET {            WS__2,WS__1,WS__0}; (* 0x00000007L *)
      SS_GRAYFRAME      = WS_SET {      WS__3                  }; (* 0x00000008L *)
      SS_WHITEFRAME     = WS_SET {      WS__3,            WS__0}; (* 0x00000009L *)
      SS_USERITEM       = WS_SET {      WS__3,      WS__1      }; (* 0x0000000AL *)
      SS_SIMPLE         = WS_SET {      WS__3,      WS__1,WS__0}; (* 0x0000000BL *)
      SS_LEFTNOWORDWRAP = WS_SET {      WS__3,WS__2            }; (* 0x0000000CL *)
      SS_OWNERDRAW      = WS_SET {      WS__3,WS__2,      WS__0}; (* 0x0000000DL *)
      SS_ENHMETAFILE    = WS_SET {      WS__3,WS__2,WS__1,WS__0}; (* 0x0000000FL *)
      SS_ETCHEDHORZ     = WS_SET {WS__4                        }; (* 0x00000010L *)
      SS_ETCHEDVERT     = WS_SET {WS__4,                  WS__0}; (* 0x00000011L *)
      SS_ETCHEDFRAME    = WS_SET {WS__4,            WS__1      }; (* 0x00000012L *)
      SS_TYPEMASK       = WS_SET {WS__4,WS__3,WS__2,WS__1,WS__0}; (* 0x0000001FL *)
      SS_NOPREFIX       = WS_SET {WS__7};                         (* 0x00000080L *)
      SS_NOTIFY         = WS_SET {WS__8};                         (* 0x00000100L *)
      SS_CENTERIMAGE    = WS_SET {WS__9};                         (* 0x00000200L *)
      SS_RIGHTJUST      = WS_SET {WS__10};                        (* 0x00000400L *)
      SS_REALSIZEIMAGE  = WS_SET {WS__11};                        (* 0x00000800L *)
      SS_SUNKEN         = WS_SET {WS__12};                        (* 0x00001000L *)
      SS_ENDELLIPSIS    = WS_SET {WS__14};                        (* 0x00004000L *)
      SS_PATHELLIPSIS   = WS_SET {WS__15};                        (* 0x00008000L *)
      SS_WORDELLIPSIS   = WS_SET {WS__15,WS__14};                 (* 0x0000C000L *)
      SS_ELLIPSISMASK   = WS_SET {WS__15,WS__14};                 (* 0x0000C000L *)

(*
 * Static Control Mesages
 *)

CONST STM_SETICON        = 0170h;
      STM_GETICON        = 0171h;
      STM_SETIMAGE       = 0172h;
      STM_GETIMAGE       = 0173h;
      STM_MSGMAX         = 0174h;

(*
 * Static Control Notifications
 *)

CONST STN_CLICKED        = 0;
      STN_DBLCLK         = 1;
      STN_ENABLE         = 2;
      STN_DISABLE        = 3;

(* Dialog window class *)

CONST  WC_DIALOG = SYSTEM.CAST (ATOMSTR, VAL (DWORD, 8002h));

(* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows *)

CONST DWL_MSGRESULT = 0;
      DWL_DLGPROC   = 4;
      DWL_USER      = 8;

(* Dialog Manager Routines *)

PROCEDURE IsDialogMessageA (hDlg : HWND; VAR Msg : MSG) : BOOL;
PROCEDURE IsDialogMessageW (hDlg : HWND; VAR Msg : MSG) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST IsDialogMessage = IsDialogMessageW;
<* ELSE *>
      CONST IsDialogMessage = IsDialogMessageA;
<* END *>

PROCEDURE MapDialogRect (hDlg : HWND; VAR Rect : RECT) : BOOL;


(* DlgDirList, DlgDirListComboBox flags values *)

TYPE DDL_ENUM = (DDL__READONLY,   (* 0 *)
                 DDL__HIDDEN,     (* 1 *)
                 DDL__SYSTEM,     (* 2 *)
                 DDL__3,
                 DDL__DIRECTORY,  (* 4 *)
                 DDL__ARCHIVE,    (* 5 *)
                 DDL__6,  DDL__7,  DDL__8, DDL__9,
                 DDL__10, DDL__11, DDL__12,
                 DDL__POSTMSGS,   (* 13 *)
                 DDL__DRIVES,     (* 14 *)
                 DDL__EXCLUSIVE); (* 15 *)
      DDL_SET = SET OF DDL_ENUM;

CONST DDL_READWRITE       = DDL_SET { };                (* 0x0000 *)
      DDL_READONLY        = DDL_SET {DDL__READONLY};    (* 0x0001 *)
      DDL_HIDDEN          = DDL_SET {DDL__HIDDEN};      (* 0x0002 *)
      DDL_SYSTEM          = DDL_SET {DDL__SYSTEM};      (* 0x0004 *)
      DDL_DIRECTORY       = DDL_SET {DDL__DIRECTORY};   (* 0x0010 *)
      DDL_ARCHIVE         = DDL_SET {DDL__ARCHIVE};     (* 0x0020 *)

      DDL_POSTMSGS        = DDL_SET {DDL__POSTMSGS};    (* 0x2000 *)
      DDL_DRIVES          = DDL_SET {DDL__DRIVES};      (* 0x4000 *)
      DDL_EXCLUSIVE       = DDL_SET {DDL__EXCLUSIVE};   (* 0x8000 *)


PROCEDURE DlgDirListA (hDlg : HWND; VAR PathSpec : ARRAY OF CHAR;
                       IDListBox : INTEGER; IDStaticPath : INTEGER;
                       FileType : DDL_SET) : INTEGER;
PROCEDURE DlgDirListW (hDlg : HWND; VAR PathSpec : ARRAY OF WCHAR;
                       IDListBox : INTEGER; IDStaticPath : INTEGER;
                       FileType : DDL_SET) : INTEGER;

PROCEDURE DlgDirSelectExA (hDlg : HWND; VAR String : ARRAY OF CHAR;
                           Count : INTEGER; IDListBox : INTEGER) : BOOL;
PROCEDURE DlgDirSelectExW (hDlg : HWND; VAR String : ARRAY OF WCHAR;
                           Count : INTEGER; IDListBox : INTEGER) : BOOL;

PROCEDURE DlgDirListComboBoxA (hDlg : HWND; VAR PathSpec : ARRAY OF CHAR;
                               IDComboBox : INTEGER; IDStaticPath : INTEGER;
                               Filetype : DDL_SET) : INTEGER;
PROCEDURE DlgDirListComboBoxW (hDlg : HWND; VAR PathSpec : ARRAY OF WCHAR;
                               IDComboBox : INTEGER; IDStaticPath : INTEGER;
                               Filetype : DDL_SET) : INTEGER;

PROCEDURE DlgDirSelectComboBoxExA (hDlg : HWND; VAR String : ARRAY OF CHAR;
                                   Count : INTEGER; IDComboBox : INTEGER) : BOOL;
PROCEDURE DlgDirSelectComboBoxExW (hDlg : HWND; VAR String : ARRAY OF WCHAR;
                                   Count : INTEGER; IDComboBox : INTEGER) : BOOL;


<* IF DEFINED (UNICODE) THEN *>
      CONST DlgDirList = DlgDirListW;
            DlgDirSelectEx = DlgDirSelectExW;
            DlgDirListComboBox = DlgDirListComboBoxW;
            DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExW;
<* ELSE *>
      CONST DlgDirList = DlgDirListA;
            DlgDirSelectEx = DlgDirSelectExA;
            DlgDirListComboBox = DlgDirListComboBoxA;
            DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExA;
<* END *>


(* Dialog Styles *)

CONST DS_ABSALIGN         = WS_SET {WS__0};   (* 0x0001L *)
      DS_SYSMODAL         = WS_SET {WS__1};   (* 0x0002L *)
      DS_LOCALEDIT        = WS_SET {WS__5};   (* 0x0020L *) (* Edit items get Local storage. *)
      DS_SETFONT          = WS_SET {WS__6};   (* 0x0040L *) (* User specified font for Dlg controls *)
      DS_MODALFRAME       = WS_SET {WS__7};   (* 0x0080L *) (* Can be combined with WS_CAPTION  *)
      DS_NOIDLEMSG        = WS_SET {WS__8};   (* 0x0100L *) (* WM_ENTERIDLE message will not be sent *)
      DS_SETFOREGROUND    = WS_SET {WS__9};   (* 0x0200L *) (* not in win3.1 *)
      DS_3DLOOK           = WS_SET {WS__2};   (* 0x0004L *)
      DS_FIXEDSYS         = WS_SET {WS__3};   (* 0x0008L *)
      DS_NOFAILCREATE     = WS_SET {WS__4};   (* 0x0010L *)
      DS_CONTROL          = WS_SET {WS__10};  (* 0x0400L *)
      DS_CENTER           = WS_SET {WS__11};  (* 0x0800L *)
      DS_CENTERMOUSE      = WS_SET {WS__12};  (* 0x1000L *)
      DS_CONTEXTHELP      = WS_SET {WS__13};  (* 0x2000L *)


CONST DM_GETDEFID   = WM_USER+0;
      DM_SETDEFID   = WM_USER+1;
      DM_REPOSITION = WM_USER+2;

      PSM_PAGEINFO      =  WM_USER+100;
      PSM_SHEETINFO     =  WM_USER+101;

      PSI_SETACTIVE     =  0001h;
      PSI_KILLACTIVE    =  0002h;
      PSI_APPLY         =  0003h;
      PSI_RESET         =  0004h;
      PSI_HASHELP       =  0005h;
      PSI_HELP          =  0006h;

      PSI_CHANGED       =  0001h;
      PSI_GUISTART      =  0002h;
      PSI_REBOOT        =  0003h;
      PSI_GETSIBLINGS   =  0004h;

(* Returned in HIWORD () of DM_GETDEFID result if msg is supported *)

CONST DC_HASDEFID  = 534Bh;

(* Dialog Codes (return value of WM_GETDLGCODE *)

TYPE DLGC_ENUM = (DLGC__WANTARROWS,      (* 0 - Control wants arrow keys         *)
                  DLGC__WANTTAB,         (* 1 - Control wants tab keys           *)
                  DLGC__WANTALLKEYS,     (* 2 - Control wants all keys           *)
                  DLGC__HASSETSEL,       (* 3 - Understands EM_SETSEL message    *)
                  DLGC__DEFPUSHBUTTON,   (* 4 - Default pushbutton               *)
                  DLGC__UNDEFPUSHBUTTON, (* 5 - Non-default pushbutton           *)
                  DLGC__RADIOBUTTON,     (* 6 - Radio button                     *)
                  DLGC__WANTCHARS,       (* 7 - Want WM_CHAR messages            *)
                  DLGC__STATIC,          (* 8 - Static item: don't include       *)
                  DLGC__9, DLGC__10,
                  DLGC__11,DLGC__12,
                  DLGC__BUTTON);         (* 13- Button item: can be checked      *)

CONST DLGC__WANTMESSAGE = DLGC__WANTALLKEYS; (* 2 *)

TYPE  DLGC_SET = SET OF DLGC_ENUM;

(* Dialog Codes (return value of WM_GETDLGCODE *)

CONST DLGC_WANTARROWS      = DLGC_SET {DLGC__WANTARROWS      }; (* 0001h *)
      DLGC_WANTTAB         = DLGC_SET {DLGC__WANTTAB         }; (* 0002h *)
      DLGC_WANTALLKEYS     = DLGC_SET {DLGC__WANTALLKEYS     }; (* 0004h *)
      DLGC_WANTMESSAGE     = DLGC_SET {DLGC__WANTMESSAGE     }; (* 0004h *)
      DLGC_HASSETSEL       = DLGC_SET {DLGC__HASSETSEL       }; (* 0008h *)
      DLGC_DEFPUSHBUTTON   = DLGC_SET {DLGC__DEFPUSHBUTTON   }; (* 0010h *)
      DLGC_UNDEFPUSHBUTTON = DLGC_SET {DLGC__UNDEFPUSHBUTTON }; (* 0020h *)
      DLGC_RADIOBUTTON     = DLGC_SET {DLGC__RADIOBUTTON     }; (* 0040h *)
      DLGC_WANTCHARS       = DLGC_SET {DLGC__WANTCHARS       }; (* 0080h *)
      DLGC_STATIC          = DLGC_SET {DLGC__STATIC          }; (* 0100h *)
      DLGC_BUTTON          = DLGC_SET {DLGC__BUTTON          }; (* 2000h *)

CONST LB_CTLCODE = 0;

(*
 * Listbox messages Return Values
 *)

CONST LB_OKAY     = SYSTEM.CAST (LRESULT, VAL (LONG, 0));
      LB_ERR      = SYSTEM.CAST (LRESULT, VAL (LONG, -1));
      LB_ERRSPACE = SYSTEM.CAST (LRESULT, VAL (LONG, -2));

(* Listbox Notification Codes *)

CONST LBN_ERRSPACE       = -2;
      LBN_SELCHANGE      =  1;
      LBN_DBLCLK         =  2;
      LBN_SELCANCEL      =  3;
      LBN_SETFOCUS       =  4;
      LBN_KILLFOCUS      =  5;

(*
 * Listbox messages
 *)

CONST LB_ADDSTRING            = 0180h;
      LB_INSERTSTRING         = 0181h;
      LB_DELETESTRING         = 0182h;
      LB_SELITEMRANGEEX       = 0183h;
      LB_RESETCONTENT         = 0184h;
      LB_SETSEL               = 0185h;
      LB_SETCURSEL            = 0186h;
      LB_GETSEL               = 0187h;
      LB_GETCURSEL            = 0188h;
      LB_GETTEXT              = 0189h;
      LB_GETTEXTLEN           = 018Ah;
      LB_GETCOUNT             = 018Bh;
      LB_SELECTSTRING         = 018Ch;
      LB_DIR                  = 018Dh;
      LB_GETTOPINDEX          = 018Eh;
      LB_FINDSTRING           = 018Fh;
      LB_GETSELCOUNT          = 0190h;
      LB_GETSELITEMS          = 0191h;
      LB_SETTABSTOPS          = 0192h;
      LB_GETHORIZONTALEXTENT  = 0193h;
      LB_SETHORIZONTALEXTENT  = 0194h;
      LB_SETCOLUMNWIDTH       = 0195h;
      LB_ADDFILE              = 0196h;
      LB_SETTOPINDEX          = 0197h;
      LB_GETITEMRECT          = 0198h;
      LB_GETITEMDATA          = 0199h;
      LB_SETITEMDATA          = 019Ah;
      LB_SELITEMRANGE         = 019Bh;
      LB_SETANCHORINDEX       = 019Ch;
      LB_GETANCHORINDEX       = 019Dh;
      LB_SETCARETINDEX        = 019Eh;
      LB_GETCARETINDEX        = 019Fh;
      LB_SETITEMHEIGHT        = 01A0h;
      LB_GETITEMHEIGHT        = 01A1h;
      LB_FINDSTRINGEXACT      = 01A2h;
      LB_SETLOCALE            = 01A5h;
      LB_GETLOCALE            = 01A6h;
      LB_SETCOUNT             = 01A7h;
      LB_INITSTORAGE          = 01A8h;
      LB_ITEMFROMPOINT        = 01A9h;
      LB_MSGMAX               = 01B0h;

(* Listbox Styles *)

CONST LBS_NOTIFY            = WS_SET {WS__0};   (* 0x0001L *)
      LBS_SORT              = WS_SET {WS__1};   (* 0x0002L *)
      LBS_NOREDRAW          = WS_SET {WS__2};   (* 0x0004L *)
      LBS_MULTIPLESEL       = WS_SET {WS__3};   (* 0x0008L *)
      LBS_OWNERDRAWFIXED    = WS_SET {WS__4};   (* 0x0010L *)
      LBS_OWNERDRAWVARIABLE = WS_SET {WS__5};   (* 0x0020L *)
      LBS_HASSTRINGS        = WS_SET {WS__6};   (* 0x0040L *)
      LBS_USETABSTOPS       = WS_SET {WS__7};   (* 0x0080L *)
      LBS_NOINTEGRALHEIGHT  = WS_SET {WS__8};   (* 0x0100L *)
      LBS_MULTICOLUMN       = WS_SET {WS__9};   (* 0x0200L *)
      LBS_WANTKEYBOARDINPUT = WS_SET {WS__10};  (* 0x0400L *)
      LBS_EXTENDEDSEL       = WS_SET {WS__11};  (* 0x0800L *)
      LBS_DISABLENOSCROLL   = WS_SET {WS__12};  (* 0x1000L *)
      LBS_NODATA            = WS_SET {WS__13};  (* 0x2000L *)
      LBS_NOSEL             = WS_SET {WS__14};  (* 0x4000L *)
      LBS_STANDARD          = LBS_NOTIFY + LBS_SORT + WS_VSCROLL + WS_BORDER;

(*
 * Combo Box return Values
 *)

CONST CB_OKAY     = SYSTEM.CAST (LRESULT, VAL (LONG, 0));
      CB_ERR      = SYSTEM.CAST (LRESULT, VAL (LONG, -1));
      CB_ERRSPACE = SYSTEM.CAST (LRESULT, VAL (LONG, -2));

(* Combo Box Notification Codes *)

CONST CBN_ERRSPACE       = -1;
      CBN_SELCHANGE      =  1;
      CBN_DBLCLK         =  2;
      CBN_SETFOCUS       =  3;
      CBN_KILLFOCUS      =  4;
      CBN_EDITCHANGE     =  5;
      CBN_EDITUPDATE     =  6;
      CBN_DROPDOWN       =  7;
      CBN_CLOSEUP        =  8;
      CBN_SELENDOK       =  9;
      CBN_SELENDCANCEL   = 10;

(* Combo Box styles *)

CONST CBS_SIMPLE            = WS_SET {WS__0};       (* 0x0001L *)
      CBS_DROPDOWN          = WS_SET {WS__1};       (* 0x0002L *)
      CBS_DROPDOWNLIST      = WS_SET {WS__1,WS__0}; (* 0x0003L *)
      CBS_OWNERDRAWFIXED    = WS_SET {WS__4};       (* 0x0010L *)
      CBS_OWNERDRAWVARIABLE = WS_SET {WS__5};       (* 0x0020L *)
      CBS_AUTOHSCROLL       = WS_SET {WS__6};       (* 0x0040L *)
      CBS_OEMCONVERT        = WS_SET {WS__7};       (* 0x0080L *)
      CBS_SORT              = WS_SET {WS__8};       (* 0x0100L *)
      CBS_HASSTRINGS        = WS_SET {WS__9};       (* 0x0200L *)
      CBS_NOINTEGRALHEIGHT  = WS_SET {WS__10};      (* 0x0400L *)
      CBS_DISABLENOSCROLL   = WS_SET {WS__11};      (* 0x0800L *)
      CBS_UPPERCASE         = WS_SET {WS__13};      (* 0x2000L *)
      CBS_LOWERCASE         = WS_SET {WS__14};      (* 0x4000L *)

(*
 * Combo Box messages
 *)

CONST CB_GETEDITSEL               = 0140h;
      CB_LIMITTEXT                = 0141h;
      CB_SETEDITSEL               = 0142h;
      CB_ADDSTRING                = 0143h;
      CB_DELETESTRING             = 0144h;
      CB_DIR                      = 0145h;
      CB_GETCOUNT                 = 0146h;
      CB_GETCURSEL                = 0147h;
      CB_GETLBTEXT                = 0148h;
      CB_GETLBTEXTLEN             = 0149h;
      CB_INSERTSTRING             = 014Ah;
      CB_RESETCONTENT             = 014Bh;
      CB_FINDSTRING               = 014Ch;
      CB_SELECTSTRING             = 014Dh;
      CB_SETCURSEL                = 014Eh;
      CB_SHOWDROPDOWN             = 014Fh;
      CB_GETITEMDATA              = 0150h;
      CB_SETITEMDATA              = 0151h;
      CB_GETDROPPEDCONTROLRECT    = 0152h;
      CB_SETITEMHEIGHT            = 0153h;
      CB_GETITEMHEIGHT            = 0154h;
      CB_SETEXTENDEDUI            = 0155h;
      CB_GETEXTENDEDUI            = 0156h;
      CB_GETDROPPEDSTATE          = 0157h;
      CB_FINDSTRINGEXACT          = 0158h;
      CB_SETLOCALE                = 0159h;
      CB_GETLOCALE                = 015Ah;
      CB_GETTOPINDEX              = 015Bh;
      CB_SETTOPINDEX              = 015Ch;
      CB_GETHORIZONTALEXTENT      = 015Dh;
      CB_SETHORIZONTALEXTENT      = 015Eh;
      CB_GETDROPPEDWIDTH          = 015Fh;
      CB_SETDROPPEDWIDTH          = 0160h;
      CB_INITSTORAGE              = 0161h;
      CB_MSGMAX                   = 0162h;

(* Scroll Bar Styles  *)

CONST SBS_HORZ                    = WS_SET { };      (* 0x0000L *)
      SBS_VERT                    = WS_SET {WS__0};  (* 0x0001L *)
      SBS_TOPALIGN                = WS_SET {WS__1};  (* 0x0002L *)
      SBS_LEFTALIGN               = WS_SET {WS__1};  (* 0x0002L *)
      SBS_BOTTOMALIGN             = WS_SET {WS__2};  (* 0x0004L *)
      SBS_RIGHTALIGN              = WS_SET {WS__2};  (* 0x0004L *)
      SBS_SIZEBOXTOPLEFTALIGN     = WS_SET {WS__1};  (* 0x0002L *)
      SBS_SIZEBOXBOTTOMRIGHTALIGN = WS_SET {WS__2};  (* 0x0004L *)
      SBS_SIZEBOX                 = WS_SET {WS__3};  (* 0x0008L *)
      SBS_SIZEGRIP                = WS_SET {WS__4};  (* 0x0010L *)

(*
 * Scroll bar messages
 *)

CONST SBM_SETPOS                  = 00E0h;
      SBM_GETPOS                  = 00E1h;
      SBM_SETRANGE                = 00E2h;
      SBM_SETRANGEREDRAW          = 00E6h;
      SBM_GETRANGE                = 00E3h;
      SBM_ENABLE_ARROWS           = 00E4h;
      SBM_SETSCROLLINFO           = 00E9h;
      SBM_GETSCROLLINFO           = 00EAh;

TYPE SIF_ENUM = (SIF__RANGE,           (* 0 *)
                 SIF__PAGE,            (* 1 *)
                 SIF__POS,             (* 2 *)
                 SIF__DISABLENOSCROLL, (* 3 *)
                 SIF__TRACKPOS);       (* 4 *)

     SIF_SET = SET OF SIF_ENUM;

CONST SIF_RANGE           = SIF_SET {SIF__RANGE           }; (* 0x0001 *)
      SIF_PAGE            = SIF_SET {SIF__PAGE            }; (* 0x0002 *)
      SIF_POS             = SIF_SET {SIF__POS             }; (* 0x0004 *)
      SIF_DISABLENOSCROLL = SIF_SET {SIF__DISABLENOSCROLL }; (* 0x0008 *)
      SIF_TRACKPOS        = SIF_SET {SIF__TRACKPOS        }; (* 0x0010 *)

      SIF_ALL = SIF_RANGE + SIF_PAGE + SIF_POS + SIF_TRACKPOS;

TYPE SCROLLINFO = RECORD
                         cbSize    : UINT;
                         fMask     : SIF_SET;
                         nMin      : INTEGER;
                         nMax      : INTEGER;
                         nPage     : UINT;
                         nPos      : INTEGER;
                         nTrackPos : INTEGER;
                  END;
    PSCROLLINFO = POINTER TO SCROLLINFO;

<* IF BACKEND # "C" THEN *>
PROCEDURE SetScrollInfo (hwnd : HWND; sbtype : SB_TYPE;
                         si : SCROLLINFO (*!*); redraw : BOOL) : INTEGER;
<* ELSE *>
PROCEDURE SetScrollInfo (hwnd : HWND; sbtype : SB_TYPE;
                         si : PSCROLLINFO (*!*); redraw : BOOL) : INTEGER;
<* END *>
PROCEDURE GetScrollInfo (hwnd : HWND; sbtype : SB_TYPE;
                         VAR si : SCROLLINFO) : BOOL;

(* MDI client style *)

CONST MDIS_ALLCHILDSTYLES = WS_SET {WS__0};

(* wParam Flags for WM_MDITILE and WM_MDICASCADE messages. *)

CONST MDITILE_VERTICAL     =  0;  (* not in win3.1 *)
      MDITILE_HORIZONTAL   =  1;  (* not in win3.1 *)
      MDITILE_SKIPDISABLED =  2;  (* not in win3.1 *)

TYPE MDICREATESTRUCTA = RECORD
                             szClass : PCSTR;
                             szTitle : PCSTR;
                             hOwner  : HANDLE;
                             x, y,
                             cx, cy  : INTEGER;
                             style   : DWORD;
                             lParam  : LPARAM;      (* app-defined stuff *)
                        END;
    PMDICREATESTRUCTA = POINTER TO MDICREATESTRUCT;

TYPE MDICREATESTRUCTW = RECORD
                             szClass : PCWSTR;
                             szTitle : PCWSTR;
                             hOwner  : HANDLE;
                             x, y,
                             cx, cy  : INTEGER;
                             style   : DWORD;
                             lParam  : LPARAM;      (* app-defined stuff *)
                        END;
    PMDICREATESTRUCTW = POINTER TO MDICREATESTRUCT;


<* IF DEFINED (UNICODE) THEN *>
      TYPE MDICREATESTRUCT  = MDICREATESTRUCTW;
           PMDICREATESTRUCT = PMDICREATESTRUCTW;
<* ELSE *>
      TYPE MDICREATESTRUCT  = MDICREATESTRUCTA;
           PMDICREATESTRUCT = PMDICREATESTRUCTA;

<* END *>

TYPE CLIENTCREATESTRUCT = RECORD
                               hWindowMenu : HANDLE;
                               idFirstChild : UINT;
                          END;

PROCEDURE DefFrameProcA (hWnd : HWND; hWndMDIClient : HWND;
                         Msg : UINT; wParam : WPARAM; lParam : LPARAM) : LRESULT;
PROCEDURE DefFrameProcW (hWnd : HWND; hWndMDIClient : HWND;
                         Msg : UINT; wParam : WPARAM; lParam : LPARAM) : LRESULT;

PROCEDURE DefMDIChildProcA (hWnd : HWND; Msg : UINT;
                            wParam : WPARAM; lParam : LPARAM) : LRESULT;
PROCEDURE DefMDIChildProcW (hWnd : HWND; Msg : UINT;
                            wParam : WPARAM; lParam : LPARAM) : LRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST DefFrameProc    = DefFrameProcW;
            DefMDIChildProc = DefMDIChildProcW;
<* ELSE *>
      CONST DefFrameProc    = DefFrameProcA;
            DefMDIChildProc = DefMDIChildProcA;
<* END *>

PROCEDURE TranslateMDISysAccel (WndClient : HWND; VAR Msg : MSG) : BOOL;

PROCEDURE ArrangeIconicWindows (hWnd : HWND) : UINT;

PROCEDURE CreateMDIWindowA (ClassName     : ATOMSTR;
                            WindowName    : ARRAY OF CHAR;
                            Style         : WS_SET;
                            X, Y,
                            Width, Height : INTEGER;
                            hWndParent    : HWND;
                            hInstance     : HINSTANCE;
                            lParam        : LPARAM)    : HWND;

PROCEDURE CreateMDIWindowW (lpClassName   : ATOMWSTR;
                            lpWindowName  : ARRAY OF WCHAR;
                            Style         : WS_SET;
                            X, Y,
                            Width, Height : INTEGER;
                            hWndParent    : HWND;
                            hInstance     : HINSTANCE;
                            lParam        : LPARAM)    : HWND;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateMDIWindow = CreateMDIWindowW;
<* ELSE *>
      CONST CreateMDIWindow = CreateMDIWindowA;
<* END *>


PROCEDURE TileWindows    (Parent : HWND;
                          wHow   : UINT;
                          Rect   : PRECT; (* NIL *)
                          cKids  : UINT;
                          VAR [NIL] Kids : ARRAY OF HWND) : WORD;

PROCEDURE CascadeWindows (Parent : HWND;
                          wHow   : UINT;
                          Rect   : PRECT; (* NIL *)
                          cKids  : UINT;
                          VAR [NIL] Kids : ARRAY OF HWND) : WORD;

TYPE HELPPOLY = DWORD;

TYPE MULTIKEYHELPA = RECORD
                            mkSize      : DWORD;
                            mkKeylist   : CHAR;
                            szKeyphrase : ARRAY [0..0] OF CHAR;
                     END;
    PMULTIKEYHELPA = POINTER TO MULTIKEYHELPA;

     MULTIKEYHELPW = RECORD
                            mkSize      : DWORD;
                            mkKeylist   : WCHAR;
                            szKeyphrase : ARRAY [0..0] OF WCHAR;
                     END;
    PMULTIKEYHELPW = POINTER TO MULTIKEYHELPW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE MULTIKEYHELP  = MULTIKEYHELPW;
           PMULTIKEYHELP = PMULTIKEYHELPW;
<* ELSE *>
      TYPE MULTIKEYHELP  = MULTIKEYHELPA;
           PMULTIKEYHELP = PMULTIKEYHELPA;
<* END *>


TYPE HELPWININFOA = RECORD
                           wStructSize  : INTEGER;
                           x, y, dx, dy : INTEGER;
                           wMax         : INTEGER;
                           rgchMember   : ARRAY [0..1] OF CHAR;
                    END;
    PHELPWININFOA = POINTER TO HELPWININFOA;

TYPE HELPWININFOW = RECORD
                           wStructSize  : INTEGER;
                           x, y, dx, dy : INTEGER;
                           wMax         : INTEGER;
                           rgchMember   : ARRAY [0..1] OF WCHAR;
                    END;
    PHELPWININFOW = POINTER TO HELPWININFOW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE HELPWININFO  = HELPWININFOW;
           PHELPWININFO = PHELPWININFOW;
<* ELSE *>
      TYPE HELPWININFO  = HELPWININFOA;
           PHELPWININFO = PHELPWININFOA;
<* END *>

(*
 * Commands to pass to WinHelp()
 *)
CONST HELP_CONTEXT      = 0001h;  (* Display topic in ulTopic *)
      HELP_QUIT         = 0002h;  (* Terminate help *)
      HELP_INDEX        = 0003h;  (* Display index *)
      HELP_CONTENTS     = 0003h;
      HELP_HELPONHELP   = 0004h;  (* Display help on using help *)
      HELP_SETINDEX     = 0005h;  (* Set current Index for multi index help *)
      HELP_SETCONTENTS  = 0005h;
      HELP_CONTEXTPOPUP = 0008h;
      HELP_FORCEFILE    = 0009h;
      HELP_KEY          = 0101h;  (* Display topic for keyword in offabData *)
      HELP_COMMAND      = 0102h;
      HELP_PARTIALKEY   = 0105h;
      HELP_MULTIKEY     = 0201h;
      HELP_SETWINPOS    = 0203h;
      HELP_CONTEXTMENU  = 000Ah;
      HELP_FINDER       = 000Bh;
      HELP_WM_HELP      = 000Ch;
      HELP_SETPOPUP_POS = 000Dh;

      HELP_TCARD              = 8000h;
      HELP_TCARD_DATA         = 0010h;
      HELP_TCARD_OTHER_CALLER = 0011h;

(* These are in winhelp.h in Win95. *)
      IDH_NO_HELP             = 28440;
      IDH_MISSING_CONTEXT     = 28441; (* Control doesn't have matching help context *)
      IDH_GENERIC_HELP_BUTTON = 28442; (* Property sheet help button *)
      IDH_OK                  = 28443;
      IDH_CANCEL              = 28444;
      IDH_HELP                = 28445;


PROCEDURE WinHelpA (hWndMain : HWND;
                    lpszHelp : ARRAY OF CHAR;
                    uCommand : UINT;
                    dwData   : DWORD) : BOOL;

PROCEDURE WinHelpW (hWndMain : HWND;
                    lpszHelp : ARRAY OF WCHAR;
                    uCommand : UINT;
                    dwData   : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST WinHelp = WinHelpW;
<* ELSE *>
      CONST WinHelp = WinHelpA;
<* END *>

(*
 * Parameter for SystemParametersInfo()
 *)

TYPE SPI_ACTION = UINT;

CONST SPI_GETBEEP               =  1;
      SPI_SETBEEP               =  2;
      SPI_GETMOUSE              =  3;
      SPI_SETMOUSE              =  4;
      SPI_GETBORDER             =  5;
      SPI_SETBORDER             =  6;
      SPI_GETKEYBOARDSPEED      =  0;
      SPI_SETKEYBOARDSPEED      = 11;
      SPI_LANGDRIVER            = 12;
      SPI_ICONHORIZONTALSPACING = 13;
      SPI_GETSCREENSAVETIMEOUT  = 14;
      SPI_SETSCREENSAVETIMEOUT  = 15;
      SPI_GETSCREENSAVEACTIVE   = 16;
      SPI_SETSCREENSAVEACTIVE   = 17;
      SPI_GETGRIDGRANULARITY    = 18;
      SPI_SETGRIDGRANULARITY    = 19;
      SPI_SETDESKWALLPAPER      = 20;
      SPI_SETDESKPATTERN        = 21;
      SPI_GETKEYBOARDDELAY      = 22;
      SPI_SETKEYBOARDDELAY      = 23;
      SPI_ICONVERTICALSPACING   = 24;
      SPI_GETICONTITLEWRAP      = 25;
      SPI_SETICONTITLEWRAP      = 26;
      SPI_GETMENUDROPALIGNMENT  = 27;
      SPI_SETMENUDROPALIGNMENT  = 28;
      SPI_SETDOUBLECLKWIDTH     = 29;
      SPI_SETDOUBLECLKHEIGHT    = 30;
      SPI_GETICONTITLELOGFONT   = 31;
      SPI_SETDOUBLECLICKTIME    = 32;
      SPI_SETMOUSEBUTTONSWAP    = 33;
      SPI_SETICONTITLELOGFONT   = 34;
      SPI_GETFASTTASKSWITCH     = 35;
      SPI_SETFASTTASKSWITCH     = 36;
      SPI_SETDRAGFULLWINDOWS    = 37;
      SPI_GETDRAGFULLWINDOWS    = 38;
      SPI_GETNONCLIENTMETRICS   = 41;
      SPI_SETNONCLIENTMETRICS   = 42;
      SPI_GETMINIMIZEDMETRICS   = 43;
      SPI_SETMINIMIZEDMETRICS   = 44;
      SPI_GETICONMETRICS        = 45;
      SPI_SETICONMETRICS        = 46;
      SPI_SETWORKAREA           = 47;
      SPI_GETWORKAREA           = 48;
      SPI_SETPENWINDOWS         = 49;

      SPI_GETHIGHCONTRAST       = 66;
      SPI_SETHIGHCONTRAST       = 67;
      SPI_GETKEYBOARDPREF       = 68;
      SPI_SETKEYBOARDPREF       = 69;
      SPI_GETSCREENREADER       = 70;
      SPI_SETSCREENREADER       = 71;
      SPI_GETANIMATION          = 72;
      SPI_SETANIMATION          = 73;
      SPI_GETFONTSMOOTHING      = 74;
      SPI_SETFONTSMOOTHING      = 75;
      SPI_SETDRAGWIDTH          = 76;
      SPI_SETDRAGHEIGHT         = 77;
      SPI_SETHANDHELD           = 78;
      SPI_GETLOWPOWERTIMEOUT    = 79;
      SPI_GETPOWEROFFTIMEOUT    = 80;
      SPI_SETLOWPOWERTIMEOUT    = 81;
      SPI_SETPOWEROFFTIMEOUT    = 82;
      SPI_GETLOWPOWERACTIVE     = 83;
      SPI_GETPOWEROFFACTIVE     = 84;
      SPI_SETLOWPOWERACTIVE     = 85;
      SPI_SETPOWEROFFACTIVE     = 86;
      SPI_SETCURSORS            = 87;
      SPI_SETICONS              = 88;
      SPI_GETDEFAULTINPUTLANG   = 89;
      SPI_SETDEFAULTINPUTLANG   = 90;
      SPI_SETLANGTOGGLE         = 91;
      SPI_GETWINDOWSEXTENSION   = 92;
      SPI_SETMOUSETRAILS        = 93;
      SPI_GETMOUSETRAILS        = 94;
      SPI_SCREENSAVERRUNNING    = 97;

      SPI_GETFILTERKEYS         = 50;
      SPI_SETFILTERKEYS         = 51;
      SPI_GETTOGGLEKEYS         = 52;
      SPI_SETTOGGLEKEYS         = 53;
      SPI_GETMOUSEKEYS          = 54;
      SPI_SETMOUSEKEYS          = 55;
      SPI_GETSHOWSOUNDS         = 56;
      SPI_SETSHOWSOUNDS         = 57;
      SPI_GETSTICKYKEYS         = 58;
      SPI_SETSTICKYKEYS         = 59;
      SPI_GETACCESSTIMEOUT      = 60;
      SPI_SETACCESSTIMEOUT      = 61;
      SPI_GETSERIALKEYS         = 62;
      SPI_SETSERIALKEYS         = 63;
      SPI_GETSOUNDSENTRY        = 64;
      SPI_SETSOUNDSENTRY        = 65;
      SPI_GETSNAPTODEFBUTTON    = 95;
      SPI_SETSNAPTODEFBUTTON    = 96;
      SPI_GETMOUSEHOVERWIDTH    = 98;
      SPI_SETMOUSEHOVERWIDTH    = 99;
      SPI_GETMOUSEHOVERHEIGHT   =100;
      SPI_SETMOUSEHOVERHEIGHT   =101;
      SPI_GETMOUSEHOVERTIME     =102;
      SPI_SETMOUSEHOVERTIME     =103;
      SPI_GETWHEELSCROLLLINES   =104;
      SPI_SETWHEELSCROLLLINES   =105;

TYPE  SPIF_ENUM = (SPIF__UPDATEINIFILE,     (* 0 *)
                   SPIF__SENDWININICHANGE); (* 1 *)
      SPIF_SET = SET OF SPIF_ENUM;

CONST SPIF_UPDATEINIFILE    = SPIF_SET {SPIF__UPDATEINIFILE};    (* 0x0001 *)
      SPIF_SENDWININICHANGE = SPIF_SET {SPIF__SENDWININICHANGE}; (* 0x0002 *)
      SPIF_SENDCHANGE       = SPIF_SENDWININICHANGE;

CONST METRICS_USEDEFAULT = -1;

TYPE NONCLIENTMETRICSA = RECORD
                                cbSize           : UINT;
                                iBorderWidth     : INTEGER;
                                iScrollWidth     : INTEGER;
                                iScrollHeight    : INTEGER;
                                iCaptionWidth    : INTEGER;
                                iCaptionHeight   : INTEGER;
                                lfCaptionFont    : LOGFONTA;
                                iSmCaptionWidth  : INTEGER;
                                iSmCaptionHeight : INTEGER;
                                lfSmCaptionFont  : LOGFONTA;
                                iMenuWidth       : INTEGER;
                                iMenuHeight      : INTEGER;
                                lfMenuFont       : LOGFONTA;
                                lfStatusFont     : LOGFONTA;
                                lfMessageFont    : LOGFONTA;
                         END;
    PNONCLIENTMETRICSA = POINTER TO NONCLIENTMETRICSA;

     NONCLIENTMETRICSW = RECORD
                                cbSize           : UINT;
                                iBorderWidth     : INTEGER;
                                iScrollWidth     : INTEGER;
                                iScrollHeight    : INTEGER;
                                iCaptionWidth    : INTEGER;
                                iCaptionHeight   : INTEGER;
                                lfCaptionFont    : LOGFONTW;
                                iSmCaptionWidth  : INTEGER;
                                iSmCaptionHeight : INTEGER;
                                lfSmCaptionFont  : LOGFONTW;
                                iMenuWidth       : INTEGER;
                                iMenuHeight      : INTEGER;
                                lfMenuFont       : LOGFONTW;
                                lfStatusFont     : LOGFONTW;
                                lfMessageFont    : LOGFONTW;
                         END;
    PNONCLIENTMETRICSW = POINTER TO NONCLIENTMETRICSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE NONCLIENTMETRICS  = NONCLIENTMETRICSW;
           PNONCLIENTMETRICS = PNONCLIENTMETRICSW;
<* ELSE *>
      TYPE NONCLIENTMETRICS  = NONCLIENTMETRICSA;
           PNONCLIENTMETRICS = PNONCLIENTMETRICSA;
<* END *>


(* Positions and directions of minimized windows;
   for use in MINIMIZEDMETRICS structure and SM_ARRANGE values in
   GetSystemMetrics ()
*)


TYPE ARW_ENUM = (ARW__0, ARW__1, ARW__2, ARW__3);
     ARW_SET  = SET OF ARW_ENUM;

CONST ARW_BOTTOMLEFT   = ARW_SET {                              }; (* 0x0000L *)
      ARW_BOTTOMRIGHT  = ARW_SET {                        ARW__0}; (* 0x0001L *)
      ARW_TOPLEFT      = ARW_SET {                ARW__1        }; (* 0x0002L *)
      ARW_TOPRIGHT     = ARW_SET {                ARW__1, ARW__0}; (* 0x0003L *)
      ARW_STARTMASK    = ARW_SET {                ARW__1, ARW__0}; (* 0x0003L *)
      ARW_STARTRIGHT   = ARW_SET {                        ARW__0}; (* 0x0001L *)
      ARW_STARTTOP     = ARW_SET {                ARW__1        }; (* 0x0002L *)

      ARW_LEFT         = ARW_SET {                              }; (* 0x0000L *)
      ARW_RIGHT        = ARW_SET {                              }; (* 0x0000L *)
      ARW_UP           = ARW_SET {        ARW__2                }; (* 0x0004L *)
      ARW_DOWN         = ARW_SET {        ARW__2                }; (* 0x0004L *)
      ARW_HIDE         = ARW_SET {ARW__3                        }; (* 0x0008L *)

      ARW_VALID        = ARW_SET {ARW__3, ARW__2, ARW__1, ARW__0}; (* 0x000FL *)

TYPE MINIMIZEDMETRICS = RECORD
                               cbSize : UINT;
                               iWidth : INTEGER;
                               iHorzGap : INTEGER;
                               iVertGap : INTEGER;
                               iArrange : ARW_SET;
                        END;
    PMINIMIZEDMETRICS = POINTER TO MINIMIZEDMETRICS;

TYPE ICONMETRICSA = RECORD
                           cbSize       : UINT;
                           iHorzSpacing : INTEGER;
                           iVertSpacing : INTEGER;
                           iTitleWrap   : INTEGER;
                           lfFont       : LOGFONTA;
                    END;
    PICONMETRICSA = POINTER TO ICONMETRICSA;

TYPE ICONMETRICSW = RECORD
                           cbSize       : UINT;
                           iHorzSpacing : INTEGER;
                           iVertSpacing : INTEGER;
                           iTitleWrap   : INTEGER;
                           lfFont       : LOGFONTW;
                    END;
    PICONMETRICSW = POINTER TO ICONMETRICSA;

<* IF DEFINED (UNICODE) THEN *>
      TYPE ICONMETRICS  = ICONMETRICSW;
           PICONMETRICS = PICONMETRICSW;
<* ELSE *>
      TYPE ICONMETRICS  = ICONMETRICSA;
           PICONMETRICS = PICONMETRICSA;
<* END *>

TYPE ANIMATIONINFO  = RECORD
                             cbSize      : UINT;
                             iMinAnimate : INTEGER;
                      END;
    PANIMATIONINFO = POINTER TO ANIMATIONINFO;

(* flags for SERIALKEYS dwFlags field *)

TYPE SERKF_ENUM = (SERKF__SERIALKEYSON, (* 0 *)
                   SERKF__AVAILABLE,    (* 1 *)
                   SERKF__INDICATOR);   (* 2 *)

     SERKF_SET = SET OF SERKF_ENUM;

CONST SERKF_SERIALKEYSON = SERKF_SET {SERKF__SERIALKEYSON}; (* 0x00000001 *)
      SERKF_AVAILABLE    = SERKF_SET {SERKF__AVAILABLE   }; (* 0x00000002 *)
      SERKF_INDICATOR    = SERKF_SET {SERKF__INDICATOR   }; (* 0x00000004 *)


TYPE SERIALKEYSA = RECORD
                          cbSize         : UINT;
                          dwFlags        : SERKF_SET;
                          lpszActivePort : PSTR;
                          lpszPort       : PSTR;
                          iBaudRate      : UINT;
                          iPortState     : UINT;
                          iActive        : UINT;
     END;
    PSERIALKEYSA = POINTER TO SERIALKEYSA;

     SERIALKEYSW = RECORD
                          cbSize         : UINT;
                          dwFlags        : SERKF_SET;
                          lpszActivePort : PWSTR;
                          lpszPort       : PWSTR;
                          iBaudRate      : UINT;
                          iPortState     : UINT;
                          iActive        : UINT;
     END;
    PSERIALKEYSW = POINTER TO SERIALKEYSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE SERIALKEYS  = SERIALKEYSW;
           PSERIALKEYS = PSERIALKEYSW;
<* ELSE *>
      TYPE SERIALKEYS  = SERIALKEYSA;
           PSERIALKEYS = PSERIALKEYSA;
<* END *>

(* flags for HIGHCONTRAST dwFlags field *)

TYPE HCF_ENUM = (HCF__HIGHCONTRASTON,   (* 0 *)
                 HCF__AVAILABLE,        (* 1 *)
                 HCF__HOTKEYACTIVE,     (* 2 *)
                 HCF__CONFIRMHOTKEY,    (* 3 *)
                 HCF__HOTKEYSOUND,      (* 4 *)
                 HCF__INDICATOR,        (* 5 *)
                 HCF__HOTKEYAVAILABLE); (* 6 *)
     HCF_SET = SET OF HCF_ENUM;

CONST HCF_HIGHCONTRASTON  = HCF_SET {HCF__HIGHCONTRASTON  }; (* 0x00000001 *)
      HCF_AVAILABLE       = HCF_SET {HCF__AVAILABLE       }; (* 0x00000002 *)
      HCF_HOTKEYACTIVE    = HCF_SET {HCF__HOTKEYACTIVE    }; (* 0x00000004 *)
      HCF_CONFIRMHOTKEY   = HCF_SET {HCF__CONFIRMHOTKEY   }; (* 0x00000008 *)
      HCF_HOTKEYSOUND     = HCF_SET {HCF__HOTKEYSOUND     }; (* 0x00000010 *)
      HCF_INDICATOR       = HCF_SET {HCF__INDICATOR       }; (* 0x00000020 *)
      HCF_HOTKEYAVAILABLE = HCF_SET {HCF__HOTKEYAVAILABLE }; (* 0x00000040 *)

TYPE HIGHCONTRASTA = RECORD
                            cbSize  : UINT;
                            dwFlags : HCF_SET;
                            lpszDefaultScheme : PSTR;
                     END;
    PHIGHCONTRASTA = POINTER TO HIGHCONTRASTA;

     HIGHCONTRASTW = RECORD
                            cbSize  : UINT;
                            dwFlags : HCF_SET;
                            lpszDefaultScheme : PWSTR;
                     END;
    PHIGHCONTRASTW = POINTER TO HIGHCONTRASTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE HIGHCONTRAST  = HIGHCONTRASTW;
           PHIGHCONTRAST = PHIGHCONTRASTW;
<* ELSE *>
      TYPE HIGHCONTRAST  = HIGHCONTRASTA;
           PHIGHCONTRAST = PHIGHCONTRASTA;
<* END *>


(* Flags for ChangeDisplaySettings *)

TYPE CDS_ENUM = (CDS__UPDATEREGISTRY, (* 0 *)
                 CDS__TEST,           (* 1 *)
                 CDS__FULLSCREEN,     (* 2 *)
                 CDS__GLOBAL,         (* 3 *)
                 CDS__SET_PRIMARY,    (* 4 *)
                 CDS__5,CDS__6,CDS__7,CDS__8,
                 CDS__9,CDS__10,CDS__11,CDS__12,
                 CDS__13,CDS__14,CDS__15,CDS__16,
                 CDS__17,CDS__18,CDS__19,CDS__20,
                 CDS__21,CDS__22,CDS__23,CDS__24,
                 CDS__25,CDS__26,CDS__27,
                 CDS__NORESET,        (* 28 *)
                 CDS__SETRECT,        (* 29 *)
                 CDS__RESET);         (* 30 *)

     CDS_SET = SET OF CDS_ENUM;

CONST CDS_UPDATEREGISTRY  = CDS_SET {CDS__UPDATEREGISTRY}; (* 0x00000001 *)
      CDS_TEST            = CDS_SET {CDS__TEST          }; (* 0x00000002 *)
      CDS_FULLSCREEN      = CDS_SET {CDS__FULLSCREEN    }; (* 0x00000004 *)
      CDS_GLOBAL          = CDS_SET {CDS__GLOBAL        }; (* 0x00000008 *)
      CDS_SET_PRIMARY     = CDS_SET {CDS__SET_PRIMARY   }; (* 0x00000010 *)
      CDS_RESET           = CDS_SET {CDS__RESET         }; (* 0x40000000 *)
      CDS_SETRECT         = CDS_SET {CDS__SETRECT       }; (* 0x20000000 *)
      CDS_NORESET         = CDS_SET {CDS__NORESET       }; (* 0x10000000 *)

(* Return values  for ChangeDisplaySettings *)

CONST DISP_CHANGE_SUCCESSFUL  =  0;
      DISP_CHANGE_RESTART     =  1;
      DISP_CHANGE_FAILED      = -1;
      DISP_CHANGE_BADMODE     = -2;
      DISP_CHANGE_NOTUPDATED  = -3;
      DISP_CHANGE_BADFLAGS    = -4;
      DISP_CHANGE_BADPARAM    = -5;

PROCEDURE ChangeDisplaySettingsA (lpDevMode : PDEVMODEA (* IN NIL *); dwFlags : CDS_SET) : LONG;
PROCEDURE ChangeDisplaySettingsW (lpDevMode : PDEVMODEW (* IN NIL *); dwFlags : CDS_SET) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST ChangeDisplaySettings = ChangeDisplaySettingsW;
<* ELSE *>
      CONST ChangeDisplaySettings = ChangeDisplaySettingsA;
<* END *>

PROCEDURE ChangeDisplaySettingsExA (lpszDeviceName : PCSTR;
                                    lpDevMode : PDEVMODEA (* IN NIL *);
                                    hwnd : HWND;
                                    dwFlags : CDS_SET;
                                    lparam : PVOID) : LONG;
PROCEDURE ChangeDisplaySettingsExW (lpszDeviceName : PCWSTR;
                                    lpDevMode : PDEVMODEW (* IN NIL *);
                                    hwnd : HWND;
                                    dwFlags : CDS_SET;
                                    lparam : PVOID) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST ChangeDisplaySettingsEx = ChangeDisplaySettingsExW;
<* ELSE *>
      CONST ChangeDisplaySettingsEx = ChangeDisplaySettingsExA;
<* END *>

CONST ENUM_CURRENT_SETTINGS  = SYSTEM.CAST (DWORD, VAL (LONG, -1));
      ENUM_REGISTRY_SETTINGS = SYSTEM.CAST (DWORD, VAL (LONG, -2));

PROCEDURE EnumDisplaySettingsA (lpszDeviceName : PCSTR; (* NIL *)
                                iModeNum : DWORD;
                                VAR DevMode : DEVMODEA) : BOOL;

PROCEDURE EnumDisplaySettingsW (lpszDeviceName : PCWSTR; (* NIL *)
                                iModeNum : DWORD;
                                VAR DevMode : DEVMODEW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumDisplaySettings = EnumDisplaySettingsW;
<* ELSE *>
      CONST EnumDisplaySettings = EnumDisplaySettingsA;
<* END *>

PROCEDURE SystemParametersInfoA (uiAction : SPI_ACTION;
                                 uiParam  : UINT;
                                 pvParam  : PVOID;
                                 fWinIni  : UINT) : BOOL;

PROCEDURE SystemParametersInfoW (uiAction : SPI_ACTION;
                                 uiParam  : UINT;
                                 pvParam  : PVOID;
                                 fWinIni  : UINT) : BOOL;
<* IF DEFINED (UNICODE) THEN *>
      CONST SystemParametersInfo = SystemParametersInfoW;
<* ELSE *>
      CONST SystemParametersInfo = SystemParametersInfoA;
<* END *>


(*
 * Accessibility support
 *)

(*
 * FILTERKEYS dwFlags field
 *)

TYPE FKF_ENUM = (FKF__FILTERKEYSON,   (* 0 *)
                 FKF__AVAILABLE,      (* 1 *)
                 FKF__HOTKEYACTIVE,   (* 2 *)
                 FKF__CONFIRMHOTKEY,  (* 3 *)
                 FKF__HOTKEYSOUND,    (* 4 *)
                 FKF__INDICATOR,      (* 5 *)
                 FKF__CLICKON);       (* 6 *)

     FKF_SET = SET OF FKF_ENUM;

CONST FKF_FILTERKEYSON    = FKF_SET {FKF__FILTERKEYSON }; (* 0x00000001 *)
      FKF_AVAILABLE       = FKF_SET {FKF__AVAILABLE    }; (* 0x00000002 *)
      FKF_HOTKEYACTIVE    = FKF_SET {FKF__HOTKEYACTIVE }; (* 0x00000004 *)
      FKF_CONFIRMHOTKEY   = FKF_SET {FKF__CONFIRMHOTKEY}; (* 0x00000008 *)
      FKF_HOTKEYSOUND     = FKF_SET {FKF__HOTKEYSOUND  }; (* 0x00000010 *)
      FKF_INDICATOR       = FKF_SET {FKF__INDICATOR    }; (* 0x00000020 *)
      FKF_CLICKON         = FKF_SET {FKF__CLICKON      }; (* 0x00000040 *)

TYPE FILTERKEYS = RECORD
                         cbSize      : UINT;
                         dwFlags     : FKF_SET;
                         iWaitMSec   : DWORD;          (* Acceptance Delay   *)
                         iDelayMSec  : DWORD;          (* Delay Until Repeat *)
                         iRepeatMSec : DWORD;          (* Repeat Rate        *)
                         iBounceMSec : DWORD;          (* Debounce Time      *)
                  END;
    PFILTERKEYS = POINTER TO FILTERKEYS;

(*
 * STICKYKEYS dwFlags field
 *)
TYPE SKF_ENUM = (SKF__STICKYKEYSON,    (* 0 *)
                 SKF__AVAILABLE,       (* 1 *)
                 SKF__HOTKEYACTIVE,    (* 2 *)
                 SKF__CONFIRMHOTKEY,   (* 3 *)
                 SKF__HOTKEYSOUND,     (* 4 *)
                 SKF__INDICATOR,       (* 5 *)
                 SKF__AUDIBLEFEEDBACK, (* 6 *)
                 SKF__TRISTATE,        (* 7 *)
                 SKF__TWOKEYSOFF);     (* 8 *)

     SKF_SET = SET OF SKF_ENUM;

CONST SKF_STICKYKEYSON    = SKF_SET {SKF__STICKYKEYSON   }; (* 0x00000001 *)
      SKF_AVAILABLE       = SKF_SET {SKF__AVAILABLE      }; (* 0x00000002 *)
      SKF_HOTKEYACTIVE    = SKF_SET {SKF__HOTKEYACTIVE   }; (* 0x00000004 *)
      SKF_CONFIRMHOTKEY   = SKF_SET {SKF__CONFIRMHOTKEY  }; (* 0x00000008 *)
      SKF_HOTKEYSOUND     = SKF_SET {SKF__HOTKEYSOUND    }; (* 0x00000010 *)
      SKF_INDICATOR       = SKF_SET {SKF__INDICATOR      }; (* 0x00000020 *)
      SKF_AUDIBLEFEEDBACK = SKF_SET {SKF__AUDIBLEFEEDBACK}; (* 0x00000040 *)
      SKF_TRISTATE        = SKF_SET {SKF__TRISTATE       }; (* 0x00000080 *)
      SKF_TWOKEYSOFF      = SKF_SET {SKF__TWOKEYSOFF     }; (* 0x00000100 *)


TYPE STICKYKEYS = RECORD
                         cbSiz   : UINT;
                         dwFlags : SKF_SET;
                  END;
    PSTICKYKEYS = POINTER TO STICKYKEYS;

(*
 * MOUSEKEYS dwFlags field
 *)

TYPE MKF_ENUM = (MKF__MOUSEKEYSON,     (* 0 *)
                 MKF__AVAILABLE,       (* 1 *)
                 MKF__HOTKEYACTIVE,    (* 2 *)
                 MKF__CONFIRMHOTKEY,   (* 3 *)
                 MKF__HOTKEYSOUND,     (* 4 *)
                 MKF__INDICATOR,       (* 5 *)
                 MKF__MODIFIERS,       (* 6 *)
                 MKF__REPLACENUMBERS); (* 7 *)

     MKF_SET = SET OF MKF_ENUM;

CONST MKF_MOUSEKEYSON     = MKF_SET {MKF__MOUSEKEYSON    }; (* 0x00000001 *)
      MKF_AVAILABLE       = MKF_SET {MKF__AVAILABLE      }; (* 0x00000002 *)
      MKF_HOTKEYACTIVE    = MKF_SET {MKF__HOTKEYACTIVE   }; (* 0x00000004 *)
      MKF_CONFIRMHOTKEY   = MKF_SET {MKF__CONFIRMHOTKEY  }; (* 0x00000008 *)
      MKF_HOTKEYSOUND     = MKF_SET {MKF__HOTKEYSOUND    }; (* 0x00000010 *)
      MKF_INDICATOR       = MKF_SET {MKF__INDICATOR      }; (* 0x00000020 *)
      MKF_MODIFIERS       = MKF_SET {MKF__MODIFIERS      }; (* 0x00000040 *)
      MKF_REPLACENUMBERS  = MKF_SET {MKF__REPLACENUMBERS }; (* 0x00000080 *)


TYPE MOUSEKEYS = RECORD
                        cbSize          : UINT;
                        dwFlags         : MKF_SET;
                        iMaxSpeed       : DWORD;
                        iTimeToMaxSpeed : DWORD;
                        iCtrlSpeed      : DWORD;
                        dwReserved1     : DWORD;
                        dwReserved2     : DWORD;
                 END;
    PMOUSEKEYS = POINTER TO MOUSEKEYS;

(*
 * ACCESSTIMEOUT dwFlags field
 *)
TYPE ATF_ENUM = (ATF__TIMEOUTON,      (* 0 *)
                 ATF__ONOFFFEEDBACK); (* 1 *)
     ATF_SET = SET OF ATF_ENUM;

CONST ATF_TIMEOUTON     = ATF_SET {ATF__TIMEOUTON};     (* 0x00000001 *)
      ATF_ONOFFFEEDBACK = ATF_SET {ATF__ONOFFFEEDBACK}; (* 0x00000002 *)


TYPE ACCESSTIMEOUT = RECORD
                            cbSize : UINT;
                            dwFlags : ATF_SET;
                            iTimeOutMSec : DWORD;
                     END;
    PACCESSTIMEOUT = POINTER TO ACCESSTIMEOUT;

(* values for SOUNDSENTRY iFSGrafEffect field *)

TYPE SSGF_ENUM = (SSGF_NONE,       (* 0 *)
                  SSGF_0, SSGF_1,
                  SSGF_DISPLAY);   (* 3 *)

(* values for SOUNDSENTRY iFSTextEffect field *)

TYPE SSTF_ENUM = (SSTF_NONE,     (* 0 *)
                  SSTF_CHARS,    (* 1 *)
                  SSTF_BORDER,   (* 2 *)
                  SSTF_DISPLAY); (* 3 *)

(* values for SOUNDSENTRY iWindowsEffect field *)

TYPE SSWF_ENUM = (SSWF_NONE,    (* 0 *)
                  SSWF_TITLE,   (* 1 *)
                  SSWF_WINDOW,  (* 2 *)
                  SSWF_DISPLAY, (* 3 *)
                  SSWF_CUSTOM); (* 4 *)


(*
 * SOUNDSENTRY dwFlags field
 *)
TYPE SSF_ENUM = (SSF__SOUNDSENTRYON, (* 0 *)
                 SSF__AVAILABLE,     (* 1 *)
                 SSF__INDICATOR);    (* 2 *)
     SSF_SET = SET OF SSF_ENUM;

CONST SSF_SOUNDSENTRYON   = SSF_SET {SSF__SOUNDSENTRYON}; (* 0x00000001 *)
      SSF_AVAILABLE       = SSF_SET {SSF__AVAILABLE    }; (* 0x00000002 *)
      SSF_INDICATOR       = SSF_SET {SSF__INDICATOR    }; (* 0x00000004 *)

TYPE SOUNDSENTRYA = RECORD
                           cbSize                 : UINT;
                           dwFlags                : SSF_SET;
                           iFSTextEffect          : SSTF_ENUM;
                           iFSTextEffectMSec      : DWORD;
                           iFSTextEffectColorBits : DWORD;
                           iFSGrafEffect          : SSGF_ENUM;
                           iFSGrafEffectMSec      : DWORD;
                           iFSGrafEffectColor     : DWORD;
                           iWindowsEffect         : SSWF_ENUM;
                           iWindowsEffectMSec     : DWORD;
                           lpszWindowsEffectDLL   : PSTR;
                           iWindowsEffectOrdinal  : DWORD;
                    END;
    PSOUNDSENTRYA = POINTER TO SOUNDSENTRYA;

TYPE SOUNDSENTRYW = RECORD
                           cbSize                 : UINT;
                           dwFlags                : SSF_SET;
                           iFSTextEffect          : SSTF_ENUM;
                           iFSTextEffectMSec      : DWORD;
                           iFSTextEffectColorBits : DWORD;
                           iFSGrafEffect          : SSGF_ENUM;
                           iFSGrafEffectMSec      : DWORD;
                           iFSGrafEffectColor     : DWORD;
                           iWindowsEffect         : SSWF_ENUM;
                           iWindowsEffectMSec     : DWORD;
                           lpszWindowsEffectDLL   : PWSTR;
                           iWindowsEffectOrdinal  : DWORD;
                    END;
    PSOUNDSENTRYW = POINTER TO SOUNDSENTRYW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE SOUNDSENTRY  = SOUNDSENTRYW;
           PSOUNDSENTRY = PSOUNDSENTRYW;
<* ELSE *>
      TYPE SOUNDSENTRY  = SOUNDSENTRYA;
           PSOUNDSENTRY = PSOUNDSENTRYA;
<* END *>

(*
 * TOGGLEKEYS dwFlags field
 *)

TYPE TKF_ENUM = (TKF__TOGGLEKEYSON,  (* 0 *)
                 TKF__AVAILABLE,     (* 1 *)
                 TKF__HOTKEYACTIVE,  (* 2 *)
                 TKF__CONFIRMHOTKEY, (* 3 *)
                 TKF__HOTKEYSOUND,   (* 4 *)
                 TKF__INDICATOR);    (* 5 *)

     TKF_SET = SET OF TKF_ENUM;

CONST TKF_TOGGLEKEYSON    = TKF_SET {TKF__TOGGLEKEYSON   }; (* 0x00000001 *)
      TKF_AVAILABLE       = TKF_SET {TKF__AVAILABLE      }; (* 0x00000002 *)
      TKF_HOTKEYACTIVE    = TKF_SET {TKF__HOTKEYACTIVE   }; (* 0x00000004 *)
      TKF_CONFIRMHOTKEY   = TKF_SET {TKF__CONFIRMHOTKEY  }; (* 0x00000008 *)
      TKF_HOTKEYSOUND     = TKF_SET {TKF__HOTKEYSOUND    }; (* 0x00000010 *)
      TKF_INDICATOR       = TKF_SET {TKF__INDICATOR      }; (* 0x00000020 *)


TYPE TOGGLEKEYS = RECORD
                         cbSize : UINT;
                         dwFlags : TKF_SET;
                  END;
    PTOGGLEKEYS = POINTER TO TOGGLEKEYS;


(*
 * Set debug level
 *)

PROCEDURE SetDebugErrorLevel (dwLevel : DWORD);

PROCEDURE SetLastErrorEx (dwErrCode : DWORD; dwType : SLE_ENUM);

END WinUser.
